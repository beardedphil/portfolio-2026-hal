---
description: "Done" requires commit + push (all agents)
alwaysApply: true
---

# “Done” Means Committed + Pushed (All Agents)

- **FORBIDDEN:** Sending a "done" or summary message while the working tree has uncommitted/unpushed changes. Commit and push first; then summarize.

## Start of task: feature branch first (prevents lost work)

- **MANDATORY:** Before making **any** file changes for a ticket, create/checkout the feature branch. This is non-negotiable. See also **no-edits-on-main.mdc**.
- **Required first step** (before the first edit):
  1. Run `git status -sb`. Note the current branch.
  2. If you are on **`main`**: do **not** use StrReplace, Write, or EditNotebook. Run `git checkout -b ticket/<id>-<short-title-kebab>` (or `git checkout ticket/<id>-...` if it exists remotely) first.
  3. Feature branch name: `ticket/<id>-<short-title-kebab>` (e.g. ticket 0030 → `ticket/0030-ticket-list-add-delete-button-and-sync-deletion-to-filesystem`).
  4. Only after you are on the feature branch may you edit files.
- **FORBIDDEN:** Implementing ticket work on `main`. If you realize you edited on `main`: run `git checkout -b ticket/<id>-...` — uncommitted changes move with you; commit on the feature branch.
- **Why:** Edits on `main` conflate work, can be lost on stash/reset, and violate branching policy. Branch first.

## Branching policy (feature branches required)

- For ticketed work, agents must work on a **feature branch**, not directly on `main`.
  - Branch naming: `ticket/<id>-<short-title-kebab>` (example: `ticket/0003-hal-chat-hal-agents`).
- “Ready / done” requires:
  - the feature branch is **pushed** to remote, and
  - `git status -sb` shows the branch is **synced** and the working tree is **clean**.


 QA performs code review + automated verification (no manual UI testing), then merges to main and moves the ticket to Human in the Loop for user testing. The implementation agent must add the branch name to the ticket (see ticket template), then may claim “ready/done.”

## Cloud QA branch access limitation (implementation agent workflow)

- **Scenario:** Implementation cloud agent can create/push a feature branch, but the separate QA cloud agent **cannot access non-`main` branches** (e.g., due to cloud environment restrictions). This is the standard workflow for cloud agents.
- **When ready for QA:** The implementation agent must:
  1. Verify the feature branch is clean and pushed to remote.
  2. **Merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0056): merge feature branch to main for cloud QA access`).
  3. Push `main` to remote.
  4. **Update the ticket body** (in Supabase, then run `npm run sync-tickets`) with:
     - The feature branch name used (e.g., `ticket/0056-implementation`)
     - A note that changes were merged to `main` due to cloud QA branch access limits
     - An **"Artifacts" section** (see below) listing links/paths to all required audit artifacts
  5. Mark the ticket as "Merged to main for QA" (add this note to the ticket body).
  6. Then send the completion/summary message including the branch name, merge note, and `git status -sb`.
- **Why:** Cloud QA agents may only have access to `main` branch. Merging to `main` makes the changes accessible for QA review and testing.

## Artifacts section requirement (implementation agent)

- **When marking a ticket ready for QA:** The implementation agent **must** add an **"Artifacts" section** to the ticket body (in Supabase, then run `npm run sync-tickets`).
- **Required format:** The "Artifacts" section must list links/paths to all required audit files under `docs/audit/<task-id>-<short-title>/`:
  - `plan.md`
  - `worklog.md`
  - `changed-files.md`
  - `decisions.md`
  - `verification.md`
  - `pm-review.md`
- **Link format:** Paths are acceptable as "links" (they are clickable in most editors). Paths must match the canonical folder naming: `<task-id>-<short-title-kebab>` (e.g., `docs/audit/0056-implementation/plan.md`).
- **Example Artifacts section:**
  ```
  ## Artifacts
  
  - [plan.md](docs/audit/0056-implementation/plan.md)
  - [worklog.md](docs/audit/0056-implementation/worklog.md)
  - [changed-files.md](docs/audit/0056-implementation/changed-files.md)
  - [decisions.md](docs/audit/0056-implementation/decisions.md)
  - [verification.md](docs/audit/0056-implementation/verification.md)
  - [pm-review.md](docs/audit/0056-implementation/pm-review.md)
  ```
- **Why:** This ensures all audit artifacts are traceable from the Kanban UI, making work fully auditable without requiring access to the repo structure.

## Sequence: push first, then summarize

- The moment you **think** you're done (implementation complete, audit written, etc.) is when you **commit and push** — not after you've already told the user.
- **First:** commit all relevant changes, **push the feature branch** to GitHub, **merge the feature branch into `main`** (with a commit message that includes the ticket ID), push `main`, and **update the ticket body** with the branch name, merge note, and the **"Artifacts" section** (see "Artifacts section requirement" above).
- **Then:** tell the user what was done (summary, verification, audit location, **branch name**). Do not give the long "here's what I did" report until after push + ticket update.
- If you summarize first and then commit/push (or forget to add the branch to the ticket), you did it in the wrong order.

## Before you reply: the gate

- **If you are about to send a message** that summarizes completed work, or that includes any of: "done", "complete", "ready", "looks good", "here's what I did", "Implementation complete", "Summary:", or similar — **STOP**.
- **First** run: `git status -sb`. If there are any `M` (modified) or `??` (untracked) relevant to the task: run `git add`, `git commit -m '...'` (with ticket ID in subject), `git push` (feature branch), then **merge the feature branch into `main`** (with a commit message that includes the ticket ID), push `main`, and **update the ticket body** with the branch name, merge note, and the **"Artifacts" section** (see "Artifacts section requirement" above). Then run `git status -sb` again.
- **Only after** the working tree is clean, the feature branch is pushed, and the **branch name is added to the ticket** may you send that message — and your message **must** include the **branch name** and the exact `git status -sb` output.
- If you have not yet committed and pushed, do **not** send a "done" or summary message; do the commit and push in this same turn, then reply.

## Requirements

- If any agent believes a task/story is **done**, they must:
  - **commit** all relevant changes, and
  - **push** to the remote
  before telling the user or project manager that it’s done.
- Agents must not delegate commit/push work to the user/PM (e.g., “after you commit and push…”).
  - If commit/push hasn’t happened yet, the correct status is **“not ready for verification.”**
- “Done/ready” messages must include the **feature branch name** (so QA can check out and verify) and the exact `git status -sb` output showing the branch is synced and the working tree is clean.
  - “Clean” means: **no modified files** and **no untracked files** (ignored build artifacts are fine).

## Commit message linkage (no commit hashes in docs)

- Every commit that belongs to a ticket must include the ticket ID in the commit subject (e.g. `feat(0010): ...`, `fix(0008): ...`, `docs(0009): ...`).
- If a ticket requires follow-up commits after an initial “feat/fix” commit, those follow-up commits must also include the same ticket ID in the subject.
  - Do not “sneak in” ticket work under unlabeled commits like `chore: ...` if it still belongs to the ticket.
- If `git status -sb` is not clean/synced, the agent must say **“not ready for verification”** and keep working until it is.
  - Do not claim “ready” if `git status` shows any `??` (untracked) or `M` (modified) entries.

## PM verification

- The project manager’s “done” is only **candidate-complete** until the user verifies the acceptance criteria.
- Do not use language like “done” or “complete” until changes are committed and pushed.
