---
description: "Done" requires commit + push (all agents)
alwaysApply: true
---

# “Done” Means Committed + Pushed (All Agents)

- **FORBIDDEN:** Sending a "done" or summary message while the working tree has uncommitted/unpushed changes. Commit and push first; then summarize.

## Implementation Agent Completion Checklist (MANDATORY)

**Before sending ANY summary message, verify ALL of these are complete:**

- [ ] Code implemented and tested
- [ ] All changes committed to feature branch (with ticket ID in commit message)
- [ ] Feature branch pushed to remote
- [ ] **All 6 artifacts stored in Supabase** (plan, worklog, changed-files, decisions, verification, pm-review)
- [ ] **Artifacts verified** via `/api/artifacts/get` - all 6 present
- [ ] Feature branch merged to `main`
- [ ] `main` pushed to remote
- [ ] Feature branch deleted (local and remote)
- [ ] HAL dev server restarted on latest `main`
- [ ] Ticket body updated with branch name and merge confirmation
- [ ] Ticket moved to QA column (if applicable)
- [ ] `git status -sb` shows clean working tree on `main`

**Only after ALL items are checked may you send a summary message.**

## Start of task: feature branch first (prevents lost work)

- **MANDATORY:** Before making **any** file changes for a ticket, create/checkout the feature branch. This is non-negotiable. See also **no-edits-on-main.mdc**.
- **Required first step** (before the first edit):
  1. Run `git status -sb`. Note the current branch.
  2. If you are on **`main`**: do **not** use StrReplace, Write, or EditNotebook. Run `git checkout -b ticket/<id>-<short-title-kebab>` (or `git checkout ticket/<id>-...` if it exists remotely) first.
  3. Feature branch name: `ticket/<id>-<short-title-kebab>` (e.g. ticket 0030 → `ticket/0030-ticket-list-add-delete-button-and-sync-deletion-to-filesystem`).
  4. Only after you are on the feature branch may you edit files.
- **FORBIDDEN:** Implementing ticket work on `main`. If you realize you edited on `main`: run `git checkout -b ticket/<id>-...` — uncommitted changes move with you; commit on the feature branch.
- **Why:** Edits on `main` conflate work, can be lost on stash/reset, and violate branching policy. Branch first.

## Branching policy (feature branches required)

- For ticketed work, agents must work on a **feature branch**, not directly on `main`.
  - Branch naming: `ticket/<id>-<short-title-kebab>` (example: `ticket/0003-hal-chat-hal-agents`).
- “Ready / done” requires:
  - the feature branch is **pushed** to remote, and
  - `git status -sb` shows the branch is **synced** and the working tree is **clean**.


 QA performs code review + automated verification (no manual UI testing), then merges to main and moves the ticket to Human in the Loop for user testing. The implementation agent must add the branch name to the ticket (see ticket template), then may claim “ready/done.”

## Cloud QA branch access limitation (implementation agent workflow)

- **Scenario:** Implementation cloud agent can create/push a feature branch, but the separate QA cloud agent **cannot access non-`main` branches** (e.g., due to cloud environment restrictions). This is the standard workflow for cloud agents.
- **When ready for QA:** The implementation agent must:
  1. Verify the feature branch is clean and pushed to remote.
  2. **Store all required artifacts in Supabase** by including tool calls in your message:
     ```json
     {
       "tool": "insert_implementation_artifact",
       "params": {
         "ticketId": "0076",
         "artifactType": "plan",
         "title": "Plan for ticket 0076",
         "body_md": "# Plan\n\n..."
       }
     }
     ```
     (Repeat for each required artifact: plan, worklog, changed-files, decisions, verification, pm-review)
  3. **Merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0056): merge feature branch to main for cloud QA access`).
  4. Push `main` to remote.
  5. **Kill HAL** (`npx --yes kill-port 5173 5174`), **pull from main** (`git pull origin main`), **restart HAL** (`npm run dev` in background).
  6. **Update the ticket body** by including a tool call in your message:
     ```json
     {
       "tool": "update_ticket_body",
       "params": {
         "ticketId": "0076",
         "body_md": "# Updated ticket body with branch name, merge note, etc."
       }
     }
     ```
  7. Mark the ticket as "Merged to main for QA" (add this note to the ticket body).
  8. Then send the completion/summary message including the branch name, merge note, and `git status -sb`.
- **Why:** Cloud QA agents may only have access to `main` branch. Merging to `main` makes the changes accessible for QA review and testing.

## Artifacts storage requirement (implementation agent)

**MANDATORY:** The implementation agent **must** store all 6 required artifacts in Supabase **before** claiming the ticket is "ready for QA" or "done". This is non-negotiable.

- **When marking a ticket ready for QA:** The implementation agent **must** store all required artifacts in Supabase by sending tool calls in your messages.
- **Required artifacts** (all stored via tool call `insert_implementation_artifact`):
  - Plan (`artifactType: "plan"`, title: `Plan for ticket <ticket-id>`)
  - Worklog (`artifactType: "worklog"`, title: `Worklog for ticket <ticket-id>`)
  - Changed Files (`artifactType: "changed-files"`, title: `Changed Files for ticket <ticket-id>`)
  - Decisions (`artifactType: "decisions"`, title: `Decisions for ticket <ticket-id>`)
  - Verification (`artifactType: "verification"`, title: `Verification for ticket <ticket-id>`)
  - PM Review (`artifactType: "pm-review"`, title: `PM Review for ticket <ticket-id>`)
- **Storage method:** 
  - **Preferred:** If `.hal/api-base-url` exists, call HAL API directly: `POST ${baseUrl}/api/artifacts/insert-implementation` for each artifact.
  - **Fallback:** Write tool calls to `.hal-tool-call-queue.json` in the repo root.
- **Verification:** After storing artifacts, verify they were stored by calling `/api/artifacts/get` with the ticket ID. If any artifact is missing, store it again before claiming "ready".
- **FORBIDDEN:** Claiming "ready for QA", "done", or "complete" without storing all 6 required artifacts. QA will fail tickets with missing artifacts.
- **Why:** All artifacts are stored in Supabase's `agent_artifacts` table and linked to the ticket via `ticket_pk`. The Kanban UI can display these artifacts, making work fully auditable without requiring access to the repo structure. QA agents **will fail** tickets that are missing artifacts.

## Sequence: push first, merge to main, then summarize

- The moment you **think** you're done (implementation complete, audit written, etc.) is when you **commit and push** — not after you've already told the user.
- **First:** commit all relevant changes, **push the feature branch** to GitHub, **merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0060): merge feature branch to main`), push `main`, **delete the feature branch** (local and remote).
- **After merge, before summarizing (implementation agent):** After merging to `main` and pushing `main`, and before updating the ticket body or sending the summary message:
  1. **Kill HAL:** Stop the dev server (e.g. `npx --yes kill-port 5173 5174` to free HAL and Kanban ports).
  2. **Pull from main:** Run `git pull origin main` (you should already be on `main`).
  3. **Restart HAL:** Run `npm run dev` (in the background or in a dev terminal) so the app is running the latest `main`.
- Then **update the ticket body** by including a tool call in your message to update the ticket with the branch name, merge note, and a note that all artifacts are stored in Supabase.
- **Then:** tell the user what was done (summary, verification, audit location, **branch name**). Do not give the long "here's what I did" report until after push + merge + branch deletion + HAL restart + ticket update.
- **MANDATORY:** Always merge to main and delete the feature branch before sending any summary message. This applies to all implementation work, not just cloud QA scenarios.
- If you summarize first and then commit/push/merge (or forget to add the branch to the ticket), you did it in the wrong order.

## Before you reply: the gate

- **If you are about to send a message** that summarizes completed work, or that includes any of: "done", "complete", "ready", "looks good", "here's what I did", "Implementation complete", "Summary:", or similar — **STOP**.
- **First** run: `git status -sb`. If there are any `M` (modified) or `??` (untracked) relevant to the task: run `git add`, `git commit -m '...'` (with ticket ID in subject), `git push` (feature branch), **store all 6 required artifacts in Supabase** by calling HAL API directly or writing to queue file, **verify artifacts were stored** by calling `/api/artifacts/get`, then **merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0060): merge feature branch to main`), push `main`, **delete the feature branch** (local and remote). Then **kill HAL** (`npx --yes kill-port 5173 5174`), **pull from main** (`git pull origin main`), **restart HAL** (`npm run dev` in background), and **update the ticket body** by including a tool call in your message with the branch name, merge note, and a note that all artifacts are stored in Supabase. Then run `git status -sb` again.
- **Only after** the working tree is clean, **all 6 required artifacts are verified as stored in Supabase** (via `/api/artifacts/get`), the feature branch is merged to main, the branch is deleted, HAL has been restarted on latest main, and the **branch name is added to the ticket** may you send that message — and your message **must** include the **branch name** and the exact `git status -sb` output.
- **CRITICAL:** If artifact storage or verification fails, do **not** claim "ready" or "done". Fix the artifact storage issue first. QA will fail tickets with missing artifacts.
- **MANDATORY:** Always merge to main and delete the feature branch before sending any summary message. Never send a summary while still on a feature branch.
- If you have not yet committed, pushed, merged to main, and deleted the branch, do **not** send a "done" or summary message; do all of these steps in this same turn, then reply.

## Requirements

- If any agent believes a task/story is **done**, they must:
  - **commit** all relevant changes, and
  - **push** to the remote
  before telling the user or project manager that it’s done.
- Agents must not delegate commit/push work to the user/PM (e.g., “after you commit and push…”).
  - If commit/push hasn’t happened yet, the correct status is **“not ready for verification.”**
- “Done/ready” messages must include the **feature branch name** (so QA can check out and verify) and the exact `git status -sb` output showing the branch is synced and the working tree is clean.
  - “Clean” means: **no modified files** and **no untracked files** (ignored build artifacts are fine).

## Commit message linkage (no commit hashes in docs)

- Every commit that belongs to a ticket must include the ticket ID in the commit subject (e.g. `feat(0010): ...`, `fix(0008): ...`, `docs(0009): ...`).
- If a ticket requires follow-up commits after an initial “feat/fix” commit, those follow-up commits must also include the same ticket ID in the subject.
  - Do not “sneak in” ticket work under unlabeled commits like `chore: ...` if it still belongs to the ticket.
- If `git status -sb` is not clean/synced, the agent must say **“not ready for verification”** and keep working until it is.
  - Do not claim “ready” if `git status` shows any `??` (untracked) or `M` (modified) entries.

## PM verification

- The project manager’s “done” is only **candidate-complete** until the user verifies the acceptance criteria.
- Do not use language like “done” or “complete” until changes are committed and pushed.
