---
description: QA agents must store QA reports in Supabase via HAL API
alwaysApply: true
---

# QA Audit Report (QA Agents)

When you **QA a ticket** (verify, check a ticket that is allegedly complete), store a QA report via HAL API. See `docs/process/hal-tool-call-contract.mdc` for endpoints.

## Branch to use

- **If ticket states "merged to main for QA access":** Verify from `main`. Do not use feature branch. Record in report that verification was on `main`. **No merge needed** (already on main).
- **Otherwise:** Use feature branch from ticket. **MANDATORY:** If QA passes, you **MUST** merge the feature branch to `main` and delete the branch before completing QA. If QA fails, do not merge.

## 8 required implementation artifacts (must be present before QA)

1. plan, 2. worklog, 3. changed-files, 4. decisions, 5. verification, 6. pm-review, 7. git-diff, 8. instructions-used

**Changed Files:** Must be NON-EMPTY. When files changed: list paths with brief descriptions. When no files changed: state "No files changed." with reason. Blank/empty = PROCESS FAILURE.

**How to check:** `POST ${baseUrl}/api/artifacts/get` with `{ ticketId }`. Filter `agent_type === "implementation"`. Match titles `Plan for ticket X`, etc.

**Auto-fail:** API fails, any artifact missing, or Changed Files blank → QA FAIL immediately. Store QA report, move to `col-todo`, final message: `QA RESULT: FAIL — <ticket-id>`.

## QA report structure

1. Ticket & deliverable
2. Missing artifacts (if any) — list them, then fail
3. Audit artifacts present (if all present)
4. Code review — PASS/FAIL with evidence
5. Build verification — **MANDATORY:** `npm run build:hal`; TypeScript errors = FAIL
6. Coverage — **MANDATORY:** Whole-repo test coverage with 4-metric table and command used; see "Coverage section" below
7. Maintainability — **MANDATORY:** Whole-repo maintainability metric; see "Maintainability section" below
8. UI verification — automated and/or manual steps
9. AC Confirmation Checklist — enumerate each AC, Met/Not met with evidence; see `ac-confirmation-checklist.mdc`
10. Verdict — PASS or FAIL

## Coverage section

**MANDATORY:** Every QA report **MUST** include a **Coverage** section with:

1. **A 4-metric table** showing **whole-repo** coverage percentages (not just the ticket’s code):
   - Lines
   - Functions
   - Branches
   - Statements

2. **The command used** to generate the coverage numbers

**How to generate coverage:**

Run the **full** test suite with coverage (whole repo):

```bash
npm run test:coverage
```

This runs vitest with coverage over the entire codebase and outputs a text summary. Extract the overall coverage percentages from the output and include them in a table in the QA report. Do not run only tests for changed files; use the full suite.

**Coverage section format:**

```markdown
## Coverage

| Metric | Coverage |
|--------|----------|
| Lines | XX% |
| Functions | XX% |
| Branches | XX% |
| Statements | XX% |

**Command used:** `npm run test:coverage`
```

**Note:** Coverage numbers must reflect the current commit under test (not hardcoded). Run the command on the branch/commit being verified.

## Maintainability section

**MANDATORY:** Every QA report **MUST** include a **Maintainability** section with a single whole-repo percentage and concrete guidance.

**How to generate maintainability:**

Run the repo’s maintainability report (uses a maintainability library over the whole codebase):

```bash
npm run report:simplicity
```

The script prints a single line: `Simplicity: XX%`. **IMPORTANT:** Even though the script output says "Simplicity", you **MUST** use the label **"Maintainability"** (not "Simplicity") in your QA report. The word "Simplicity" should **NOT** appear anywhere in the user-visible QA report text.

**Maintainability section format:**

```markdown
## Maintainability

Maintainability: XX%

The maintainability metric measures code quality across the entire repository. Higher scores indicate:

- **Readability:** Code is clear, well-structured, and easy to understand
- **Testability:** Code is designed to be easily tested with good separation of concerns
- **Change safety:** Code changes are less likely to introduce bugs or break existing functionality
```

**CRITICAL:** 
- Use the exact heading `## Maintainability` (not "Simplicity" or any variation)
- Include all three bullets (Readability, Testability, Change safety) in your report
- Do not mention "Simplicity" anywhere in the QA report body

**Note:** Run this on the branch/commit being verified. The number is for the whole repo, not just the ticket’s changes.

## Storing QA report

Make actual HTTP calls: `POST ${baseUrl}/api/artifacts/insert-qa` with `{ ticketId, title, body_md }`. Use `curl` or run_terminal_cmd. Do not just include JSON in your message.

## Implementation Agent Note (for FAIL verdicts)

**MANDATORY:** When a ticket fails QA (or HITL), you **MUST** create a separate, concise "Implementation agent note" artifact that explains why the ticket failed. This note is for implementation agents to quickly understand what needs to be fixed.

**Format:**
- Title: `Implementation agent note for ticket HAL-XXXX` (preferred) or `Note for implementation agent: HAL-XXXX`
- Keep it short (2-4 bullet points max)
- Focus on actionable items
- No detailed analysis—just what's wrong and what to fix
- Implementation agents are required to check for this artifact first before starting work

**Example structure:**
```markdown
# Implementation Agent Note: HAL-XXXX

## Status: FAIL

## Why This Ticket Failed

1. **Issue 1:** Brief description
2. **Issue 2:** Brief description

## Required Actions

1. Action item 1
2. Action item 2
3. Action item 3

## Code Review Notes

Brief note if implementation is otherwise correct.
```

**Store via:** `POST ${baseUrl}/api/artifacts/insert-qa` with `{ ticketId, title: "Implementation agent note for ticket HAL-XXXX", body_md }`

## Completion

**CRITICAL: All ticket movements are AUTOMATIC - DO NOT wait for user interaction or ask for permission. Just move the tickets automatically.**

- **PASS:** 
 1. Store QA report
 2. **MANDATORY:** If feature branch exists (not already on main), merge feature branch to `main` and push to remote: `git checkout main && git merge <feature-branch> && git push origin main`
    - **CRITICAL:** Both `git merge` and `git push origin main` must succeed. If either fails:
      - **Retry with exponential backoff:** Attempt up to 4 times with delays (4s, 8s, 16s, 32s)
      - **If all retries fail:** Surface the error in the final summary message and **DO NOT** move the ticket to `col-human-in-the-loop`
      - **Keep ticket in QA:** The ticket must remain in its current column (or move to `col-todo` if appropriate) until merge/push succeeds
    - **Only after confirmed successful merge + push:** Proceed to step 3
 3. **MANDATORY:** Delete feature branch (local and remote): `git branch -d <feature-branch> && git push origin --delete <feature-branch>` (only if branch exists and merge/push succeeded)
    - **CRITICAL:** Branch deletion only happens after confirmed successful merge + push. If merge/push failed, do not delete the branch.
 4. **MANDATORY:** **AUTOMATICALLY** move ticket to `col-human-in-the-loop` **ONLY IF** merge and push both succeeded. If merge/push failed, do not move the ticket forward.
    - **Move ticket automatically using HAL API:**
    ```javascript
    const baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()
    const res = await fetch(`${baseUrl}/api/tickets/move`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ticketId: '<ticket-id>', columnId: 'col-human-in-the-loop' }),
    })
    const result = await res.json()
    // If move fails, log it but continue - system handles failures gracefully
    ```
    - **DO NOT ask user for permission - just move it automatically**
 5. Send summary. Final message must include: `QA RESULT: PASS — <ticket-id>`
    - **If merge/push failed:** Include error details in summary and state that ticket was not moved to HITL due to merge/push failure
- **FAIL:** 
 1. Store full QA report
 2. **MANDATORY:** Store Implementation agent note
 3. **AUTOMATICALLY** move ticket to `col-todo` using HAL API:
    ```javascript
    const baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()
    const res = await fetch(`${baseUrl}/api/tickets/move`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ticketId: '<ticket-id>', columnId: 'col-todo' }),
    })
    const result = await res.json()
    // If move fails, log it but continue - system handles failures gracefully
    ```
    - **DO NOT ask user for permission - just move it automatically**
 4. **Do NOT merge feature branch** (leave it for implementation agent to fix)
 5. Send summary. Final message must include: `QA RESULT: FAIL — <ticket-id>`
