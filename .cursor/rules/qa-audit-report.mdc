---
description: QA agents must store QA reports in Supabase via HAL API
alwaysApply: true
---

# QA Audit Report (QA Agents)

When you **QA a ticket** (e.g. user asks to "QA", "verify", or "check" a ticket that is allegedly complete), you **must** store a QA report in Supabase via HAL's API endpoints.

## Cloud QA workflow context

In cloud environments, QA agents may not have access to feature branches (only `main`). When this is the case, the implementation agent merges the feature branch to `main` before QA begins. QA must then verify from `main` rather than attempting to check out a feature branch. This workflow is indicated when the ticket states "merged to `main` for QA access" or similar language.

## Which branch to use (decision rule)

- **If the ticket or prompt states that the implementation was "merged to main for QA access"** (or that code is on `main` for QA): 
  - You **must** verify from the **`main`** branch. 
  - Do **not** attempt to locate, check out, or use the feature branch.
  - **Step 1:** Pull the latest `main` branch: `git checkout main && git pull origin main`
  - **Step 2:** Perform QA on `main` (code review and verification).
  - **Step 3:** Record in the QA report that verification was performed against `main` (e.g. "Verified on `main`; implementation was merged to main for QA access.").
  - **Step 4:** Store the QA report in Supabase via HAL API (see "Storing QA report" below).
  - **Step 5:** Move ticket to Human in the Loop via HAL API, then provide summary.
- **Otherwise:** use the feature branch named in the ticket's QA → Branch field (or the branch you were launched on). Perform QA on that branch, then follow the full workflow (merge to main, delete branch, etc.).

**Important:** When QA cannot access feature branches (cloud QA workflow), the implementation agent merges the feature branch to `main` before QA. In this case, QA must verify from `main` and record this in the QA report stored in Supabase.

## Required implementation artifacts (must be present before QA)

**MANDATORY:** Before performing any QA work, you **must** verify that all required implementation artifacts are present in Supabase. If any are missing, QA **must fail immediately** without attempting code review or verification.

**Required implementation artifacts:**
1. **Plan artifact** (`artifactType: "plan"`, title: `Plan for ticket <ticket-id>`)
2. **Worklog artifact** (`artifactType: "worklog"`, title: `Worklog for ticket <ticket-id>`)
3. **Changed Files artifact** (`artifactType: "changed-files"`, title: `Changed Files for ticket <ticket-id>`)
4. **Decisions artifact** (`artifactType: "decisions"`, title: `Decisions for ticket <ticket-id>`)
5. **Verification artifact** (`artifactType: "verification"`, title: `Verification for ticket <ticket-id>`)
6. **PM Review artifact** (`artifactType: "pm-review"`, title: `PM Review for ticket <ticket-id>`)

**How to check for artifacts:**
1. Use the `get_artifacts` tool to fetch all artifacts for the ticket:
   ```json
   {
     "tool": "get_artifacts",
     "params": {
       "ticketId": "0076"
     }
   }
   ```
2. Filter the returned artifacts to find implementation artifacts (where `agent_type === "implementation"`).
3. Check that all 6 required artifact types are present by matching artifact titles:
   - `Plan for ticket <ticket-id>`
   - `Worklog for ticket <ticket-id>`
   - `Changed Files for ticket <ticket-id>`
   - `Decisions for ticket <ticket-id>`
   - `Verification for ticket <ticket-id>`
   - `PM Review for ticket <ticket-id>`

**Auto-fail when artifacts are missing:**
- **If any required artifact is missing:** QA **must fail immediately**.
- **Do NOT** attempt code review, verification, or any other QA work.
- **Do NOT** attempt to "guess" or recreate missing artifacts.
- **Record a QA Fail outcome** by storing a QA report that clearly states the failure reason.
- **The QA report must enumerate the specific missing artifacts** (not just a generic "artifacts missing" message).
- **Store the QA report in Supabase** using `insert_qa_artifact` tool.
- **The final message must include:** `QA RESULT: FAIL — <ticket-id>` (see "Completion message format requirement" below).

**Example QA report when artifacts are missing:**
```markdown
# QA Report for ticket 0076

## Ticket & Deliverable
[Brief summary from ticket]

## Missing Required Implementation Artifacts

**QA FAILED:** Required implementation artifacts are missing. QA cannot proceed without complete implementation artifacts.

**Missing artifacts:**
- Plan artifact (`Plan for ticket 0076`)
- PM Review artifact (`PM Review for ticket 0076`)

**Present artifacts:**
- Worklog artifact
- Changed Files artifact
- Decisions artifact
- Verification artifact

## Verdict

**FAIL** — Implementation artifacts incomplete. Implementation agent must store all required artifacts before QA can proceed.

QA RESULT: FAIL — 0076
```

**If all required artifacts are present:** Proceed with normal QA workflow (code review, verification, etc.).

## Required artifact (QA report)

- **Storage:** Supabase `agent_artifacts` table (via HAL API endpoint `/api/artifacts/insert-qa`)
- **When:** After performing QA (code review and, if possible, UI verification) for a ticket, OR when auto-failing due to missing implementation artifacts.
- **Agent type:** `qa`
- **Title format:** `QA report for ticket <ticket-id>`

## QA report structure

1. **Ticket & deliverable** — One-line goal, deliverable, and acceptance criteria from the ticket.
2. **Missing Required Implementation Artifacts** (if applicable) — List of missing artifacts. If artifacts are missing, this section must be present and QA must fail.
3. **Audit artifacts** — Confirm all required implementation artifacts are present in Supabase (plan, worklog, changed-files, decisions, verification, pm-review). Only include this section if all artifacts are present.
4. **Code review** — PASS/FAIL with brief evidence (e.g. table of requirement vs implementation; file and line refs if helpful). Only include if artifacts are present.
5. **UI verification** — What was run: automated and/or manual steps. If automated UI was not run (e.g. native dialogs, login, or pickers), state that and list the manual steps the user should run. Only include if artifacts are present.
6. **Verdict** — Implementation complete? OK to merge? Any blocking manual verification? Must clearly state PASS or FAIL.

## Storing QA report

**Send a tool call to HAL in your message:**

Include this JSON block in your message:

```json
{
  "tool": "insert_qa_artifact",
  "params": {
    "ticketId": "0076",
    "title": "QA report for ticket 0076",
    "body_md": "# QA Report\n\n..."
  }
}
```

HAL will parse this from your message, execute it, and store the artifact in Supabase. You don't need API URLs or credentials - just include the JSON in your message.

## QA completion: do not hand off to the user

When the verdict is **PASS (OK to merge)**, QA must **complete the full workflow** — do not stop at a summary or "next steps for the user."

## Completion message format requirement

**MANDATORY:** The final completion message to the user **must** include the ticket ID and an explicit PASS/FAIL outcome token in a consistent, easy-to-spot format.

- **Format:** `QA RESULT: <PASS|FAIL> — <ticket-id>`
- **Examples:**
  - `QA RESULT: PASS — 0056`
  - `QA RESULT: FAIL — 0056`
- **Placement:** This must appear in the final summary message that QA sends to the user after completing all workflow steps (merge, branch deletion, ticket updates, etc.).
- **Why:** HAL needs to reliably parse QA outcomes from chat transcripts. The format must be human-verifiable (no external tooling required) and consistently structured for automated interpretation.
- **Verification:** A human can read the QA chat transcript in the app and immediately see the ticket ID and outcome without parsing complex prose.

**If you are verifying from the feature branch** (normal workflow):

1. **Store QA report in Supabase** — Include a tool call in your message:
   ```json
   {
     "tool": "insert_qa_artifact",
     "params": {
       "ticketId": "0076",
       "title": "QA report for ticket 0076",
       "body_md": "# QA Report\n\n..."
     }
   }
   ```
2. **Update ticket body** (optional) — If needed, include a tool call to update the ticket body:
   ```json
   {
     "tool": "update_ticket_body",
     "params": {
       "ticketId": "0076",
       "body_md": "# Updated ticket body..."
     }
   }
   ```
3. **Move ticket to Human in the Loop** — Include a tool call:
   ```json
   {
     "tool": "move_ticket_column",
     "params": {
       "ticketId": "0076",
       "columnId": "col-human-in-the-loop"
     }
   }
   ```
4. **Merge to main** — checkout `main`, merge the feature branch, push `main`.
5. **Delete the feature branch** — local and remote (see `delete-branch-after-merge.mdc`).
6. **Then** give your summary to the user. **The final message must include:** `QA RESULT: PASS — <ticket-id>` (see "Completion message format requirement" above).

**If you are verifying from `main`** (implementation was merged to main for QA access):

1. **Store QA report in Supabase** — Include a tool call in your message. Include a note in the report that verification was performed against `main`.
2. **Update ticket body** (optional) — If needed, include a tool call to note that verification was performed against `main`.
3. **Move ticket to Human in the Loop** — Include a tool call to move the ticket.
4. **Then** give your summary to the user. **The final message must include:** `QA RESULT: PASS — <ticket-id>` (see "Completion message format requirement" above).

Do not give a summary with "next steps" or "run these commands" — QA performs the merge (or confirms main) and branch deletion where applicable. The user receives the completed result.

- Use a commit subject that includes the ticket ID (e.g. `qa(0033): add QA report, move to Human in the Loop`).
- **If verdict is FAIL:** Do not merge. Store the QA report in Supabase only; summarize findings and recommend a bugfix ticket (see `bugfix-tracking.mdc`). **The final message must include:** `QA RESULT: FAIL — <ticket-id>` (see "Completion message format requirement" above).

## HAL Tool Call Contract

All Supabase operations are sent to HAL as **tool calls** in your messages. HAL parses and executes them automatically.

**Available tools:**

- **`insert_qa_artifact`** — Store QA report in Supabase
  - Params: `{ ticketId: string, title: string, body_md: string }`

- **`update_ticket_body`** — Update ticket body in Supabase
  - Params: `{ ticketId: string, body_md: string }`

- **`move_ticket_column`** — Move ticket to different column
  - Params: `{ ticketId: string, columnId: string }`

- **`get_ticket_content`** — Fetch ticket content
  - Params: `{ ticketId: string }`

**How to use:** Include tool calls as JSON blocks in your messages. HAL will parse and execute them. You don't need API URLs or credentials.

See `.cursor/rules/agent-supabase-api-paradigm.mdc` for full documentation.

## Scope

- Applies to any QA or verification of a **ticketed** task (ticket in Supabase).
- Keep the report concise; use bullets and tables where appropriate.
- All artifacts are stored in Supabase, not in `docs/audit/` folders.
