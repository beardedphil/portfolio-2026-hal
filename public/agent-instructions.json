{
  "index": {
    "basic": [
      "agent-instructions",
      "qa-audit-report",
      "heading-parsing-pitfalls",
      "code-location-citations",
      "code-citation-requirements",
      "state-management-change-documentation",
      "key-decisions-summary"
    ],
    "situational": {},
    "topics": {
      "agent-instructions": {
        "title": "Agent Instructions Entry Point",
        "description": "Entry point for agent instructions - load basic rules from Supabase",
        "agentTypes": [
          "all"
        ]
      },
      "code-location-citations": {
        "title": "Code Location Citations",
        "description": "Require agents to cite concrete code locations that reviewers can verify quickly",
        "agentTypes": [
          "all"
        ]
      },
      "code-citation-requirements": {
        "title": "Code Citation Requirements",
        "description": "Require agents to cite specific file paths and line numbers when referencing code locations",
        "agentTypes": [
          "all"
        ]
      },
      "state-management-change-documentation": {
        "title": "State Management Change Documentation",
        "description": "Require agents to document and justify any changes to application state management in review artifacts",
        "agentTypes": [
          "all"
        ]
      },
      "key-decisions-summary": {
        "title": "Key Decisions Summary Requirement",
        "description": "Require agents to include a \"Key decisions\" summary in completion write-ups so reviewers can understand tradeoffs without re-reading entire worklogs",
        "agentTypes": [
          "all"
        ]
      }
    }
  },
  "instructions": [
    {
      "path": "ac-confirmation-checklist.mdc",
      "name": "ac confirmation checklist",
      "description": "AC Confirmation Checklist - mandatory step before marking tickets complete",
      "alwaysApply": true,
      "content": "# AC Confirmation Checklist\r\n\r\n**MANDATORY:** Before marking a ticket complete or moving it forward in the workflow, agents **MUST** perform an explicit Acceptance Criteria (AC) confirmation checklist. This applies to **Implementation**, **QA**, and **PM** agents where relevant.\r\n\r\n## When to Perform AC Confirmation\r\n\r\n- **Implementation agents:** Before moving ticket to \"Ready for QA\" and sending completion summary\r\n- **QA agents:** Before moving ticket to \"Human in the Loop\" and sending completion summary\r\n- **PM agents:** Before marking ticket complete or moving to final status (where applicable)\r\n\r\n**CRITICAL:** The AC confirmation checklist must be completed **before** any final summary message or ticket movement. Do not mark a ticket complete or move it forward without completing this checklist.\r\n\r\n## AC Confirmation Checklist Requirements\r\n\r\n### 1. Enumerate Each Acceptance Criteria\r\n\r\nYou **MUST** enumerate every single Acceptance Criteria line item from the ticket. For each AC:\r\n\r\n- List the full text of the AC (or a clear reference that uniquely identifies it)\r\n- State **\"Met\"** or **\"Not met\"** for each AC\r\n- Provide **evidence** for your determination\r\n\r\n### 2. Evidence Requirements\r\n\r\nFor each AC marked as **\"Met\"**, provide one or more of the following types of evidence:\r\n\r\n- **Links to artifacts:** Reference specific artifacts stored in Supabase (e.g., \"See Plan artifact for ticket 0191, section X\")\r\n- **File paths:** Reference specific files and line numbers where the requirement is implemented (e.g., \"`.cursor/rules/ac-confirmation-checklist.mdc` lines 15-25\")\r\n- **Screenshots:** If applicable, reference screenshots stored in artifacts\r\n- **Reproduction steps:** Clear steps a human can follow to verify the AC is met (e.g., \"Navigate to X, click Y, verify Z appears\")\r\n\r\nFor each AC marked as **\"Not met\"**, clearly state:\r\n- Why it is not met\r\n- What work remains\r\n- What the next steps are (see \"Handling Unmet ACs\" below)\r\n\r\n### 3. Handling Unmet Acceptance Criteria\r\n\r\n**MANDATORY:** If any AC is marked as **\"Not met\"**, you **MUST** clearly state what happens next:\r\n\r\n- **Do not mark complete:** The ticket cannot be marked complete or moved to a \"done\" status\r\n- **Update plan or open follow-up:** If the AC requires additional work, either:\r\n  - Update the implementation plan to include the missing work, OR\r\n  - Create/open a bugfix or follow-up ticket to address the unmet AC\r\n- **Move to appropriate column:** Move the ticket to the appropriate column (e.g., \"To-do\" if work remains, \"Will Not Implement\" if the AC is intentionally not being met)\r\n\r\n**CRITICAL:** You **MUST NOT** mark a ticket complete or move it forward if any AC is not met, unless explicitly documented that the AC is intentionally not being met (with justification).\r\n\r\n## Human-Verifiable Format\r\n\r\nThe AC confirmation checklist must be written so a human can verify it **purely via UI artifacts and the agent's final summary**. This means:\r\n\r\n- **Include in final summary:** The AC confirmation checklist must appear in the agent's final completion message/summary\r\n- **Reference artifacts:** Evidence should reference artifacts that are stored in Supabase and accessible via the HAL app UI\r\n- **No terminal-only verification:** All evidence must be verifiable through the HAL app UI (artifacts, ticket content, etc.) without requiring terminal access\r\n\r\n### Example AC Confirmation Checklist Format\r\n\r\n```markdown\r\n## AC Confirmation Checklist\r\n\r\n### AC 1: \"A new, explicit 'AC Confirmation checklist' section exists in the agent process docs/rules\"\r\n- **Status:** Met\r\n- **Evidence:** \r\n  - New rule file created: `.cursor/rules/ac-confirmation-checklist.mdc`\r\n  - See artifact: \"Plan for ticket 0191\" section \"Implementation Details\"\r\n  - File path: `.cursor/rules/ac-confirmation-checklist.mdc` lines 1-150\r\n\r\n### AC 2: \"The checklist requires the agent to enumerate each Acceptance Criteria line item from the ticket and write 'Met / Not met' with evidence\"\r\n- **Status:** Met\r\n- **Evidence:**\r\n  - See this section (lines 25-45) which requires enumeration and Met/Not met status\r\n  - See artifact: \"Verification for ticket 0191\" which demonstrates the checklist format\r\n\r\n### AC 3: \"The checklist requires the agent to state what happens when any AC is not met\"\r\n- **Status:** Met\r\n- **Evidence:**\r\n  - See \"Handling Unmet Acceptance Criteria\" section (lines 60-75)\r\n  - This section explicitly requires stating next steps when ACs are not met\r\n\r\n### AC 4: \"The workflow is written so a human can verify it purely via the UI artifacts and the agent's final summary\"\r\n- **Status:** Met\r\n- **Evidence:**\r\n  - See \"Human-Verifiable Format\" section (lines 80-95)\r\n  - This section requires all evidence to be verifiable via HAL app UI\r\n\r\n### AC 5: \"Documentation/rules updates are scoped to process changes only (no product feature implementation required)\"\r\n- **Status:** Met\r\n- **Evidence:**\r\n  - Only documentation files were created/modified (`.cursor/rules/ac-confirmation-checklist.mdc`)\r\n  - No product code changes were made\r\n  - See artifact: \"Changed Files for ticket 0191\"\r\n```\r\n\r\n## Integration with Existing Workflows\r\n\r\n### For Implementation Agents:\r\n\r\n1. Complete all implementation work\r\n2. Store all required artifacts\r\n3. **Perform AC Confirmation Checklist** (this step)\r\n4. If all ACs are met: Move ticket to \"Ready for QA\" and send completion summary\r\n5. If any AC is not met: Do not move ticket; update plan or create follow-up ticket\r\n\r\n### For QA Agents:\r\n\r\n1. Verify required implementation artifacts are present\r\n2. Perform code review and verification\r\n3. **Perform AC Confirmation Checklist** (this step) - verify that implementation met all ACs\r\n4. If all ACs are met: Store QA report, move ticket to \"Human in the Loop\", merge to main, send completion summary\r\n5. If any AC is not met: Store QA report with FAIL verdict, move ticket to \"To-do\", send summary\r\n\r\n### For PM Agents:\r\n\r\n1. Review ticket and artifacts\r\n2. **Perform AC Confirmation Checklist** (this step) - verify that all ACs are met\r\n3. If all ACs are met: Mark ticket complete or move to final status\r\n4. If any AC is not met: Do not mark complete; move to appropriate column\r\n\r\n## Storage of AC Confirmation Checklist\r\n\r\nThe AC confirmation checklist should be:\r\n\r\n- **Included in the agent's final summary message** (mandatory)\r\n- **Stored in an artifact** (recommended for Implementation and QA agents):\r\n  - Implementation agents: Include in \"Verification for ticket <ticket-id>\" artifact\r\n  - QA agents: Include in \"QA report for ticket <ticket-id>\" artifact\r\n  - PM agents: Include in \"PM Review for ticket <ticket-id>\" artifact (if applicable)\r\n\r\nThis ensures the checklist is human-verifiable via the HAL app UI.\r\n\r\n## Scope\r\n\r\n- **Applies to:** Implementation agents, QA agents, PM agents\r\n- **Applies when:** Before marking tickets complete or moving them forward in workflow\r\n- **Mandatory:** Yes - this is a required step, not optional\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "ac-confirmation-checklist",
      "isBasic": false,
      "isSituational": false
    },
    {
      "path": "agent-instructions.mdc",
      "name": "agent instructions",
      "description": "PM agent instructions; HAL API usage; move ticket to Ready for QA",
      "alwaysApply": true,
      "content": "# Agent Instructions (Local)\r\n\r\nInstructions are loaded from `.cursor/rules` and `docs/`. See `docs/process/hal-tool-call-contract.mdc` for HAL API endpoints.\r\n\r\n## API-only Data Access (ALL Agents)\r\n\r\n**MANDATORY:** Agents must **never** call the database directly (no direct Supabase client usage, no `@supabase/supabase-js`, no `SUPABASE_*` env vars in agent runtime).\r\n\r\n- **All ticket operations** (create/update/move/list/get) must go through HAL endpoints under `/api/tickets/*`.\r\n- **All artifact operations** must go through HAL endpoints under `/api/artifacts/*`.\r\n- HAL server endpoints use **server-side privileged Supabase credentials** (e.g. `SUPABASE_SECRET_KEY` / service role) to bypass RLS safely.\r\n\r\n## Pre-Commit Build Verification\r\n\r\n**MANDATORY:** Before committing ANY code changes, ALL agents **MUST** verify the build succeeds:\r\n\r\n1. **Install dependencies (if not already done):**\r\n   ```bash\r\n   npm install\r\n   ```\r\n\r\n2. **Verify TypeScript compilation:**\r\n   ```bash\r\n   npx tsc -b --noEmit\r\n   ```\r\n   \r\n   This must pass with zero errors. If it fails, fix all TypeScript errors before committing.\r\n\r\n3. **Verify full build (if making changes that affect build):**\r\n   ```bash\r\n   npm run build:hal\r\n   ```\r\n   \r\n   **Note:** `npm run build:hal` may fail due to vite 6.x scanning node_modules during config loading (pre-existing issue). If this happens, verify TypeScript compilation succeeds instead:\r\n   ```bash\r\n   npx tsc -b --noEmit\r\n   ```\r\n   \r\n   If TypeScript compilation fails, you **MUST** fix the errors before committing. Do not commit code that breaks TypeScript compilation.\r\n\r\n4. **For specific projects:**\r\n   ```bash\r\n   cd projects/kanban && npx tsc --noEmit  # Check kanban project specifically\r\n   ```\r\n\r\n**CRITICAL RULES:**\r\n- **NEVER commit code without running `npx tsc -b --noEmit` first**\r\n- **NEVER commit code that causes `npm run build:hal` to fail**\r\n- **If build fails, fix it before committing - do not leave broken builds for others to discover**\r\n- This applies to ALL agents (implementation, QA, PM) when making code changes\r\n\r\n**This check prevents build failures in CI/CD and ensures code quality.**\r\n\r\n## Moving Tickets After Implementation\r\n\r\n**MANDATORY:** After implementation, the implementation agent **MUST** automatically move the ticket to **Ready for QA** before sending a completion summary. **DO NOT wait for user interaction or ask for permission - just move it.**\r\n\r\n**Move ticket to Ready for QA (AUTOMATIC - NO USER INTERACTION REQUIRED):**\r\n```javascript\r\nconst baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\r\nconst res = await fetch(`${baseUrl}/api/tickets/move`, {\r\n  method: 'POST',\r\n  headers: { 'Content-Type': 'application/json' },\r\n  body: JSON.stringify({ ticketId: '0167', columnId: 'col-qa' }),\r\n})\r\nconst result = await res.json()\r\nif (!result.success) {\r\n  // If missing artifacts, store them and retry\r\n  if (result.missingArtifacts && Array.isArray(result.missingArtifacts)) {\r\n    // Store missing artifacts, then retry move\r\n    // (implementation details in error handling below)\r\n  } else {\r\n    throw new Error(`Failed to move ticket: ${result.error}`)\r\n  }\r\n}\r\n```\r\n\r\n**When to move (AUTOMATIC WORKFLOW - NO USER INTERACTION):**\r\n1. ✅ After all code changes are committed and pushed\r\n2. ✅ After all 8 required artifacts are stored (plan, worklog, changed-files, decisions, verification, pm-review, git-diff, instructions-used)\r\n3. ✅ **Automatically call get_artifacts** (or POST /api/artifacts/get) and confirm all 8 required implementation artifacts are present with substantive content\r\n4. ✅ **AUTOMATICALLY MOVE THE TICKET TO READY FOR QA** (use the API call above) - **DO THIS AUTOMATICALLY, DO NOT ASK USER**\r\n5. ✅ **THEN** send your final \"implementation complete\" summary message\r\n\r\n**Error Handling for Ticket Move:**\r\n- **If move returns success: false with missingArtifacts:** Automatically store each listed artifact via POST /api/artifacts/insert-implementation with the corresponding artifactType, then automatically retry POST /api/tickets/move. The move API will not allow moving to Ready for QA until all 8 artifacts are present.\r\n- **If move fails for other reasons:** Log the error, but **STILL ATTEMPT TO MOVE**. The system is designed to handle failures gracefully. Do not block completion - move the ticket and note any issues in your summary.\r\n\r\n**CRITICAL WORKFLOW RULES:** \r\n- **ALWAYS move the ticket automatically** - never ask the user for permission or wait for confirmation\r\n- **DO NOT** send a completion summary or \"done\" message without first moving the ticket to Ready for QA\r\n- **DO NOT** mark the ticket as complete in your message if you haven't moved it\r\n- The ticket move is **part of the completion workflow**, not an optional step\r\n- **If the move fails, retry automatically** - do not give up after one failure\r\n- **The system is designed to handle failures** - if a move fails, it's okay, just note it and move on\r\n\r\n**Available column IDs:**\r\n- `col-unassigned` - Unassigned\r\n- `col-todo` - To-do\r\n- `col-doing` - Doing (Active Work)\r\n- `col-qa` - Ready for QA\r\n- `col-human-in-the-loop` - Human in the Loop\r\n- `col-process-review` - Process Review\r\n- `col-done` - Done\r\n- `col-wont-implement` - Will Not Implement\r\n\r\n**Note:** The HAL API endpoint `/api/tickets/move` uses server-side Supabase credentials, so agents don't need to provide credentials in the request body. The API uses the ticket's primary key (pk) for updates to ensure reliable ticket movement regardless of the ticket ID format provided.\r\n\r\n## QA Notes in Completion Summary\r\n\r\n**MANDATORY:** All final completion summaries from **Implementation agents** and **Project Manager agents** **MUST** include a **QA Notes** section that maps each Acceptance Criteria to a concrete UI verification location.\r\n\r\n### Requirements\r\n\r\n1. **Enumerate each Acceptance Criteria** — The QA Notes section must list **every single AC** from the ticket.\r\n\r\n2. **Provide exact UI location/route** — For each AC, specify:\r\n   - The exact UI route/path where the AC can be verified (e.g., `/settings`, `/tickets/HAL-0841`, `/kanban`)\r\n   - Any relevant UI labels, buttons, or elements that demonstrate the AC is met (e.g., \"Settings page → 'Dark mode' toggle switch\", \"Ticket detail page → 'Status' field shows 'Ready for QA'\")\r\n   - Clear navigation steps if needed (e.g., \"Navigate to Settings → Appearance section → Verify 'Dark mode' toggle is visible\")\r\n\r\n3. **Mark non-UI-verifiable ACs as Blocked** — If any AC cannot be verified in the UI (e.g., requires terminal access, database inspection, or code review), the agent **MUST**:\r\n   - Mark that AC as **Blocked** in the QA Notes section\r\n   - **NOT** claim the ticket is complete if any AC is Blocked\r\n   - Either move the ticket to an appropriate column (e.g., \"To-do\" if work remains) or create a follow-up ticket to address the non-UI-verifiable requirement\r\n\r\n**CRITICAL:** If any AC is marked as **Blocked** (not UI-verifiable), the ticket **CANNOT** be marked complete or moved to \"Ready for QA\". The agent must either:\r\n- Update the AC to be UI-verifiable, OR\r\n- Document why the AC cannot be UI-verifiable and move the ticket to an appropriate status (e.g., \"Will Not Implement\" if the AC is intentionally non-UI-verifiable)\r\n\r\n### QA Notes Section Format\r\n\r\nThe QA Notes section must appear in the **final completion summary** (the \"done\" message sent to the user). It should follow this format:\r\n\r\n```markdown\r\n## QA Notes\r\n\r\n### AC 1: \"[Full text of AC 1]\"\r\n- **UI Location:** `/settings` → Appearance section\r\n- **Verification:** Navigate to Settings page, scroll to Appearance section, verify \"Dark mode\" toggle switch is visible and clickable\r\n- **Status:** ✅ UI-verifiable\r\n\r\n### AC 2: \"[Full text of AC 2]\"\r\n- **UI Location:** `/tickets/HAL-0841` → Ticket detail page\r\n- **Verification:** Open ticket HAL-0841, verify \"Status\" field displays \"Ready for QA\"\r\n- **Status:** ✅ UI-verifiable\r\n\r\n### AC 3: \"[Full text of AC 3]\"\r\n- **UI Location:** N/A (requires database inspection)\r\n- **Verification:** Cannot be verified in UI - requires direct database access\r\n- **Status:** ⚠️ Blocked (not UI-verifiable)\r\n```\r\n\r\n### Example: Complete Final Summary with QA Notes\r\n\r\n```markdown\r\n## Summary\r\n\r\nImplemented dark mode toggle feature with persistence. Added toggle switch to Settings page, implemented theme switching logic, and stored preference in localStorage.\r\n\r\n## Key Decisions\r\n\r\n- Used localStorage for persistence to avoid backend changes\r\n- Implemented theme switching via CSS variables for performance\r\n\r\n## QA Notes\r\n\r\n### AC 1: \"Settings page displays a 'Dark mode' toggle switch that is clearly visible and clickable\"\r\n- **UI Location:** `/settings` → Appearance section\r\n- **Verification:** Navigate to Settings page, scroll to Appearance section, verify \"Dark mode\" toggle switch is visible and clickable\r\n- **Status:** ✅ UI-verifiable\r\n\r\n### AC 2: \"Clicking the toggle immediately changes the app theme from light to dark (or vice versa) with a smooth transition\"\r\n- **UI Location:** `/settings` → Appearance section → \"Dark mode\" toggle\r\n- **Verification:** Click the \"Dark mode\" toggle, observe entire app UI transitions from light to dark theme (or vice versa) with smooth animation\r\n- **Status:** ✅ UI-verifiable\r\n\r\n### AC 3: \"The selected theme preference persists after page refresh (the toggle state matches the current theme on reload)\"\r\n- **UI Location:** `/settings` → Appearance section → \"Dark mode\" toggle\r\n- **Verification:** Set theme to dark mode, refresh page (F5 or Cmd+R), verify page reloads with dark theme and toggle switch is in \"on\" position\r\n- **Status:** ✅ UI-verifiable\r\n\r\nTicket HAL-0841 implementation completed and moved to QA.\r\n```\r\n\r\n### Integration with AC Confirmation Checklist\r\n\r\nThe QA Notes section **complements** the AC Confirmation Checklist (see `.cursor/rules/ac-confirmation-checklist.mdc`). Both sections should appear in the final completion summary:\r\n\r\n- **AC Confirmation Checklist** — Enumerates each AC with \"Met\" / \"Not met\" status and evidence (file paths, artifacts, etc.)\r\n- **QA Notes** — Maps each AC to exact UI location/route for human verification\r\n\r\nTogether, these sections ensure that:\r\n1. All ACs are explicitly addressed (AC Confirmation Checklist)\r\n2. All ACs can be verified in the UI (QA Notes)\r\n3. Reviewers can quickly verify completion without terminal access (QA Notes)\r\n\r\n### Scope\r\n\r\n- **Applies to:** Implementation agents, Project Manager agents\r\n- **Applies when:** Before sending final completion summary (after moving ticket to \"Ready for QA\" or final status)\r\n- **Mandatory:** Yes - this is a required section in completion summaries, not optional\r\n- **Location:** Must appear in the final chat completion summary message\r\n",
      "agentTypes": [
        "all",
        "implementation-agent",
        "project-manager",
        "process-review-agent"
      ],
      "topicId": "agent-instructions",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "Agent Instructions Entry Point",
        "description": "Entry point for agent instructions - load basic rules from Supabase",
        "agentTypes": [
          "all"
        ]
      }
    },
    {
      "path": "cloud-agents-pull-from-main.mdc",
      "name": "cloud agents pull from main",
      "description": "Cloud agents must pull from main before starting work; do not assume latest code",
      "alwaysApply": true,
      "content": "# Cloud Agents: Pull from Main Before Starting\r\n\r\n**MANDATORY:** Cloud agents (Implementation and QA) **MUST** pull the latest code from `main` before starting any work. Do not assume you have the latest code.\r\n\r\n## Required first step\r\n\r\nBefore making changes, running tests, or loading instructions:\r\n\r\n```bash\r\ngit checkout main && git pull origin main\r\n```\r\n\r\n- **Implementation agents:** Then follow the \"Implementation Agent Branch Setup\" section below.\r\n- **QA agents:** Then proceed with loading instructions and QA workflow.\r\n\r\n## Implementation Agent Branch Setup\r\n\r\n**MANDATORY:** Implementation agents **MUST** create or switch to the feature branch and push it with upstream tracking **BEFORE** reading any files or making any code edits. This ensures work is never done on an untracked local branch.\r\n\r\n### Step 1: Create or Switch to Feature Branch\r\n\r\nCreate a new branch using the ticket number and a descriptive name, or switch to an existing branch:\r\n\r\n```bash\r\ngit switch -c ticket/0817-add-a-rule-to-create-and-push-branch-early\r\n```\r\n\r\n**If the branch already exists locally or remotely:**\r\n```bash\r\ngit switch ticket/0817-add-a-rule-to-create-and-push-branch-early\r\n```\r\n\r\n### Step 2: Push Branch with Upstream Tracking\r\n\r\n**MANDATORY:** Push the branch immediately with upstream tracking:\r\n\r\n```bash\r\ngit push -u origin ticket/0817-add-a-rule-to-create-and-push-branch-early\r\n```\r\n\r\n**If upstream is already set but you want to ensure it's correct:**\r\n```bash\r\ngit push -u origin ticket/0817-add-a-rule-to-create-and-push-branch-early\r\n```\r\n\r\nThis command will set the upstream tracking relationship if it doesn't exist, or update it if it does.\r\n\r\n### Step 3: Verify Upstream is Set\r\n\r\n**MANDATORY:** Verify that upstream tracking is correctly configured:\r\n\r\n```bash\r\ngit rev-parse --abbrev-ref --symbolic-full-name @{u}\r\n```\r\n\r\n**Expected output:**\r\n```\r\norigin/ticket/0817-add-a-rule-to-create-and-push-branch-early\r\n```\r\n\r\nIf this command outputs the expected remote branch name, upstream tracking is correctly set. If it fails or outputs something unexpected, the upstream is not set correctly and you must run `git push -u origin <branch-name>` again.\r\n\r\n### Why Push Early\r\n\r\nPushing the branch immediately after creation (before any code edits) provides several critical benefits:\r\n\r\n- **Remote backup:** Work is backed up to the remote repository from the start, preventing loss if the local environment is reset or lost\r\n- **CI/PR integration:** Enables continuous integration systems and pull request workflows to run from the first commit\r\n- **Collaboration:** Other team members can see the branch exists and track progress\r\n- **Safety:** Prevents losing work if the local branch is accidentally reset or deleted\r\n\r\n### Safe Alternative: Branch Already Exists\r\n\r\nIf the branch already exists (either locally or remotely), use this safe workflow:\r\n\r\n1. **Switch to the existing branch:**\r\n   ```bash\r\n   git switch ticket/0817-add-a-rule-to-create-and-push-branch-early\r\n   ```\r\n\r\n2. **Verify or set upstream tracking:**\r\n   ```bash\r\n   git push -u origin ticket/0817-add-a-rule-to-create-and-push-branch-early\r\n   ```\r\n\r\n3. **Verify upstream is set:**\r\n   ```bash\r\n   git rev-parse --abbrev-ref --symbolic-full-name @{u}\r\n   ```\r\n\r\nThis ensures upstream tracking is configured even if the branch existed before you started work.\r\n\r\n### Critical Ordering\r\n\r\n**DO NOT** read files, make code edits, or run any other commands until:\r\n1. ✅ You have pulled latest from `main`\r\n2. ✅ You have created/switched to the feature branch\r\n3. ✅ You have pushed the branch with upstream tracking (`git push -u origin <branch-name>`)\r\n4. ✅ You have verified upstream is set (`git rev-parse --abbrev-ref --symbolic-full-name @{u}`)\r\n\r\nOnly after all four steps are complete should you proceed with reading files, making code changes, or any other implementation work.\r\n\r\n## Never Work on Detached HEAD or Wrong Branch\r\n\r\n**MANDATORY:** Agents must **never** perform work on detached HEAD or a non-ticket branch. All work must be performed on the correct feature branch for the ticket.\r\n\r\n## Do Not\r\n\r\n**MANDATORY:** The following destructive git commands are **prohibited by default** and must **never** be used unless explicitly required by the ticket:\r\n\r\n- `git reset --hard` — Discards all uncommitted changes and resets the working directory to a specific commit\r\n- `git clean -fd` — Removes untracked files and directories\r\n- Force-push operations (`git push --force` or `git push --force-with-lease`) — Overwrites remote branch history\r\n\r\n### Exception: When Ticket Explicitly Requires Destructive Commands\r\n\r\nDestructive commands are **only allowed** when **both** of the following conditions are met:\r\n\r\n1. **The ticket explicitly requires the destructive command** — The ticket description, acceptance criteria, or instructions must clearly state that a destructive command is needed (e.g., \"reset the branch to a clean state\" or \"force-push to fix branch history\").\r\n\r\n2. **The agent creates a backup and documents the rationale** — Before executing any destructive command, the agent **MUST**:\r\n   - Create a backup using one of the following methods:\r\n     - **Patch file:** `git diff > backup.patch` (for uncommitted changes)\r\n     - **Stash:** `git stash push -m \"backup before destructive operation\"` (for uncommitted changes)\r\n     - **Branch backup:** `git branch backup-<timestamp>` (for committed work that might be lost)\r\n   - Document the rationale in the worklog or decisions artifact, explaining:\r\n     - Why the destructive command is necessary\r\n     - What backup was created and where it is stored\r\n     - What will be lost and why it's acceptable\r\n\r\n**If a destructive command is needed but the ticket doesn't explicitly require it:** The agent must **not** execute the command. Instead, the agent should document the situation and request clarification or create a follow-up ticket.\r\n\r\n### If You Discover Work on the Wrong Branch\r\n\r\nIf you discover that work has landed on the wrong branch (detached HEAD, `main`, or a different feature branch), you **MUST** immediately fix this:\r\n\r\n1. **Identify the commit hash(es)** of the work that was done on the wrong branch:\r\n   ```bash\r\n   git log --oneline -5  # Find the commit hash(es) to move\r\n   ```\r\n\r\n2. **Create or checkout the correct feature branch:**\r\n   ```bash\r\n   git checkout -b <ticket-branch>  # If branch doesn't exist\r\n   # OR\r\n   git switch <ticket-branch>       # If branch already exists\r\n   ```\r\n\r\n3. **Cherry-pick the commit(s) to the correct branch:**\r\n   ```bash\r\n   git cherry-pick <commit-hash>\r\n   # If multiple commits, cherry-pick each one or use a range:\r\n   git cherry-pick <first-hash>^..<last-hash>\r\n   ```\r\n\r\n4. **Push the corrected branch:**\r\n   ```bash\r\n   git push -u origin <ticket-branch>\r\n   ```\r\n\r\n5. **If work was already committed on the wrong branch, you may need to reset that branch:**\r\n   \r\n   **WARNING:** This step involves destructive commands (`git reset --hard` and `git push --force`). See the \"Do Not\" section above for requirements.\r\n   \r\n   **Before proceeding:** Ensure you have created a backup branch of the work that will be removed:\r\n   ```bash\r\n   git branch backup-<wrong-branch>-<timestamp>  # Create backup before destructive operations\r\n   ```\r\n   \r\n   **Only if you need to remove commits from the wrong branch:**\r\n   ```bash\r\n   git checkout <wrong-branch>\r\n   git reset --hard <commit-before-wrong-work>\r\n   git push --force origin <wrong-branch>  # Use with caution - see \"Do Not\" section\r\n   ```\r\n   \r\n   **Documentation required:** Document in your worklog or decisions artifact:\r\n   - Why the reset and force-push were necessary\r\n   - What backup branch was created\r\n   - What commits were removed and why\r\n\r\n**CRITICAL:** Do not continue working until the branch situation is corrected. All commits must be on the correct feature branch for the ticket.\r\n\r\n## Why\r\n\r\nCloud agents run in an environment that may have cloned the repo earlier or from a different ref. The board and tickets reflect the current state of `main`; working from a stale clone can cause merge conflicts, duplicate work, or missed changes. Always start from an up-to-date `main`.\r\n\r\n## Scope\r\n\r\n- Applies to: implementation-agent, qa-agent (any agent that runs as a Cursor Cloud Agent on the repo).\r\n- When: Before any other work on the ticket (first step after the agent starts).\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent"
      ],
      "topicId": "cloud-agents-pull-from-main",
      "isBasic": false,
      "isSituational": false
    },
    {
      "path": "code-citation-requirements.mdc",
      "name": "code citation requirements",
      "description": "Require agents to cite specific file paths and line numbers when referencing code locations",
      "alwaysApply": true,
      "content": "# Code Citation Requirements\r\n\r\nWhen agents reference \"where something is implemented\" or claim where key functionality exists, they **must** cite concrete code locations using file paths and (when feasible) line numbers or symbol names. This enables reviewers to verify claims quickly without searching the codebase.\r\n\r\n## Mandatory Citation Format\r\n\r\n**Minimum acceptable citation formats:**\r\n\r\n1. **File path with line range:** `src/foo.ts:42-61`\r\n2. **File path with single line:** `src/foo.ts:42`\r\n3. **File path with symbol name:** `src/foo.ts — function bar()` or `src/foo.ts — class MyComponent`\r\n4. **File path with line and symbol:** `src/foo.ts:42 — function bar()`\r\n\r\n**Examples:**\r\n- ✅ `src/api/tickets.ts:123-145` — implementation of ticket syncing\r\n- ✅ `components/KanbanBoard.tsx:42` — column rendering logic\r\n- ✅ `src/utils/validation.ts — function validateTicket()` — validation rules\r\n- ✅ `src/hooks/useTickets.ts:78-92 — useEffect hook` — data fetching\r\n- ❌ \"in the tickets API file\" — too vague\r\n- ❌ \"tickets.ts\" — missing path context\r\n- ❌ \"the validation function\" — no file reference\r\n\r\n## Required Contexts\r\n\r\nThis requirement applies to all of the following contexts:\r\n\r\n### 1. Implementation Summaries and Worklogs\r\n\r\nWhen implementation agents document what was implemented, they must cite specific locations:\r\n\r\n**Example (worklog):**\r\n```markdown\r\n## Changes Made\r\n\r\n- Added ticket syncing logic in `src/api/tickets.ts:123-145` — `syncTickets()` function\r\n- Updated column rendering in `components/KanbanBoard.tsx:42-67` — `renderColumns()` method\r\n- Fixed validation in `src/utils/validation.ts:89-102 — validateTicket()` function\r\n```\r\n\r\n### 2. QA Reports\r\n\r\nWhen QA agents review code and report findings, they must cite specific locations:\r\n\r\n**Example (QA report code review section):**\r\n```markdown\r\n## Code Review\r\n\r\n| Requirement | Implementation | Status |\r\n|------------|----------------|--------|\r\n| Ticket syncing | `src/api/tickets.ts:123-145 — syncTickets()` | ✅ PASS |\r\n| Column rendering | `components/KanbanBoard.tsx:42-67` | ✅ PASS |\r\n| Validation | `src/utils/validation.ts:89-102 — validateTicket()` | ⚠️ FAIL — missing null check |\r\n```\r\n\r\n### 3. PM Guidance\r\n\r\nWhen Project Manager agents answer questions like \"Where is X implemented?\" or \"How does Y work?\", they must cite specific locations:\r\n\r\n**Example (PM response):**\r\n```markdown\r\nTicket syncing is implemented in `src/api/tickets.ts:123-145` in the `syncTickets()` function. The function handles:\r\n- Fetching tickets from Supabase (`src/api/tickets.ts:130-138`)\r\n- Updating local state (`src/api/tickets.ts:140-145`)\r\n```\r\n\r\n## Exceptions: When Line Numbers Are Unreliable\r\n\r\nWhen line numbers are unreliable or unstable (e.g., generated code, minified bundles, frequently changing files), cite the nearest stable anchor instead:\r\n\r\n**Acceptable alternatives:**\r\n- **Symbol name + file path:** `src/generated/api.ts — export function fetchTickets()`\r\n- **Exported function/class:** `src/api/index.ts — export { syncTickets }`\r\n- **Route ID or path:** `src/routes.ts — route id: 'tickets'`\r\n- **Component name:** `components/TicketCard.tsx — <TicketCard /> component`\r\n- **Configuration key:** `config/app.config.ts — tickets.syncInterval`\r\n\r\n**Examples:**\r\n- ✅ `dist/bundle.js — function syncTickets()` (minified bundle)\r\n- ✅ `src/generated/types.ts — interface Ticket` (generated file)\r\n- ✅ `src/routes.ts — route: '/tickets'` (routing config)\r\n- ❌ `dist/bundle.js:1234` (line number in minified code is unreliable)\r\n\r\n**When in doubt:** Prefer symbol names, exported identifiers, or stable configuration keys over line numbers in generated or frequently-changing files.\r\n\r\n## Enforcement\r\n\r\n- **Implementation agents:** Must include citations in worklogs, plans, and implementation summaries.\r\n- **QA agents:** Must include citations in code review sections of QA reports (see `.cursor/rules/qa-audit-report.mdc`).\r\n- **PM agents:** Must include citations when answering \"where is X implemented?\" questions.\r\n\r\n**Reviewers should verify:** All code location claims can be verified by navigating to the cited file path and (when provided) line number or symbol name.\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "code-citation-requirements",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "Code Citation Requirements",
        "description": "Require agents to cite specific file paths and line numbers when referencing code locations",
        "agentTypes": [
          "all"
        ]
      }
    },
    {
      "path": "code-location-citations.mdc",
      "name": "code location citations",
      "description": "Require agents to cite specific file paths and line numbers/symbols when referencing where functionality is implemented",
      "alwaysApply": true,
      "content": "# Code Location Citations\r\n\r\nWhen an agent references \"where something is implemented\" or claims where key functionality exists, they **must** cite concrete code locations that reviewers can verify quickly.\r\n\r\n## Required Citation Format\r\n\r\n**Minimum acceptable citation formats:**\r\n\r\n- **File path with line range:** `src/foo.ts:42-61`\r\n- **File path with function/class name:** `src/foo.ts — function bar()`\r\n- **File path with symbol:** `src/foo.ts — class MyComponent`\r\n- **File path with route/component ID:** `src/routes.ts — route id: \"dashboard\"`\r\n\r\n**Examples:**\r\n- ✅ `src/components/Button.tsx:15-23` (line range)\r\n- ✅ `src/utils/api.ts — function fetchUser()` (symbol name)\r\n- ✅ `src/routes.ts:42 — route id: \"settings\"` (route identifier)\r\n- ✅ `src/App.tsx — component App` (component name)\r\n- ❌ `src/components/Button.tsx` (missing line/symbol)\r\n- ❌ `the Button component` (no file path)\r\n\r\n## When Citations Are Required\r\n\r\nCitations are **mandatory** in these contexts:\r\n\r\n1. **Implementation summaries/worklogs** — When describing what was implemented or where changes were made\r\n2. **QA reports** — When reviewing code and referencing where functionality exists\r\n3. **PM guidance** — When answering \"where is X implemented?\" or similar questions\r\n\r\n## Exceptions: Unreliable Line Numbers\r\n\r\nIf line numbers are unreliable or unstable (e.g., generated code, minified bundles, auto-generated files), cite the **nearest stable anchor** instead:\r\n\r\n- **Symbol name** (exported function, class, constant)\r\n- **Route ID** or **component name**\r\n- **Export identifier**\r\n- **File path** (always required, even when line numbers aren't)\r\n\r\n**Examples of stable anchors:**\r\n- `src/generated/api.ts — export function createUser()` (generated file, use symbol)\r\n- `dist/bundle.js — function handleClick()` (minified, use symbol)\r\n- `src/routes.ts — route id: \"dashboard\"` (route identifier)\r\n\r\n**Always include the file path** even when using stable anchors instead of line numbers.\r\n\r\n## Scope\r\n\r\n- Applies to **all agents** (implementation, QA, PM) when referencing code locations\r\n- Citations must be **human-verifiable** — a reviewer should be able to open the file and find the referenced location\r\n- When in doubt, provide **more specific citations** (line numbers + symbol names) rather than less\r\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "code-location-citations",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "Code Location Citations",
        "description": "Require agents to cite concrete code locations that reviewers can verify quickly",
        "agentTypes": [
          "all"
        ]
      }
    },
    {
      "path": "heading-parsing-pitfalls.mdc",
      "name": "heading parsing pitfalls",
      "description": "Guide for agents to produce headings that HAL can parse and render correctly",
      "alwaysApply": true,
      "content": "# Heading parsing pitfalls (and how to avoid them)\r\n\r\nWhen creating tickets or writing documentation, agents must produce headings that HAL can parse and render correctly. This guide covers common pitfalls and how to avoid them.\r\n\r\n## Pitfall 1: Inconsistent heading levels\r\n\r\n**Problem:** Using `#` (H1) or `###` (H3) when `##` (H2) is required, or skipping heading levels (e.g., going from `##` to `####`).\r\n\r\n**Why this fails:** HAL's parsing logic expects specific heading levels. Required ticket sections must use `##` (H2) to be recognized correctly.\r\n\r\n**❌ Bad examples:**\r\n```markdown\r\n# Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n### Acceptance criteria\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n#### Acceptance criteria\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**Fix:** Always use `##` (H2) for required ticket sections. Maintain consistent heading hierarchy throughout the document.\r\n\r\n## Pitfall 2: Ambiguous \"pseudo-headings\" instead of real markdown headings\r\n\r\n**Problem:** Using bold text (`**Section Name:**`) or text with colons (`Section Name:`) when a real markdown heading is intended.\r\n\r\n**Why this fails:** HAL's parsing logic looks for markdown heading syntax (`## Section Name`), not bold text or colons. Pseudo-headings won't be recognized as section boundaries.\r\n\r\n**❌ Bad examples:**\r\n```markdown\r\n**Goal (one sentence):**\r\n\r\nAdd a feature.\r\n\r\n**Acceptance criteria (UI-only):**\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n```markdown\r\nGoal (one sentence):\r\n\r\nAdd a feature.\r\n\r\nAcceptance criteria (UI-only):\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**Fix:** Use proper markdown heading syntax (`## Section Name`) instead of bold text or plain text with colons.\r\n\r\n## Pitfall 3: Required ticket headings don't match canonical text exactly\r\n\r\n**Problem:** Using variations like \"Goal\" instead of \"Goal (one sentence)\", or \"Acceptance criteria\" instead of \"Acceptance criteria (UI-only)\".\r\n\r\n**Why this fails:** HAL's parsing logic uses case-sensitive, exact text matching. Headings must match the canonical format exactly to be recognized.\r\n\r\n**❌ Bad examples:**\r\n```markdown\r\n## Goal\r\n\r\nAdd a feature.\r\n\r\n## Human-verifiable deliverable\r\n\r\nUser sees a button.\r\n\r\n## Acceptance criteria\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Human-verifiable deliverable (UI only)\r\n\r\nUser sees a button.\r\n\r\n## Acceptance Criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Human-verifiable deliverable (UI-only)\r\n\r\nUser sees a button.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**Fix:** Use the exact canonical text for required ticket sections:\r\n- `## Goal (one sentence)`\r\n- `## Human-verifiable deliverable (UI-only)`\r\n- `## Acceptance criteria (UI-only)`\r\n- `## Constraints`\r\n- `## Non-goals`\r\n\r\n## Pitfall 4: Duplicating the same top-level heading multiple times\r\n\r\n**Problem:** Including multiple `# Ticket` blocks or repeating the same top-level section heading.\r\n\r\n**Why this fails:** HAL's parsing logic expects a single, well-structured document. Duplicate headings can cause parsing confusion and make sections ambiguous.\r\n\r\n**❌ Bad example:**\r\n```markdown\r\n# Ticket\r\n\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n# Ticket\r\n\r\n## Goal (one sentence)\r\n\r\nAdd another feature.\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Human-verifiable deliverable (UI-only)\r\n\r\nUser sees a button.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n- [ ] Item 2\r\n```\r\n\r\n**Fix:** Use each heading only once. If you need to group related content, use subheadings (`###`) or organize content within a single section.\r\n\r\n## Pitfall 5: Using plain bullets instead of checkboxes in Acceptance criteria\r\n\r\n**Problem:** Using `- Item` or `* Item` instead of `- [ ] Item` for Acceptance criteria items.\r\n\r\n**Why this fails:** HAL's Ready-to-start checklist requires Acceptance criteria to use checkbox format (`- [ ]`) so items can be tracked and verified. Plain bullets won't pass validation.\r\n\r\n**❌ Bad examples:**\r\n```markdown\r\n## Acceptance criteria (UI-only)\r\n\r\n- User sees a button\r\n- Button is clickable\r\n- Clicking shows a message\r\n```\r\n\r\n```markdown\r\n## Acceptance criteria (UI-only)\r\n\r\n* User sees a button\r\n* Button is clickable\r\n* Clicking shows a message\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] User sees a button labeled \"Save\" in the header\r\n- [ ] Button is clickable and responds to clicks\r\n- [ ] Clicking the button shows a success message in the UI\r\n```\r\n\r\n**Fix:** Always use checkbox format (`- [ ]`) for Acceptance criteria items. Each item should be UI-verifiable (a human can confirm by looking at the UI or running a manual test).\r\n\r\n## Copy/paste examples\r\n\r\n### Good: Minimal ticket skeleton that passes Definition of Ready\r\n\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a dark mode toggle button to the settings page that persists the user's preference.\r\n\r\n## Human-verifiable deliverable (UI-only)\r\n\r\nA non-technical user opens the app, navigates to Settings, sees a \"Dark mode\" toggle switch, clicks it, and observes the entire app UI changes from light to dark theme. The preference persists after page refresh.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Settings page displays a \"Dark mode\" toggle switch that is clearly visible and clickable\r\n- [ ] Clicking the toggle immediately changes the app theme from light to dark (or vice versa) with a smooth transition\r\n- [ ] The selected theme preference persists after page refresh (the toggle state matches the current theme on reload)\r\n\r\n## Constraints\r\n\r\n- Keep this task as small as possible while still producing a **human-verifiable** UI change.\r\n- Verification must require **no external tools** (no terminal, no devtools, no console).\r\n\r\n## Non-goals\r\n\r\n- Theme customization beyond light/dark (no color pickers or advanced theming)\r\n- Per-component theme overrides (global theme only)\r\n\r\n## Scope Lock / Out-of-Scope\r\n\r\n### Product Flows Changed\r\n\r\n- [x] **Instructions retrieval** — Updated theme-related instructions to include dark mode preferences\r\n\r\n### Product Flows Not Implemented (Missing Infrastructure)\r\n\r\nNone — All required infrastructure is in place.\r\n\r\n### Escalation Note to PM/QA\r\n\r\nN/A — No missing infrastructure or blockers.\r\n```\r\n\r\n**Why this is good:**\r\n- All headings use `##` (H2) consistently\r\n- Headings match canonical text exactly\r\n- Acceptance criteria use checkbox format (`- [ ]`)\r\n- No placeholders or pseudo-headings\r\n- All sections are present and properly formatted\r\n\r\n### Bad: Common failure mode and corrected version\r\n\r\n**❌ Bad example (multiple pitfalls):**\r\n```markdown\r\n# Ticket\r\n\r\n**Goal:** Add dark mode toggle\r\n\r\n### Human-verifiable deliverable\r\n\r\nUser sees toggle in settings.\r\n\r\n## Acceptance criteria\r\n\r\n- User sees toggle\r\n- Toggle works\r\n- Preference saves\r\n\r\n## Constraints\r\n\r\n- Use existing theme system\r\n\r\n## Non-goals\r\n\r\n- Advanced theming\r\n```\r\n\r\n**Problems:**\r\n1. Uses `# Ticket` (H1) instead of starting with `## Goal`\r\n2. Uses bold pseudo-heading `**Goal:**` instead of `## Goal (one sentence)`\r\n3. Uses `###` (H3) for \"Human-verifiable deliverable\" instead of `##`\r\n4. Missing \"(one sentence)\" and \"(UI-only)\" suffixes in headings\r\n5. Uses plain bullets (`-`) instead of checkboxes (`- [ ]`) in Acceptance criteria\r\n6. Acceptance criteria items are not UI-verifiable (too vague)\r\n\r\n**✅ Corrected version:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a dark mode toggle button to the settings page that persists the user's preference.\r\n\r\n## Human-verifiable deliverable (UI-only)\r\n\r\nA non-technical user opens the app, navigates to Settings, sees a \"Dark mode\" toggle switch, clicks it, and observes the entire app UI changes from light to dark theme. The preference persists after page refresh.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Settings page displays a \"Dark mode\" toggle switch that is clearly visible and clickable\r\n- [ ] Clicking the toggle immediately changes the app theme from light to dark (or vice versa) with a smooth transition\r\n- [ ] The selected theme preference persists after page refresh (the toggle state matches the current theme on reload)\r\n\r\n## Constraints\r\n\r\n- Use existing theme system (no new CSS framework)\r\n- Theme preference must be stored in localStorage\r\n\r\n## Non-goals\r\n\r\n- Theme customization beyond light/dark (no color pickers or advanced theming)\r\n- Per-component theme overrides (global theme only)\r\n```\r\n\r\n**Why this is correct:**\r\n- All headings use `##` (H2) consistently\r\n- Headings match canonical text exactly: \"Goal (one sentence)\", \"Human-verifiable deliverable (UI-only)\", \"Acceptance criteria (UI-only)\"\r\n- Acceptance criteria use checkbox format (`- [ ]`)\r\n- All items are UI-verifiable with specific, testable descriptions\r\n- No pseudo-headings or placeholders\r\n\r\n## Summary\r\n\r\nTo produce headings that HAL can parse correctly:\r\n\r\n1. **Use `##` (H2) consistently** for required ticket sections\r\n2. **Use proper markdown heading syntax** (`## Section Name`), not bold text or colons\r\n3. **Match canonical text exactly** (case-sensitive): \"Goal (one sentence)\", \"Human-verifiable deliverable (UI-only)\", \"Acceptance criteria (UI-only)\"\r\n4. **Avoid duplicate top-level headings** — use each heading only once\r\n5. **Use checkbox format** (`- [ ]`) for Acceptance criteria items, not plain bullets\r\n\r\nFollowing these guidelines ensures your tickets will pass HAL's Definition of Ready validation and be correctly parsed and rendered in the UI.\r\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "heading-parsing-pitfalls",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "implementation-agent-workflow.mdc",
      "name": "implementation agent workflow",
      "description": "Implementation agent workflow - check for failure notes first",
      "alwaysApply": true,
      "content": "# Implementation Agent Workflow\r\n\r\n## Check for Implementation Agent Note First\r\n\r\n**MANDATORY:** Before starting work on any ticket, implementation agents **MUST** check for an \"Implementation agent note\" artifact. This note contains concise failure reasons from QA or Human-in-the-Loop reviews.\r\n\r\n**How to check:**\r\n```javascript\r\nconst baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\r\nconst res = await fetch(`${baseUrl}/api/artifacts/get`, {\r\n  method: 'POST',\r\n  headers: { 'Content-Type': 'application/json' },\r\n  body: JSON.stringify({ ticketId: 'XXXX' }),\r\n})\r\nconst result = await res.json()\r\nif (result.success) {\r\n  const implNote = result.artifacts.find(a => \r\n    a.title?.toLowerCase().includes('implementation agent note') ||\r\n    a.title?.toLowerCase().includes('note for implementation agent')\r\n  )\r\n  if (implNote) {\r\n    // Read the note first - it explains what needs to be fixed\r\n    // Address the issues listed in the note before proceeding\r\n  }\r\n}\r\n```\r\n\r\n**If an Implementation agent note exists:**\r\n1. **Read it first** - It contains the specific reasons why the ticket failed\r\n2. **Address all issues** listed in the \"Required Actions\" section\r\n3. **Do not proceed** with new implementation until all issues are resolved\r\n4. **Re-submit for QA** after fixes are complete\r\n\r\n**If no Implementation agent note exists:**\r\n- Proceed with normal implementation workflow\r\n\r\n## Artifact Title Formats\r\n\r\nThe note may be titled:\r\n- `Implementation agent note for ticket HAL-XXXX`\r\n- `Note for implementation agent: HAL-XXXX`\r\n\r\nBoth formats are recognized and should be checked.\r\n\r\n## AC Feasibility Gate\r\n\r\n**MANDATORY:** Before creating a branch, reading files, or making any code changes, implementation agents **MUST** perform an \"AC Feasibility Gate\" check. This gate ensures that all acceptance criteria can be implemented with existing UI surfaces and API endpoints.\r\n\r\n### Step 1: Map Each Acceptance Criterion\r\n\r\nFor **each** acceptance criterion in the ticket, the agent **MUST** explicitly map it to:\r\n\r\n1. **An existing UI surface** — Where a human will verify the AC is met (e.g., \"Settings page\", \"Ticket detail view\", \"Kanban board column\")\r\n2. **An existing API/endpoint or data source** — What enables the AC to be implemented (e.g., \"`POST /api/tickets/move` endpoint\", \"Supabase `tickets` table via HAL API\", \"localStorage for theme preference\")\r\n\r\n**Mapping format:**\r\n```markdown\r\n### AC 1: [Full text of acceptance criterion]\r\n\r\n- **UI Surface:** [Specific UI location where human will verify, e.g., \"Settings page toggle switch\"]\r\n- **API/Endpoint:** [Specific API endpoint or data source, e.g., \"`POST /api/artifacts/insert-implementation` endpoint\"]\r\n- **Feasibility:** ✅ Feasible / ❌ Not feasible\r\n\r\n[If not feasible, explain why below]\r\n```\r\n\r\n### Step 2: Stop and Escalate if Any AC Cannot Be Mapped\r\n\r\n**CRITICAL:** If **any** acceptance criterion cannot be mapped to both:\r\n- An existing UI surface, **OR**\r\n- An existing API/endpoint or data source\r\n\r\nThen the agent **MUST STOP** and **NOT** proceed with implementation. Instead, the agent must do **one** of the following:\r\n\r\n#### Option A: File a Clarification Request\r\n\r\nCreate a clear clarification request that states:\r\n- **Which AC(s) cannot be mapped** (list the full text of each AC)\r\n- **What is missing** (e.g., \"RED generation UI component does not exist\", \"No API endpoint for generating RED artifacts\")\r\n- **What information is needed** to proceed (e.g., \"Need clarification on where RED generation UI should be located\", \"Need confirmation that RED generation endpoint should be created in a separate ticket\")\r\n- **Why this blocks implementation** (e.g., \"Cannot implement AC without the UI surface where users will verify it\")\r\n\r\n#### Option B: Propose a Ticket Split\r\n\r\nPropose a ticket split that identifies:\r\n- **Which AC(s) require missing infrastructure** (list the full text of each AC)\r\n- **What sub-tickets are needed** (e.g., \"Ticket A: Create RED generation UI component\", \"Ticket B: Create `POST /api/artifacts/generate-red` endpoint\")\r\n- **Dependencies** (which sub-tickets must be completed first)\r\n- **Recommended order** for implementing the sub-tickets\r\n\r\n### Step 3: Document the AC Feasibility Gate Results\r\n\r\nThe agent **MUST** document the AC Feasibility Gate results in the implementation plan artifact:\r\n\r\n- **If all ACs are feasible:** Include the complete mapping table in the plan artifact\r\n- **If any AC is not feasible:** Include the clarification request or ticket split proposal in the plan artifact, and **do not proceed** with implementation\r\n\r\n### Example: Failing AC Mapping\r\n\r\n**Example scenario:** A ticket has an acceptance criterion: \"User can generate a RED (Requirements Engineering Document) artifact from the ticket detail view.\"\r\n\r\n**AC Feasibility Gate check:**\r\n```markdown\r\n### AC: \"User can generate a RED artifact from the ticket detail view\"\r\n\r\n- **UI Surface:** ❌ **NOT FOUND** — No RED generation UI component exists in the ticket detail view\r\n- **API/Endpoint:** ❌ **NOT FOUND** — No `POST /api/artifacts/generate-red` endpoint exists\r\n- **Feasibility:** ❌ **NOT FEASIBLE**\r\n\r\n**Missing components:**\r\n1. RED generation UI component (button/menu item in ticket detail view)\r\n2. RED generation API endpoint (`POST /api/artifacts/generate-red`)\r\n\r\n**Required action:** STOP implementation. Propose ticket split:\r\n- Ticket A: Create RED generation UI component in ticket detail view\r\n- Ticket B: Create `POST /api/artifacts/generate-red` endpoint\r\n- Ticket C: Wire UI component to API endpoint (depends on A and B)\r\n```\r\n\r\n**Expected behavior:** The agent stops, documents the ticket split proposal in the plan artifact, and does **not** proceed with partial implementation.\r\n\r\n### When to Perform AC Feasibility Gate\r\n\r\nThe AC Feasibility Gate **MUST** be performed:\r\n1. ✅ After checking for Implementation Agent Note (if any)\r\n2. ✅ **BEFORE** creating/switching to feature branch\r\n3. ✅ **BEFORE** reading any files for implementation\r\n4. ✅ **BEFORE** making any code changes\r\n\r\n**CRITICAL ORDERING:**\r\n- Check for Implementation Agent Note → **AC Feasibility Gate** → Branch Setup → Code Implementation\r\n\r\nOnly proceed to branch setup and coding if **all** acceptance criteria pass the feasibility gate.\r\n",
      "agentTypes": [
        "all",
        "implementation-agent"
      ],
      "topicId": "implementation-agent-workflow",
      "isBasic": false,
      "isSituational": false
    },
    {
      "path": "key-decisions-summary.mdc",
      "name": "key decisions summary",
      "description": "Require agents to include a \"Key decisions\" summary in completion write-ups so reviewers can understand tradeoffs without re-reading entire worklogs",
      "alwaysApply": true,
      "content": "# Key Decisions Summary Requirement\r\n\r\n**MANDATORY:** All agent completion write-ups must include a short, explicit **\"Key decisions\"** summary (2–6 bullets) so reviewers can quickly understand tradeoffs and design choices without re-reading the entire worklog or diff.\r\n\r\n## When This Requirement Applies\r\n\r\nThis requirement applies to **all agents** when completing work:\r\n\r\n- **Implementation agents** — Must include \"Key decisions\" in both the **PM Review artifact** and the **final chat completion summary**\r\n- **QA agents** — Must verify that the \"Key decisions\" section exists and is complete during review\r\n- **Project Manager agents** — Must check for \"Key decisions\" section when reviewing implementation artifacts\r\n\r\n## Required Content: Key Decisions Section\r\n\r\n**MANDATORY:** Implementation agents **must** include a \"Key decisions\" section in:\r\n\r\n1. **PM Review artifact** (stored in Supabase with `artifactType: \"pm-review\"`)\r\n2. **Final chat completion summary** (the \"done\" message sent to the user)\r\n\r\n### Format\r\n\r\nThe \"Key decisions\" section should be a bulleted list (2–6 bullets) that explains:\r\n\r\n- **Why approach A was chosen over approach B** (e.g., \"Used Supabase API endpoint instead of direct database access for better error handling and validation\")\r\n- **Any tradeoffs or risks** (e.g., \"Chose synchronous validation over async to simplify error handling, but this may block UI for large datasets\")\r\n- **Design choices that affect maintainability** (e.g., \"Stored instructions in Supabase rather than file system to enable runtime updates without deployments\")\r\n- **Performance or scalability considerations** (e.g., \"Implemented client-side caching to reduce API calls, with 5-minute TTL to balance freshness and performance\")\r\n- **Integration decisions** (e.g., \"Updated existing instruction update endpoint rather than creating new one to maintain API consistency\")\r\n\r\n### Example: Good Key Decisions Section\r\n\r\n```markdown\r\n## Key Decisions\r\n\r\n- **Stored instructions in Supabase instead of file system** — Enables runtime updates via HAL UI without requiring deployments or code changes. Tradeoff: Requires Supabase connection, but this is already a dependency for the project.\r\n\r\n- **Updated existing `/api/instructions/update` endpoint** — Rather than creating a new endpoint, extended the existing one to maintain API consistency. This keeps the instruction update workflow unified.\r\n\r\n- **Added \"Key decisions\" requirement to all agent types** — Not just implementation agents, but also QA and PM agents need to check for this section. This ensures comprehensive review coverage.\r\n\r\n- **Included example in instruction file** — Provides concrete guidance on what constitutes a good \"Key decisions\" bullet, helping agents understand the expected level of detail and tradeoff explanation.\r\n\r\n- **Required in both PM Review artifact and chat summary** — Ensures visibility in both the structured artifact (for audit trail) and the conversational summary (for immediate review).\r\n```\r\n\r\n### Example: Poor Key Decisions Section (Too Vague)\r\n\r\n```markdown\r\n## Key Decisions\r\n\r\n- Used Supabase for storage\r\n- Updated the API\r\n- Added requirements\r\n```\r\n\r\n**Why this is poor:** Doesn't explain tradeoffs, alternatives considered, or reasoning. Reviewers can't understand the \"why\" without reading the entire worklog.\r\n\r\n## Implementation Agent Requirements\r\n\r\n**MANDATORY:** When completing a ticket, implementation agents **must**:\r\n\r\n1. **Include \"Key decisions\" in PM Review artifact:**\r\n   - Store the PM Review artifact via HAL API: `POST /api/artifacts/insert-implementation`\r\n   - Artifact type: `pm-review`\r\n   - Title format: `PM Review for ticket <ticket-id>`\r\n   - The artifact body must include a \"Key decisions\" section with 2–6 bullets\r\n\r\n2. **Include \"Key decisions\" in final chat completion summary:**\r\n   - When sending the completion message (the \"done\" summary), include a \"Key decisions\" section\r\n   - This can be a brief summary (2–4 bullets) that highlights the most important decisions\r\n   - The full detailed version should be in the PM Review artifact\r\n\r\n### PM Review Artifact Template\r\n\r\n```markdown\r\n# PM Review for ticket <ticket-id>\r\n\r\n[Other PM Review content...]\r\n\r\n## Key Decisions\r\n\r\n- [Bullet 1: Why approach A over B, tradeoffs, risks]\r\n- [Bullet 2: Design choice affecting maintainability]\r\n- [Bullet 3: Performance/scalability consideration]\r\n- [Bullet 4: Integration decision]\r\n- [Bullet 5-6: Additional important decisions]\r\n\r\n[Other PM Review content...]\r\n```\r\n\r\n### Final Chat Summary Template\r\n\r\n```markdown\r\n## Summary\r\n\r\n[Brief summary of what was implemented...]\r\n\r\n## Key Decisions\r\n\r\n- [Most important decision 1]\r\n- [Most important decision 2]\r\n- [Most important decision 3]\r\n\r\nTicket <ticket-id> implementation completed and moved to QA.\r\n```\r\n\r\n## QA Agent Requirements\r\n\r\n**MANDATORY:** When QA agents review a ticket, they **must**:\r\n\r\n1. **Verify \"Key decisions\" section exists** — Check both:\r\n   - PM Review artifact (via HAL API: `POST /api/artifacts/get`)\r\n   - Final chat completion summary (if available in conversation history)\r\n\r\n2. **Verify \"Key decisions\" content quality** — The section should:\r\n   - Contain 2–6 bullets (not too few, not too many)\r\n   - Explain tradeoffs or alternatives considered\r\n   - Provide reasoning, not just descriptions\r\n   - Be specific enough that reviewers understand the \"why\" without reading the entire worklog\r\n\r\n3. **Include \"Key decisions\" review in QA report** — QA reports should include a section confirming:\r\n   - \"Key decisions\" section exists in PM Review artifact: [Yes / No]\r\n   - \"Key decisions\" section exists in completion summary: [Yes / No / N/A]\r\n   - Content quality: [Pass / Fail / Needs improvement]\r\n   - If missing or incomplete, QA **MUST FAIL** the ticket\r\n\r\n### QA Report Template Addition\r\n\r\nQA reports should include:\r\n\r\n```markdown\r\n## Key Decisions Review\r\n\r\n**Key decisions section in PM Review artifact:** [Yes / No]\r\n\r\n**Key decisions section in completion summary:** [Yes / No / N/A]\r\n\r\n**Content quality:**\r\n- [ ] Contains 2–6 bullets: [Yes / No]\r\n- [ ] Explains tradeoffs or alternatives: [Yes / No]\r\n- [ ] Provides reasoning (not just descriptions): [Yes / No]\r\n- [ ] Specific enough to understand \"why\" without reading full worklog: [Yes / No]\r\n\r\n**Overall assessment:** [Pass / Fail / Needs improvement]\r\n\r\n**If missing or incomplete:** QA **MUST FAIL** the ticket and request the implementation agent to add the \"Key decisions\" section.\r\n```\r\n\r\n## Project Manager Agent Requirements\r\n\r\n**MANDATORY:** When Project Manager agents review implementation artifacts, they **must**:\r\n\r\n1. **Check for \"Key decisions\" section** — Verify it exists in the PM Review artifact\r\n\r\n2. **Verify completeness** — Ensure the section:\r\n   - Contains 2–6 bullets\r\n   - Explains tradeoffs and reasoning\r\n   - Helps reviewers understand design choices quickly\r\n\r\n3. **Flag missing sections** — If \"Key decisions\" is missing or incomplete, PM agents should:\r\n   - Note this in their review\r\n   - Request the implementation agent to add it\r\n   - Consider this a blocker for ticket completion\r\n\r\n## Integration with Existing Workflows\r\n\r\n### PM Review Artifact\r\n\r\nThe \"Key decisions\" section must be included in the **PM Review artifact** stored in Supabase:\r\n- **Artifact type:** `pm-review`\r\n- **Title format:** `PM Review for ticket <ticket-id>`\r\n- **Storage:** Via HAL API endpoint `/api/artifacts/insert-implementation` with `artifactType: \"pm-review\"`\r\n\r\n### Final Chat Completion Summary\r\n\r\nThe \"Key decisions\" section must also be included in the **final chat completion summary** (the \"done\" message):\r\n- This is the message sent when the implementation agent completes work\r\n- Can be a brief version (2–4 bullets) highlighting the most important decisions\r\n- The full detailed version should be in the PM Review artifact\r\n\r\n### QA Audit Report\r\n\r\nQA agents must verify \"Key decisions\" documentation as part of their standard QA workflow.\r\n\r\n## Scope\r\n\r\n- Applies to **all agents** (implementation, QA, PM) when completing or reviewing work\r\n- The \"Key decisions\" section must be **human-verifiable** — a reviewer can open the PM Review artifact and immediately see the key decisions and tradeoffs\r\n- When in doubt, **include more detail** — it's better to over-explain tradeoffs than to leave reviewers guessing why certain approaches were chosen\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "key-decisions-summary",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "Key Decisions Summary Requirement",
        "description": "Require agents to include a \"Key decisions\" summary in completion write-ups so reviewers can understand tradeoffs without re-reading entire worklogs",
        "agentTypes": [
          "all"
        ]
      }
    },
    {
      "path": "qa-audit-report.mdc",
      "name": "qa audit report",
      "description": "QA agents must store QA reports in Supabase via HAL API",
      "alwaysApply": true,
      "content": "# QA Audit Report (QA Agents)\r\n\r\nWhen you **QA a ticket** (verify, check a ticket that is allegedly complete), store a QA report via HAL API. See `docs/process/hal-tool-call-contract.mdc` for endpoints.\r\n\r\n## Branch to use\r\n\r\n- **If ticket states \"merged to main for QA access\":** Verify from `main`. Do not use feature branch. Record in report that verification was on `main`. **No merge needed** (already on main).\r\n- **Otherwise:** Use feature branch from ticket. **MANDATORY:** If QA passes, you **MUST** merge the feature branch to `main` and delete the branch before completing QA. If QA fails, do not merge.\r\n\r\n## 8 required implementation artifacts (must be present before QA)\r\n\r\n1. plan, 2. worklog, 3. changed-files, 4. decisions, 5. verification, 6. pm-review, 7. git-diff, 8. instructions-used\r\n\r\n**Changed Files:** Must be NON-EMPTY. When files changed: list paths with brief descriptions. When no files changed: state \"No files changed.\" with reason. Blank/empty = PROCESS FAILURE.\r\n\r\n**How to check:** `POST ${baseUrl}/api/artifacts/get` with `{ ticketId }`. Filter `agent_type === \"implementation\"`. Match titles `Plan for ticket X`, etc.\r\n\r\n**Auto-fail:** API fails, any artifact missing, or Changed Files blank → QA FAIL immediately. Store QA report, move to `col-todo`, final message: `QA RESULT: FAIL — <ticket-id>`.\r\n\r\n## QA report structure\r\n\r\n1. Ticket & deliverable\r\n2. Missing artifacts (if any) — list them, then fail\r\n3. Audit artifacts present (if all present)\r\n4. Code review — PASS/FAIL with evidence\r\n5. Build verification — **MANDATORY:** `npm run build:hal`; TypeScript errors = FAIL\r\n6. Coverage — **MANDATORY:** Whole-repo test coverage with 4-metric table and command used; see \"Coverage section\" below\r\n7. Code Quality — **MANDATORY:** Whole-repo code quality metric; see \"Code Quality section\" below\r\n8. UI verification — automated and/or manual steps\r\n9. AC Confirmation Checklist — enumerate each AC, Met/Not met with evidence; see `ac-confirmation-checklist.mdc`\r\n10. Verdict — PASS or FAIL\r\n\r\n## Coverage section\r\n\r\n**MANDATORY:** Every QA report **MUST** include a **Coverage** section with:\r\n\r\n1. **A 4-metric table** showing **whole-repo** coverage percentages (not just the ticket’s code):\r\n   - Lines\r\n   - Functions\r\n   - Branches\r\n   - Statements\r\n\r\n2. **The command used** to generate the coverage numbers\r\n\r\n**How to generate coverage:**\r\n\r\nRun the **full** test suite with coverage (whole repo):\r\n\r\n```bash\r\nnpm run test:coverage\r\n```\r\n\r\nThis runs vitest with coverage over the entire codebase and outputs a text summary. Extract the overall coverage percentages from the output and include them in a table in the QA report. Do not run only tests for changed files; use the full suite.\r\n\r\n**Coverage section format:**\r\n\r\n```markdown\r\n## Coverage\r\n\r\n| Metric | Coverage |\r\n|--------|----------|\r\n| Lines | XX% |\r\n| Functions | XX% |\r\n| Branches | XX% |\r\n| Statements | XX% |\r\n\r\n**Command used:** `npm run test:coverage`\r\n```\r\n\r\n**Note:** Coverage numbers must reflect the current commit under test (not hardcoded). Run the command on the branch/commit being verified.\r\n\r\n## Code Quality section\r\n\r\n**MANDATORY:** Every QA report **MUST** include a **Code Quality** section with a single whole-repo percentage and concrete guidance.\r\n\r\n**How to generate maintainability:**\r\n\r\nRun the repo’s maintainability report (uses a maintainability library over the whole codebase):\r\n\r\n```bash\r\nnpm run report:simplicity\r\n```\r\n\r\nThe script prints a single line: `Simplicity: XX%`. **IMPORTANT:** Even though the script output says \"Simplicity\", you **MUST** use the label **\"Code Quality\"** (not \"Simplicity\" or \"Maintainability\") in your QA report. The words \"Simplicity\" and \"Maintainability\" should **NOT** appear anywhere in the user-visible QA report text.\r\n\r\n**Code Quality section format:**\r\n\r\n```markdown\r\n## Code Quality\r\n\r\nCode Quality: XX%\r\n\r\nThe code quality metric measures code quality across the entire repository. Higher scores indicate:\r\n\r\n- **Readability:** Code is clear, well-structured, and easy to understand\r\n- **Testability:** Code is designed to be easily tested with good separation of concerns\r\n- **Change safety:** Code changes are less likely to introduce bugs or break existing functionality\r\n```\r\n\r\n**CRITICAL:** \r\n- Use the exact heading `## Code Quality` (not \"Simplicity\", \"Maintainability\", or any variation)\r\n- Include all three bullets (Readability, Testability, Change safety) in your report\r\n- Do not mention \"Simplicity\" or \"Maintainability\" anywhere in the QA report body\r\n\r\n**Note:** Run this on the branch/commit being verified. The number is for the whole repo, not just the ticket’s changes.\r\n\r\n## Storing QA report\r\n\r\nMake actual HTTP calls: `POST ${baseUrl}/api/artifacts/insert-qa` with `{ ticketId, title, body_md }`. Use `curl` or run_terminal_cmd. Do not just include JSON in your message.\r\n\r\n## Implementation Agent Note (for FAIL verdicts)\r\n\r\n**MANDATORY:** When a ticket fails QA (or HITL), you **MUST** create a separate, concise \"Implementation agent note\" artifact that explains why the ticket failed. This note is for implementation agents to quickly understand what needs to be fixed.\r\n\r\n**Format:**\r\n- Title: `Implementation agent note for ticket HAL-XXXX` (preferred) or `Note for implementation agent: HAL-XXXX`\r\n- Keep it short (2-4 bullet points max)\r\n- Focus on actionable items\r\n- No detailed analysis—just what's wrong and what to fix\r\n- Implementation agents are required to check for this artifact first before starting work\r\n\r\n**Example structure:**\r\n```markdown\r\n# Implementation Agent Note: HAL-XXXX\r\n\r\n## Status: FAIL\r\n\r\n## Why This Ticket Failed\r\n\r\n1. **Issue 1:** Brief description\r\n2. **Issue 2:** Brief description\r\n\r\n## Required Actions\r\n\r\n1. Action item 1\r\n2. Action item 2\r\n3. Action item 3\r\n\r\n## Code Review Notes\r\n\r\nBrief note if implementation is otherwise correct.\r\n```\r\n\r\n**Store via:** `POST ${baseUrl}/api/artifacts/insert-qa` with `{ ticketId, title: \"Implementation agent note for ticket HAL-XXXX\", body_md }`\r\n\r\n## Completion\r\n\r\n**CRITICAL: All ticket movements are AUTOMATIC - DO NOT wait for user interaction or ask for permission. Just move the tickets automatically.**\r\n\r\n- **PASS:** \r\n 1. Store QA report\r\n 2. **MANDATORY:** If feature branch exists (not already on main), merge feature branch to `main` and push to remote: `git checkout main && git merge <feature-branch> && git push origin main`\r\n    - **CRITICAL:** Both `git merge` and `git push origin main` must succeed. If either fails:\r\n      - **Retry with exponential backoff:** Attempt up to 4 times with delays (4s, 8s, 16s, 32s)\r\n      - **If all retries fail:** Surface the error in the final summary message and **DO NOT** move the ticket to `col-human-in-the-loop`\r\n      - **Keep ticket in QA:** The ticket must remain in its current column (or move to `col-todo` if appropriate) until merge/push succeeds\r\n    - **Only after confirmed successful merge + push:** Proceed to step 3\r\n 3. **MANDATORY:** Delete feature branch (local and remote): `git branch -d <feature-branch> && git push origin --delete <feature-branch>` (only if branch exists and merge/push succeeded)\r\n    - **CRITICAL:** Branch deletion only happens after confirmed successful merge + push. If merge/push failed, do not delete the branch.\r\n 4. **MANDATORY:** **AUTOMATICALLY** move ticket to `col-human-in-the-loop` **ONLY IF** merge and push both succeeded. If merge/push failed, do not move the ticket forward.\r\n    - **Move ticket automatically using HAL API:**\r\n    ```javascript\r\n    const baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\r\n    const res = await fetch(`${baseUrl}/api/tickets/move`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ ticketId: '<ticket-id>', columnId: 'col-human-in-the-loop' }),\r\n    })\r\n    const result = await res.json()\r\n    // If move fails, log it but continue - system handles failures gracefully\r\n    ```\r\n    - **DO NOT ask user for permission - just move it automatically**\r\n 5. Send summary. Final message must include: `QA RESULT: PASS — <ticket-id>`\r\n    - **If merge/push failed:** Include error details in summary and state that ticket was not moved to HITL due to merge/push failure\r\n- **FAIL:** \r\n 1. Store full QA report\r\n 2. **MANDATORY:** Store Implementation agent note\r\n 3. **AUTOMATICALLY** move ticket to `col-todo` using HAL API:\r\n    ```javascript\r\n    const baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\r\n    const res = await fetch(`${baseUrl}/api/tickets/move`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ ticketId: '<ticket-id>', columnId: 'col-todo' }),\r\n    })\r\n    const result = await res.json()\r\n    // If move fails, log it but continue - system handles failures gracefully\r\n    ```\r\n    - **DO NOT ask user for permission - just move it automatically**\r\n 4. **Do NOT merge feature branch** (leave it for implementation agent to fix)\r\n 5. Send summary. Final message must include: `QA RESULT: FAIL — <ticket-id>`\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent"
      ],
      "topicId": "qa-audit-report",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "state-management-change-documentation.mdc",
      "name": "state management change documentation",
      "description": "Require agents to document and justify any changes to application state management in review artifacts",
      "alwaysApply": true,
      "content": "# State Management Change Documentation\r\n\r\n**MANDATORY:** Any change to application state management (stores, reducers, context, persistence, query cache, etc.) must be **called out and justified** in the agent's review artifact(s), so reviewers can quickly understand behavioral risk.\r\n\r\n## What is a \"State Management Change\"?\r\n\r\nA **state management change** is any modification to how application state is stored, accessed, updated, or persisted. This includes:\r\n\r\n### Examples of State Management Changes\r\n\r\n- **Store modifications** (Zustand, Redux, Pinia, etc.)\r\n  - Adding/removing/modifying store slices or actions\r\n  - Changing store structure or initial state\r\n  - Modifying store selectors or computed values\r\n\r\n- **Context provider changes** (React Context, Vue provide/inject, etc.)\r\n  - Adding/removing/modifying context providers\r\n  - Changing context value structure\r\n  - Modifying context consumers\r\n\r\n- **Persistence/hydration changes**\r\n  - Adding/removing localStorage/sessionStorage usage\r\n  - Changing persistence keys or serialization format\r\n  - Modifying hydration logic (loading persisted state on app start)\r\n  - Changing persistence scope (what gets persisted vs. ephemeral)\r\n\r\n- **Query cache changes** (React Query, SWR, Apollo, etc.)\r\n  - Modifying cache keys or invalidation strategies\r\n  - Changing cache time-to-live (TTL) or stale-while-revalidate settings\r\n  - Adding/removing cache mutations or optimistic updates\r\n\r\n- **Cross-tab synchronization changes**\r\n  - Adding/removing `storage` event listeners\r\n  - Modifying broadcast channel or shared worker usage\r\n  - Changing how state syncs across browser tabs/windows\r\n\r\n- **State migration changes**\r\n  - Adding migration logic for existing persisted state\r\n  - Changing state schema versions\r\n  - Modifying backward compatibility handling\r\n\r\n## When This Requirement Applies\r\n\r\nThis requirement applies to **all agents** when making changes that affect state management:\r\n\r\n- **Implementation agents** — Must document state management changes in their **PM Review artifact**\r\n- **QA agents** — Must verify that state management changes are properly documented and check the impact during QA review\r\n- **Project Manager agents** — Must ensure state management changes are called out in PM reviews\r\n\r\n## Required Documentation: PM Review Checklist\r\n\r\n**MANDATORY:** When an implementation agent makes any state management change, they **must** include the following checklist in their **PM Review artifact** (stored in Supabase with `artifactType: \"pm-review\"`).\r\n\r\n### Copy/Paste Checklist Template\r\n\r\n```markdown\r\n## State Management Changes\r\n\r\n**State management changes made:** [Yes / No]\r\n\r\nIf Yes, complete the following:\r\n\r\n### What Changed\r\n- [ ] Store/Context/Cache modified: [specify which and what changed]\r\n- [ ] Persistence logic modified: [specify what changed]\r\n- [ ] Migration logic added: [specify what changed]\r\n- [ ] Other state management change: [specify what changed]\r\n\r\n### Why This Change Was Necessary\r\n[Brief explanation of why the state management change was required]\r\n\r\n### Migration Considerations\r\n- [ ] Existing persisted state affected: [Yes / No]\r\n- [ ] Backward compatibility: [Maintained / Broken / N/A]\r\n- [ ] Migration path: [Describe how existing users' state will be handled, if applicable]\r\n\r\n### User-Visible Impact\r\n- [ ] State persists across sessions: [Yes / No / Changed]\r\n- [ ] State syncs across tabs: [Yes / No / Changed]\r\n- [ ] User data loss risk: [None / Low / Medium / High]\r\n- [ ] Performance impact: [None / Low / Medium / High]\r\n- [ ] Breaking changes: [None / Describe if any]\r\n\r\n### Code Locations\r\n[Cite specific file paths and line numbers where state management changes were made, per `.cursor/rules/code-location-citations.mdc`]\r\n```\r\n\r\n## QA Review Requirements\r\n\r\n**MANDATORY:** When QA agents review a ticket that includes state management changes, they **must**:\r\n\r\n1. **Verify the PM Review artifact includes the state management checklist** — If state management changes were made but the checklist is missing or incomplete, QA **MUST FAIL** the ticket.\r\n\r\n2. **Review the documented impact** — QA should verify:\r\n   - The \"What Changed\" section accurately describes the code changes\r\n   - The \"Why This Change Was Necessary\" provides adequate justification\r\n   - Migration considerations are addressed if applicable\r\n   - User-visible impact is accurately assessed\r\n\r\n3. **Include state management review in QA report** — QA reports should include a section confirming:\r\n   - State management changes were properly documented (or \"No state management changes\" if none were made)\r\n   - The documented impact assessment appears reasonable\r\n   - Any concerns about user data loss, breaking changes, or migration issues\r\n\r\n### QA Report Template Addition\r\n\r\nQA reports should include:\r\n\r\n```markdown\r\n## State Management Review\r\n\r\n**State management changes:** [Yes / No]\r\n\r\nIf Yes:\r\n- [ ] PM Review includes complete state management checklist\r\n- [ ] Documented changes match code review findings\r\n- [ ] Migration considerations addressed: [Yes / No / N/A]\r\n- [ ] User-visible impact assessment appears reasonable: [Yes / No]\r\n- [ ] Concerns identified: [None / List any concerns]\r\n```\r\n\r\n## Integration with Existing Workflows\r\n\r\n### PM Review Artifact\r\n\r\nThe state management checklist must be included in the **PM Review artifact** stored in Supabase:\r\n- **Artifact type:** `pm-review`\r\n- **Title format:** `PM Review for ticket <ticket-id>`\r\n- **Storage:** Via HAL API endpoint `/api/artifacts/insert-pm-review` (or equivalent)\r\n\r\n### QA Audit Report\r\n\r\nQA agents must verify state management documentation as part of their standard QA workflow (see `.cursor/rules/qa-audit-report.mdc`).\r\n\r\n## Scope\r\n\r\n- Applies to **all agents** (implementation, QA, PM) when state management changes are involved\r\n- The checklist must be **human-verifiable** — a reviewer can open the PM Review artifact and immediately see whether state management changes were made and their impact\r\n- When in doubt, **document the change** — it's better to over-document than to miss a state management change that could affect user experience\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "state-management-change-documentation",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "State Management Change Documentation",
        "description": "Require agents to document and justify any changes to application state management in review artifacts",
        "agentTypes": [
          "all"
        ]
      }
    }
  ],
  "basic": [
    {
      "path": "agent-instructions.mdc",
      "name": "agent instructions",
      "description": "PM agent instructions; HAL API usage; move ticket to Ready for QA",
      "alwaysApply": true,
      "content": "# Agent Instructions (Local)\r\n\r\nInstructions are loaded from `.cursor/rules` and `docs/`. See `docs/process/hal-tool-call-contract.mdc` for HAL API endpoints.\r\n\r\n## API-only Data Access (ALL Agents)\r\n\r\n**MANDATORY:** Agents must **never** call the database directly (no direct Supabase client usage, no `@supabase/supabase-js`, no `SUPABASE_*` env vars in agent runtime).\r\n\r\n- **All ticket operations** (create/update/move/list/get) must go through HAL endpoints under `/api/tickets/*`.\r\n- **All artifact operations** must go through HAL endpoints under `/api/artifacts/*`.\r\n- HAL server endpoints use **server-side privileged Supabase credentials** (e.g. `SUPABASE_SECRET_KEY` / service role) to bypass RLS safely.\r\n\r\n## Pre-Commit Build Verification\r\n\r\n**MANDATORY:** Before committing ANY code changes, ALL agents **MUST** verify the build succeeds:\r\n\r\n1. **Install dependencies (if not already done):**\r\n   ```bash\r\n   npm install\r\n   ```\r\n\r\n2. **Verify TypeScript compilation:**\r\n   ```bash\r\n   npx tsc -b --noEmit\r\n   ```\r\n   \r\n   This must pass with zero errors. If it fails, fix all TypeScript errors before committing.\r\n\r\n3. **Verify full build (if making changes that affect build):**\r\n   ```bash\r\n   npm run build:hal\r\n   ```\r\n   \r\n   **Note:** `npm run build:hal` may fail due to vite 6.x scanning node_modules during config loading (pre-existing issue). If this happens, verify TypeScript compilation succeeds instead:\r\n   ```bash\r\n   npx tsc -b --noEmit\r\n   ```\r\n   \r\n   If TypeScript compilation fails, you **MUST** fix the errors before committing. Do not commit code that breaks TypeScript compilation.\r\n\r\n4. **For specific projects:**\r\n   ```bash\r\n   cd projects/kanban && npx tsc --noEmit  # Check kanban project specifically\r\n   ```\r\n\r\n**CRITICAL RULES:**\r\n- **NEVER commit code without running `npx tsc -b --noEmit` first**\r\n- **NEVER commit code that causes `npm run build:hal` to fail**\r\n- **If build fails, fix it before committing - do not leave broken builds for others to discover**\r\n- This applies to ALL agents (implementation, QA, PM) when making code changes\r\n\r\n**This check prevents build failures in CI/CD and ensures code quality.**\r\n\r\n## Moving Tickets After Implementation\r\n\r\n**MANDATORY:** After implementation, the implementation agent **MUST** automatically move the ticket to **Ready for QA** before sending a completion summary. **DO NOT wait for user interaction or ask for permission - just move it.**\r\n\r\n**Move ticket to Ready for QA (AUTOMATIC - NO USER INTERACTION REQUIRED):**\r\n```javascript\r\nconst baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\r\nconst res = await fetch(`${baseUrl}/api/tickets/move`, {\r\n  method: 'POST',\r\n  headers: { 'Content-Type': 'application/json' },\r\n  body: JSON.stringify({ ticketId: '0167', columnId: 'col-qa' }),\r\n})\r\nconst result = await res.json()\r\nif (!result.success) {\r\n  // If missing artifacts, store them and retry\r\n  if (result.missingArtifacts && Array.isArray(result.missingArtifacts)) {\r\n    // Store missing artifacts, then retry move\r\n    // (implementation details in error handling below)\r\n  } else {\r\n    throw new Error(`Failed to move ticket: ${result.error}`)\r\n  }\r\n}\r\n```\r\n\r\n**When to move (AUTOMATIC WORKFLOW - NO USER INTERACTION):**\r\n1. ✅ After all code changes are committed and pushed\r\n2. ✅ After all 8 required artifacts are stored (plan, worklog, changed-files, decisions, verification, pm-review, git-diff, instructions-used)\r\n3. ✅ **Automatically call get_artifacts** (or POST /api/artifacts/get) and confirm all 8 required implementation artifacts are present with substantive content\r\n4. ✅ **AUTOMATICALLY MOVE THE TICKET TO READY FOR QA** (use the API call above) - **DO THIS AUTOMATICALLY, DO NOT ASK USER**\r\n5. ✅ **THEN** send your final \"implementation complete\" summary message\r\n\r\n**Error Handling for Ticket Move:**\r\n- **If move returns success: false with missingArtifacts:** Automatically store each listed artifact via POST /api/artifacts/insert-implementation with the corresponding artifactType, then automatically retry POST /api/tickets/move. The move API will not allow moving to Ready for QA until all 8 artifacts are present.\r\n- **If move fails for other reasons:** Log the error, but **STILL ATTEMPT TO MOVE**. The system is designed to handle failures gracefully. Do not block completion - move the ticket and note any issues in your summary.\r\n\r\n**CRITICAL WORKFLOW RULES:** \r\n- **ALWAYS move the ticket automatically** - never ask the user for permission or wait for confirmation\r\n- **DO NOT** send a completion summary or \"done\" message without first moving the ticket to Ready for QA\r\n- **DO NOT** mark the ticket as complete in your message if you haven't moved it\r\n- The ticket move is **part of the completion workflow**, not an optional step\r\n- **If the move fails, retry automatically** - do not give up after one failure\r\n- **The system is designed to handle failures** - if a move fails, it's okay, just note it and move on\r\n\r\n**Available column IDs:**\r\n- `col-unassigned` - Unassigned\r\n- `col-todo` - To-do\r\n- `col-doing` - Doing (Active Work)\r\n- `col-qa` - Ready for QA\r\n- `col-human-in-the-loop` - Human in the Loop\r\n- `col-process-review` - Process Review\r\n- `col-done` - Done\r\n- `col-wont-implement` - Will Not Implement\r\n\r\n**Note:** The HAL API endpoint `/api/tickets/move` uses server-side Supabase credentials, so agents don't need to provide credentials in the request body. The API uses the ticket's primary key (pk) for updates to ensure reliable ticket movement regardless of the ticket ID format provided.\r\n\r\n## QA Notes in Completion Summary\r\n\r\n**MANDATORY:** All final completion summaries from **Implementation agents** and **Project Manager agents** **MUST** include a **QA Notes** section that maps each Acceptance Criteria to a concrete UI verification location.\r\n\r\n### Requirements\r\n\r\n1. **Enumerate each Acceptance Criteria** — The QA Notes section must list **every single AC** from the ticket.\r\n\r\n2. **Provide exact UI location/route** — For each AC, specify:\r\n   - The exact UI route/path where the AC can be verified (e.g., `/settings`, `/tickets/HAL-0841`, `/kanban`)\r\n   - Any relevant UI labels, buttons, or elements that demonstrate the AC is met (e.g., \"Settings page → 'Dark mode' toggle switch\", \"Ticket detail page → 'Status' field shows 'Ready for QA'\")\r\n   - Clear navigation steps if needed (e.g., \"Navigate to Settings → Appearance section → Verify 'Dark mode' toggle is visible\")\r\n\r\n3. **Mark non-UI-verifiable ACs as Blocked** — If any AC cannot be verified in the UI (e.g., requires terminal access, database inspection, or code review), the agent **MUST**:\r\n   - Mark that AC as **Blocked** in the QA Notes section\r\n   - **NOT** claim the ticket is complete if any AC is Blocked\r\n   - Either move the ticket to an appropriate column (e.g., \"To-do\" if work remains) or create a follow-up ticket to address the non-UI-verifiable requirement\r\n\r\n**CRITICAL:** If any AC is marked as **Blocked** (not UI-verifiable), the ticket **CANNOT** be marked complete or moved to \"Ready for QA\". The agent must either:\r\n- Update the AC to be UI-verifiable, OR\r\n- Document why the AC cannot be UI-verifiable and move the ticket to an appropriate status (e.g., \"Will Not Implement\" if the AC is intentionally non-UI-verifiable)\r\n\r\n### QA Notes Section Format\r\n\r\nThe QA Notes section must appear in the **final completion summary** (the \"done\" message sent to the user). It should follow this format:\r\n\r\n```markdown\r\n## QA Notes\r\n\r\n### AC 1: \"[Full text of AC 1]\"\r\n- **UI Location:** `/settings` → Appearance section\r\n- **Verification:** Navigate to Settings page, scroll to Appearance section, verify \"Dark mode\" toggle switch is visible and clickable\r\n- **Status:** ✅ UI-verifiable\r\n\r\n### AC 2: \"[Full text of AC 2]\"\r\n- **UI Location:** `/tickets/HAL-0841` → Ticket detail page\r\n- **Verification:** Open ticket HAL-0841, verify \"Status\" field displays \"Ready for QA\"\r\n- **Status:** ✅ UI-verifiable\r\n\r\n### AC 3: \"[Full text of AC 3]\"\r\n- **UI Location:** N/A (requires database inspection)\r\n- **Verification:** Cannot be verified in UI - requires direct database access\r\n- **Status:** ⚠️ Blocked (not UI-verifiable)\r\n```\r\n\r\n### Example: Complete Final Summary with QA Notes\r\n\r\n```markdown\r\n## Summary\r\n\r\nImplemented dark mode toggle feature with persistence. Added toggle switch to Settings page, implemented theme switching logic, and stored preference in localStorage.\r\n\r\n## Key Decisions\r\n\r\n- Used localStorage for persistence to avoid backend changes\r\n- Implemented theme switching via CSS variables for performance\r\n\r\n## QA Notes\r\n\r\n### AC 1: \"Settings page displays a 'Dark mode' toggle switch that is clearly visible and clickable\"\r\n- **UI Location:** `/settings` → Appearance section\r\n- **Verification:** Navigate to Settings page, scroll to Appearance section, verify \"Dark mode\" toggle switch is visible and clickable\r\n- **Status:** ✅ UI-verifiable\r\n\r\n### AC 2: \"Clicking the toggle immediately changes the app theme from light to dark (or vice versa) with a smooth transition\"\r\n- **UI Location:** `/settings` → Appearance section → \"Dark mode\" toggle\r\n- **Verification:** Click the \"Dark mode\" toggle, observe entire app UI transitions from light to dark theme (or vice versa) with smooth animation\r\n- **Status:** ✅ UI-verifiable\r\n\r\n### AC 3: \"The selected theme preference persists after page refresh (the toggle state matches the current theme on reload)\"\r\n- **UI Location:** `/settings` → Appearance section → \"Dark mode\" toggle\r\n- **Verification:** Set theme to dark mode, refresh page (F5 or Cmd+R), verify page reloads with dark theme and toggle switch is in \"on\" position\r\n- **Status:** ✅ UI-verifiable\r\n\r\nTicket HAL-0841 implementation completed and moved to QA.\r\n```\r\n\r\n### Integration with AC Confirmation Checklist\r\n\r\nThe QA Notes section **complements** the AC Confirmation Checklist (see `.cursor/rules/ac-confirmation-checklist.mdc`). Both sections should appear in the final completion summary:\r\n\r\n- **AC Confirmation Checklist** — Enumerates each AC with \"Met\" / \"Not met\" status and evidence (file paths, artifacts, etc.)\r\n- **QA Notes** — Maps each AC to exact UI location/route for human verification\r\n\r\nTogether, these sections ensure that:\r\n1. All ACs are explicitly addressed (AC Confirmation Checklist)\r\n2. All ACs can be verified in the UI (QA Notes)\r\n3. Reviewers can quickly verify completion without terminal access (QA Notes)\r\n\r\n### Scope\r\n\r\n- **Applies to:** Implementation agents, Project Manager agents\r\n- **Applies when:** Before sending final completion summary (after moving ticket to \"Ready for QA\" or final status)\r\n- **Mandatory:** Yes - this is a required section in completion summaries, not optional\r\n- **Location:** Must appear in the final chat completion summary message\r\n",
      "agentTypes": [
        "all",
        "implementation-agent",
        "project-manager",
        "process-review-agent"
      ],
      "topicId": "agent-instructions",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "Agent Instructions Entry Point",
        "description": "Entry point for agent instructions - load basic rules from Supabase",
        "agentTypes": [
          "all"
        ]
      }
    },
    {
      "path": "code-citation-requirements.mdc",
      "name": "code citation requirements",
      "description": "Require agents to cite specific file paths and line numbers when referencing code locations",
      "alwaysApply": true,
      "content": "# Code Citation Requirements\r\n\r\nWhen agents reference \"where something is implemented\" or claim where key functionality exists, they **must** cite concrete code locations using file paths and (when feasible) line numbers or symbol names. This enables reviewers to verify claims quickly without searching the codebase.\r\n\r\n## Mandatory Citation Format\r\n\r\n**Minimum acceptable citation formats:**\r\n\r\n1. **File path with line range:** `src/foo.ts:42-61`\r\n2. **File path with single line:** `src/foo.ts:42`\r\n3. **File path with symbol name:** `src/foo.ts — function bar()` or `src/foo.ts — class MyComponent`\r\n4. **File path with line and symbol:** `src/foo.ts:42 — function bar()`\r\n\r\n**Examples:**\r\n- ✅ `src/api/tickets.ts:123-145` — implementation of ticket syncing\r\n- ✅ `components/KanbanBoard.tsx:42` — column rendering logic\r\n- ✅ `src/utils/validation.ts — function validateTicket()` — validation rules\r\n- ✅ `src/hooks/useTickets.ts:78-92 — useEffect hook` — data fetching\r\n- ❌ \"in the tickets API file\" — too vague\r\n- ❌ \"tickets.ts\" — missing path context\r\n- ❌ \"the validation function\" — no file reference\r\n\r\n## Required Contexts\r\n\r\nThis requirement applies to all of the following contexts:\r\n\r\n### 1. Implementation Summaries and Worklogs\r\n\r\nWhen implementation agents document what was implemented, they must cite specific locations:\r\n\r\n**Example (worklog):**\r\n```markdown\r\n## Changes Made\r\n\r\n- Added ticket syncing logic in `src/api/tickets.ts:123-145` — `syncTickets()` function\r\n- Updated column rendering in `components/KanbanBoard.tsx:42-67` — `renderColumns()` method\r\n- Fixed validation in `src/utils/validation.ts:89-102 — validateTicket()` function\r\n```\r\n\r\n### 2. QA Reports\r\n\r\nWhen QA agents review code and report findings, they must cite specific locations:\r\n\r\n**Example (QA report code review section):**\r\n```markdown\r\n## Code Review\r\n\r\n| Requirement | Implementation | Status |\r\n|------------|----------------|--------|\r\n| Ticket syncing | `src/api/tickets.ts:123-145 — syncTickets()` | ✅ PASS |\r\n| Column rendering | `components/KanbanBoard.tsx:42-67` | ✅ PASS |\r\n| Validation | `src/utils/validation.ts:89-102 — validateTicket()` | ⚠️ FAIL — missing null check |\r\n```\r\n\r\n### 3. PM Guidance\r\n\r\nWhen Project Manager agents answer questions like \"Where is X implemented?\" or \"How does Y work?\", they must cite specific locations:\r\n\r\n**Example (PM response):**\r\n```markdown\r\nTicket syncing is implemented in `src/api/tickets.ts:123-145` in the `syncTickets()` function. The function handles:\r\n- Fetching tickets from Supabase (`src/api/tickets.ts:130-138`)\r\n- Updating local state (`src/api/tickets.ts:140-145`)\r\n```\r\n\r\n## Exceptions: When Line Numbers Are Unreliable\r\n\r\nWhen line numbers are unreliable or unstable (e.g., generated code, minified bundles, frequently changing files), cite the nearest stable anchor instead:\r\n\r\n**Acceptable alternatives:**\r\n- **Symbol name + file path:** `src/generated/api.ts — export function fetchTickets()`\r\n- **Exported function/class:** `src/api/index.ts — export { syncTickets }`\r\n- **Route ID or path:** `src/routes.ts — route id: 'tickets'`\r\n- **Component name:** `components/TicketCard.tsx — <TicketCard /> component`\r\n- **Configuration key:** `config/app.config.ts — tickets.syncInterval`\r\n\r\n**Examples:**\r\n- ✅ `dist/bundle.js — function syncTickets()` (minified bundle)\r\n- ✅ `src/generated/types.ts — interface Ticket` (generated file)\r\n- ✅ `src/routes.ts — route: '/tickets'` (routing config)\r\n- ❌ `dist/bundle.js:1234` (line number in minified code is unreliable)\r\n\r\n**When in doubt:** Prefer symbol names, exported identifiers, or stable configuration keys over line numbers in generated or frequently-changing files.\r\n\r\n## Enforcement\r\n\r\n- **Implementation agents:** Must include citations in worklogs, plans, and implementation summaries.\r\n- **QA agents:** Must include citations in code review sections of QA reports (see `.cursor/rules/qa-audit-report.mdc`).\r\n- **PM agents:** Must include citations when answering \"where is X implemented?\" questions.\r\n\r\n**Reviewers should verify:** All code location claims can be verified by navigating to the cited file path and (when provided) line number or symbol name.\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "code-citation-requirements",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "Code Citation Requirements",
        "description": "Require agents to cite specific file paths and line numbers when referencing code locations",
        "agentTypes": [
          "all"
        ]
      }
    },
    {
      "path": "code-location-citations.mdc",
      "name": "code location citations",
      "description": "Require agents to cite specific file paths and line numbers/symbols when referencing where functionality is implemented",
      "alwaysApply": true,
      "content": "# Code Location Citations\r\n\r\nWhen an agent references \"where something is implemented\" or claims where key functionality exists, they **must** cite concrete code locations that reviewers can verify quickly.\r\n\r\n## Required Citation Format\r\n\r\n**Minimum acceptable citation formats:**\r\n\r\n- **File path with line range:** `src/foo.ts:42-61`\r\n- **File path with function/class name:** `src/foo.ts — function bar()`\r\n- **File path with symbol:** `src/foo.ts — class MyComponent`\r\n- **File path with route/component ID:** `src/routes.ts — route id: \"dashboard\"`\r\n\r\n**Examples:**\r\n- ✅ `src/components/Button.tsx:15-23` (line range)\r\n- ✅ `src/utils/api.ts — function fetchUser()` (symbol name)\r\n- ✅ `src/routes.ts:42 — route id: \"settings\"` (route identifier)\r\n- ✅ `src/App.tsx — component App` (component name)\r\n- ❌ `src/components/Button.tsx` (missing line/symbol)\r\n- ❌ `the Button component` (no file path)\r\n\r\n## When Citations Are Required\r\n\r\nCitations are **mandatory** in these contexts:\r\n\r\n1. **Implementation summaries/worklogs** — When describing what was implemented or where changes were made\r\n2. **QA reports** — When reviewing code and referencing where functionality exists\r\n3. **PM guidance** — When answering \"where is X implemented?\" or similar questions\r\n\r\n## Exceptions: Unreliable Line Numbers\r\n\r\nIf line numbers are unreliable or unstable (e.g., generated code, minified bundles, auto-generated files), cite the **nearest stable anchor** instead:\r\n\r\n- **Symbol name** (exported function, class, constant)\r\n- **Route ID** or **component name**\r\n- **Export identifier**\r\n- **File path** (always required, even when line numbers aren't)\r\n\r\n**Examples of stable anchors:**\r\n- `src/generated/api.ts — export function createUser()` (generated file, use symbol)\r\n- `dist/bundle.js — function handleClick()` (minified, use symbol)\r\n- `src/routes.ts — route id: \"dashboard\"` (route identifier)\r\n\r\n**Always include the file path** even when using stable anchors instead of line numbers.\r\n\r\n## Scope\r\n\r\n- Applies to **all agents** (implementation, QA, PM) when referencing code locations\r\n- Citations must be **human-verifiable** — a reviewer should be able to open the file and find the referenced location\r\n- When in doubt, provide **more specific citations** (line numbers + symbol names) rather than less\r\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "code-location-citations",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "Code Location Citations",
        "description": "Require agents to cite concrete code locations that reviewers can verify quickly",
        "agentTypes": [
          "all"
        ]
      }
    },
    {
      "path": "heading-parsing-pitfalls.mdc",
      "name": "heading parsing pitfalls",
      "description": "Guide for agents to produce headings that HAL can parse and render correctly",
      "alwaysApply": true,
      "content": "# Heading parsing pitfalls (and how to avoid them)\r\n\r\nWhen creating tickets or writing documentation, agents must produce headings that HAL can parse and render correctly. This guide covers common pitfalls and how to avoid them.\r\n\r\n## Pitfall 1: Inconsistent heading levels\r\n\r\n**Problem:** Using `#` (H1) or `###` (H3) when `##` (H2) is required, or skipping heading levels (e.g., going from `##` to `####`).\r\n\r\n**Why this fails:** HAL's parsing logic expects specific heading levels. Required ticket sections must use `##` (H2) to be recognized correctly.\r\n\r\n**❌ Bad examples:**\r\n```markdown\r\n# Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n### Acceptance criteria\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n#### Acceptance criteria\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**Fix:** Always use `##` (H2) for required ticket sections. Maintain consistent heading hierarchy throughout the document.\r\n\r\n## Pitfall 2: Ambiguous \"pseudo-headings\" instead of real markdown headings\r\n\r\n**Problem:** Using bold text (`**Section Name:**`) or text with colons (`Section Name:`) when a real markdown heading is intended.\r\n\r\n**Why this fails:** HAL's parsing logic looks for markdown heading syntax (`## Section Name`), not bold text or colons. Pseudo-headings won't be recognized as section boundaries.\r\n\r\n**❌ Bad examples:**\r\n```markdown\r\n**Goal (one sentence):**\r\n\r\nAdd a feature.\r\n\r\n**Acceptance criteria (UI-only):**\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n```markdown\r\nGoal (one sentence):\r\n\r\nAdd a feature.\r\n\r\nAcceptance criteria (UI-only):\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**Fix:** Use proper markdown heading syntax (`## Section Name`) instead of bold text or plain text with colons.\r\n\r\n## Pitfall 3: Required ticket headings don't match canonical text exactly\r\n\r\n**Problem:** Using variations like \"Goal\" instead of \"Goal (one sentence)\", or \"Acceptance criteria\" instead of \"Acceptance criteria (UI-only)\".\r\n\r\n**Why this fails:** HAL's parsing logic uses case-sensitive, exact text matching. Headings must match the canonical format exactly to be recognized.\r\n\r\n**❌ Bad examples:**\r\n```markdown\r\n## Goal\r\n\r\nAdd a feature.\r\n\r\n## Human-verifiable deliverable\r\n\r\nUser sees a button.\r\n\r\n## Acceptance criteria\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Human-verifiable deliverable (UI only)\r\n\r\nUser sees a button.\r\n\r\n## Acceptance Criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Human-verifiable deliverable (UI-only)\r\n\r\nUser sees a button.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n```\r\n\r\n**Fix:** Use the exact canonical text for required ticket sections:\r\n- `## Goal (one sentence)`\r\n- `## Human-verifiable deliverable (UI-only)`\r\n- `## Acceptance criteria (UI-only)`\r\n- `## Constraints`\r\n- `## Non-goals`\r\n\r\n## Pitfall 4: Duplicating the same top-level heading multiple times\r\n\r\n**Problem:** Including multiple `# Ticket` blocks or repeating the same top-level section heading.\r\n\r\n**Why this fails:** HAL's parsing logic expects a single, well-structured document. Duplicate headings can cause parsing confusion and make sections ambiguous.\r\n\r\n**❌ Bad example:**\r\n```markdown\r\n# Ticket\r\n\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n# Ticket\r\n\r\n## Goal (one sentence)\r\n\r\nAdd another feature.\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a feature.\r\n\r\n## Human-verifiable deliverable (UI-only)\r\n\r\nUser sees a button.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Item 1\r\n- [ ] Item 2\r\n```\r\n\r\n**Fix:** Use each heading only once. If you need to group related content, use subheadings (`###`) or organize content within a single section.\r\n\r\n## Pitfall 5: Using plain bullets instead of checkboxes in Acceptance criteria\r\n\r\n**Problem:** Using `- Item` or `* Item` instead of `- [ ] Item` for Acceptance criteria items.\r\n\r\n**Why this fails:** HAL's Ready-to-start checklist requires Acceptance criteria to use checkbox format (`- [ ]`) so items can be tracked and verified. Plain bullets won't pass validation.\r\n\r\n**❌ Bad examples:**\r\n```markdown\r\n## Acceptance criteria (UI-only)\r\n\r\n- User sees a button\r\n- Button is clickable\r\n- Clicking shows a message\r\n```\r\n\r\n```markdown\r\n## Acceptance criteria (UI-only)\r\n\r\n* User sees a button\r\n* Button is clickable\r\n* Clicking shows a message\r\n```\r\n\r\n**✅ Good example:**\r\n```markdown\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] User sees a button labeled \"Save\" in the header\r\n- [ ] Button is clickable and responds to clicks\r\n- [ ] Clicking the button shows a success message in the UI\r\n```\r\n\r\n**Fix:** Always use checkbox format (`- [ ]`) for Acceptance criteria items. Each item should be UI-verifiable (a human can confirm by looking at the UI or running a manual test).\r\n\r\n## Copy/paste examples\r\n\r\n### Good: Minimal ticket skeleton that passes Definition of Ready\r\n\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a dark mode toggle button to the settings page that persists the user's preference.\r\n\r\n## Human-verifiable deliverable (UI-only)\r\n\r\nA non-technical user opens the app, navigates to Settings, sees a \"Dark mode\" toggle switch, clicks it, and observes the entire app UI changes from light to dark theme. The preference persists after page refresh.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Settings page displays a \"Dark mode\" toggle switch that is clearly visible and clickable\r\n- [ ] Clicking the toggle immediately changes the app theme from light to dark (or vice versa) with a smooth transition\r\n- [ ] The selected theme preference persists after page refresh (the toggle state matches the current theme on reload)\r\n\r\n## Constraints\r\n\r\n- Keep this task as small as possible while still producing a **human-verifiable** UI change.\r\n- Verification must require **no external tools** (no terminal, no devtools, no console).\r\n\r\n## Non-goals\r\n\r\n- Theme customization beyond light/dark (no color pickers or advanced theming)\r\n- Per-component theme overrides (global theme only)\r\n\r\n## Scope Lock / Out-of-Scope\r\n\r\n### Product Flows Changed\r\n\r\n- [x] **Instructions retrieval** — Updated theme-related instructions to include dark mode preferences\r\n\r\n### Product Flows Not Implemented (Missing Infrastructure)\r\n\r\nNone — All required infrastructure is in place.\r\n\r\n### Escalation Note to PM/QA\r\n\r\nN/A — No missing infrastructure or blockers.\r\n```\r\n\r\n**Why this is good:**\r\n- All headings use `##` (H2) consistently\r\n- Headings match canonical text exactly\r\n- Acceptance criteria use checkbox format (`- [ ]`)\r\n- No placeholders or pseudo-headings\r\n- All sections are present and properly formatted\r\n\r\n### Bad: Common failure mode and corrected version\r\n\r\n**❌ Bad example (multiple pitfalls):**\r\n```markdown\r\n# Ticket\r\n\r\n**Goal:** Add dark mode toggle\r\n\r\n### Human-verifiable deliverable\r\n\r\nUser sees toggle in settings.\r\n\r\n## Acceptance criteria\r\n\r\n- User sees toggle\r\n- Toggle works\r\n- Preference saves\r\n\r\n## Constraints\r\n\r\n- Use existing theme system\r\n\r\n## Non-goals\r\n\r\n- Advanced theming\r\n```\r\n\r\n**Problems:**\r\n1. Uses `# Ticket` (H1) instead of starting with `## Goal`\r\n2. Uses bold pseudo-heading `**Goal:**` instead of `## Goal (one sentence)`\r\n3. Uses `###` (H3) for \"Human-verifiable deliverable\" instead of `##`\r\n4. Missing \"(one sentence)\" and \"(UI-only)\" suffixes in headings\r\n5. Uses plain bullets (`-`) instead of checkboxes (`- [ ]`) in Acceptance criteria\r\n6. Acceptance criteria items are not UI-verifiable (too vague)\r\n\r\n**✅ Corrected version:**\r\n```markdown\r\n## Goal (one sentence)\r\n\r\nAdd a dark mode toggle button to the settings page that persists the user's preference.\r\n\r\n## Human-verifiable deliverable (UI-only)\r\n\r\nA non-technical user opens the app, navigates to Settings, sees a \"Dark mode\" toggle switch, clicks it, and observes the entire app UI changes from light to dark theme. The preference persists after page refresh.\r\n\r\n## Acceptance criteria (UI-only)\r\n\r\n- [ ] Settings page displays a \"Dark mode\" toggle switch that is clearly visible and clickable\r\n- [ ] Clicking the toggle immediately changes the app theme from light to dark (or vice versa) with a smooth transition\r\n- [ ] The selected theme preference persists after page refresh (the toggle state matches the current theme on reload)\r\n\r\n## Constraints\r\n\r\n- Use existing theme system (no new CSS framework)\r\n- Theme preference must be stored in localStorage\r\n\r\n## Non-goals\r\n\r\n- Theme customization beyond light/dark (no color pickers or advanced theming)\r\n- Per-component theme overrides (global theme only)\r\n```\r\n\r\n**Why this is correct:**\r\n- All headings use `##` (H2) consistently\r\n- Headings match canonical text exactly: \"Goal (one sentence)\", \"Human-verifiable deliverable (UI-only)\", \"Acceptance criteria (UI-only)\"\r\n- Acceptance criteria use checkbox format (`- [ ]`)\r\n- All items are UI-verifiable with specific, testable descriptions\r\n- No pseudo-headings or placeholders\r\n\r\n## Summary\r\n\r\nTo produce headings that HAL can parse correctly:\r\n\r\n1. **Use `##` (H2) consistently** for required ticket sections\r\n2. **Use proper markdown heading syntax** (`## Section Name`), not bold text or colons\r\n3. **Match canonical text exactly** (case-sensitive): \"Goal (one sentence)\", \"Human-verifiable deliverable (UI-only)\", \"Acceptance criteria (UI-only)\"\r\n4. **Avoid duplicate top-level headings** — use each heading only once\r\n5. **Use checkbox format** (`- [ ]`) for Acceptance criteria items, not plain bullets\r\n\r\nFollowing these guidelines ensures your tickets will pass HAL's Definition of Ready validation and be correctly parsed and rendered in the UI.\r\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "heading-parsing-pitfalls",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "key-decisions-summary.mdc",
      "name": "key decisions summary",
      "description": "Require agents to include a \"Key decisions\" summary in completion write-ups so reviewers can understand tradeoffs without re-reading entire worklogs",
      "alwaysApply": true,
      "content": "# Key Decisions Summary Requirement\r\n\r\n**MANDATORY:** All agent completion write-ups must include a short, explicit **\"Key decisions\"** summary (2–6 bullets) so reviewers can quickly understand tradeoffs and design choices without re-reading the entire worklog or diff.\r\n\r\n## When This Requirement Applies\r\n\r\nThis requirement applies to **all agents** when completing work:\r\n\r\n- **Implementation agents** — Must include \"Key decisions\" in both the **PM Review artifact** and the **final chat completion summary**\r\n- **QA agents** — Must verify that the \"Key decisions\" section exists and is complete during review\r\n- **Project Manager agents** — Must check for \"Key decisions\" section when reviewing implementation artifacts\r\n\r\n## Required Content: Key Decisions Section\r\n\r\n**MANDATORY:** Implementation agents **must** include a \"Key decisions\" section in:\r\n\r\n1. **PM Review artifact** (stored in Supabase with `artifactType: \"pm-review\"`)\r\n2. **Final chat completion summary** (the \"done\" message sent to the user)\r\n\r\n### Format\r\n\r\nThe \"Key decisions\" section should be a bulleted list (2–6 bullets) that explains:\r\n\r\n- **Why approach A was chosen over approach B** (e.g., \"Used Supabase API endpoint instead of direct database access for better error handling and validation\")\r\n- **Any tradeoffs or risks** (e.g., \"Chose synchronous validation over async to simplify error handling, but this may block UI for large datasets\")\r\n- **Design choices that affect maintainability** (e.g., \"Stored instructions in Supabase rather than file system to enable runtime updates without deployments\")\r\n- **Performance or scalability considerations** (e.g., \"Implemented client-side caching to reduce API calls, with 5-minute TTL to balance freshness and performance\")\r\n- **Integration decisions** (e.g., \"Updated existing instruction update endpoint rather than creating new one to maintain API consistency\")\r\n\r\n### Example: Good Key Decisions Section\r\n\r\n```markdown\r\n## Key Decisions\r\n\r\n- **Stored instructions in Supabase instead of file system** — Enables runtime updates via HAL UI without requiring deployments or code changes. Tradeoff: Requires Supabase connection, but this is already a dependency for the project.\r\n\r\n- **Updated existing `/api/instructions/update` endpoint** — Rather than creating a new endpoint, extended the existing one to maintain API consistency. This keeps the instruction update workflow unified.\r\n\r\n- **Added \"Key decisions\" requirement to all agent types** — Not just implementation agents, but also QA and PM agents need to check for this section. This ensures comprehensive review coverage.\r\n\r\n- **Included example in instruction file** — Provides concrete guidance on what constitutes a good \"Key decisions\" bullet, helping agents understand the expected level of detail and tradeoff explanation.\r\n\r\n- **Required in both PM Review artifact and chat summary** — Ensures visibility in both the structured artifact (for audit trail) and the conversational summary (for immediate review).\r\n```\r\n\r\n### Example: Poor Key Decisions Section (Too Vague)\r\n\r\n```markdown\r\n## Key Decisions\r\n\r\n- Used Supabase for storage\r\n- Updated the API\r\n- Added requirements\r\n```\r\n\r\n**Why this is poor:** Doesn't explain tradeoffs, alternatives considered, or reasoning. Reviewers can't understand the \"why\" without reading the entire worklog.\r\n\r\n## Implementation Agent Requirements\r\n\r\n**MANDATORY:** When completing a ticket, implementation agents **must**:\r\n\r\n1. **Include \"Key decisions\" in PM Review artifact:**\r\n   - Store the PM Review artifact via HAL API: `POST /api/artifacts/insert-implementation`\r\n   - Artifact type: `pm-review`\r\n   - Title format: `PM Review for ticket <ticket-id>`\r\n   - The artifact body must include a \"Key decisions\" section with 2–6 bullets\r\n\r\n2. **Include \"Key decisions\" in final chat completion summary:**\r\n   - When sending the completion message (the \"done\" summary), include a \"Key decisions\" section\r\n   - This can be a brief summary (2–4 bullets) that highlights the most important decisions\r\n   - The full detailed version should be in the PM Review artifact\r\n\r\n### PM Review Artifact Template\r\n\r\n```markdown\r\n# PM Review for ticket <ticket-id>\r\n\r\n[Other PM Review content...]\r\n\r\n## Key Decisions\r\n\r\n- [Bullet 1: Why approach A over B, tradeoffs, risks]\r\n- [Bullet 2: Design choice affecting maintainability]\r\n- [Bullet 3: Performance/scalability consideration]\r\n- [Bullet 4: Integration decision]\r\n- [Bullet 5-6: Additional important decisions]\r\n\r\n[Other PM Review content...]\r\n```\r\n\r\n### Final Chat Summary Template\r\n\r\n```markdown\r\n## Summary\r\n\r\n[Brief summary of what was implemented...]\r\n\r\n## Key Decisions\r\n\r\n- [Most important decision 1]\r\n- [Most important decision 2]\r\n- [Most important decision 3]\r\n\r\nTicket <ticket-id> implementation completed and moved to QA.\r\n```\r\n\r\n## QA Agent Requirements\r\n\r\n**MANDATORY:** When QA agents review a ticket, they **must**:\r\n\r\n1. **Verify \"Key decisions\" section exists** — Check both:\r\n   - PM Review artifact (via HAL API: `POST /api/artifacts/get`)\r\n   - Final chat completion summary (if available in conversation history)\r\n\r\n2. **Verify \"Key decisions\" content quality** — The section should:\r\n   - Contain 2–6 bullets (not too few, not too many)\r\n   - Explain tradeoffs or alternatives considered\r\n   - Provide reasoning, not just descriptions\r\n   - Be specific enough that reviewers understand the \"why\" without reading the entire worklog\r\n\r\n3. **Include \"Key decisions\" review in QA report** — QA reports should include a section confirming:\r\n   - \"Key decisions\" section exists in PM Review artifact: [Yes / No]\r\n   - \"Key decisions\" section exists in completion summary: [Yes / No / N/A]\r\n   - Content quality: [Pass / Fail / Needs improvement]\r\n   - If missing or incomplete, QA **MUST FAIL** the ticket\r\n\r\n### QA Report Template Addition\r\n\r\nQA reports should include:\r\n\r\n```markdown\r\n## Key Decisions Review\r\n\r\n**Key decisions section in PM Review artifact:** [Yes / No]\r\n\r\n**Key decisions section in completion summary:** [Yes / No / N/A]\r\n\r\n**Content quality:**\r\n- [ ] Contains 2–6 bullets: [Yes / No]\r\n- [ ] Explains tradeoffs or alternatives: [Yes / No]\r\n- [ ] Provides reasoning (not just descriptions): [Yes / No]\r\n- [ ] Specific enough to understand \"why\" without reading full worklog: [Yes / No]\r\n\r\n**Overall assessment:** [Pass / Fail / Needs improvement]\r\n\r\n**If missing or incomplete:** QA **MUST FAIL** the ticket and request the implementation agent to add the \"Key decisions\" section.\r\n```\r\n\r\n## Project Manager Agent Requirements\r\n\r\n**MANDATORY:** When Project Manager agents review implementation artifacts, they **must**:\r\n\r\n1. **Check for \"Key decisions\" section** — Verify it exists in the PM Review artifact\r\n\r\n2. **Verify completeness** — Ensure the section:\r\n   - Contains 2–6 bullets\r\n   - Explains tradeoffs and reasoning\r\n   - Helps reviewers understand design choices quickly\r\n\r\n3. **Flag missing sections** — If \"Key decisions\" is missing or incomplete, PM agents should:\r\n   - Note this in their review\r\n   - Request the implementation agent to add it\r\n   - Consider this a blocker for ticket completion\r\n\r\n## Integration with Existing Workflows\r\n\r\n### PM Review Artifact\r\n\r\nThe \"Key decisions\" section must be included in the **PM Review artifact** stored in Supabase:\r\n- **Artifact type:** `pm-review`\r\n- **Title format:** `PM Review for ticket <ticket-id>`\r\n- **Storage:** Via HAL API endpoint `/api/artifacts/insert-implementation` with `artifactType: \"pm-review\"`\r\n\r\n### Final Chat Completion Summary\r\n\r\nThe \"Key decisions\" section must also be included in the **final chat completion summary** (the \"done\" message):\r\n- This is the message sent when the implementation agent completes work\r\n- Can be a brief version (2–4 bullets) highlighting the most important decisions\r\n- The full detailed version should be in the PM Review artifact\r\n\r\n### QA Audit Report\r\n\r\nQA agents must verify \"Key decisions\" documentation as part of their standard QA workflow.\r\n\r\n## Scope\r\n\r\n- Applies to **all agents** (implementation, QA, PM) when completing or reviewing work\r\n- The \"Key decisions\" section must be **human-verifiable** — a reviewer can open the PM Review artifact and immediately see the key decisions and tradeoffs\r\n- When in doubt, **include more detail** — it's better to over-explain tradeoffs than to leave reviewers guessing why certain approaches were chosen\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "key-decisions-summary",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "Key Decisions Summary Requirement",
        "description": "Require agents to include a \"Key decisions\" summary in completion write-ups so reviewers can understand tradeoffs without re-reading entire worklogs",
        "agentTypes": [
          "all"
        ]
      }
    },
    {
      "path": "qa-audit-report.mdc",
      "name": "qa audit report",
      "description": "QA agents must store QA reports in Supabase via HAL API",
      "alwaysApply": true,
      "content": "# QA Audit Report (QA Agents)\r\n\r\nWhen you **QA a ticket** (verify, check a ticket that is allegedly complete), store a QA report via HAL API. See `docs/process/hal-tool-call-contract.mdc` for endpoints.\r\n\r\n## Branch to use\r\n\r\n- **If ticket states \"merged to main for QA access\":** Verify from `main`. Do not use feature branch. Record in report that verification was on `main`. **No merge needed** (already on main).\r\n- **Otherwise:** Use feature branch from ticket. **MANDATORY:** If QA passes, you **MUST** merge the feature branch to `main` and delete the branch before completing QA. If QA fails, do not merge.\r\n\r\n## 8 required implementation artifacts (must be present before QA)\r\n\r\n1. plan, 2. worklog, 3. changed-files, 4. decisions, 5. verification, 6. pm-review, 7. git-diff, 8. instructions-used\r\n\r\n**Changed Files:** Must be NON-EMPTY. When files changed: list paths with brief descriptions. When no files changed: state \"No files changed.\" with reason. Blank/empty = PROCESS FAILURE.\r\n\r\n**How to check:** `POST ${baseUrl}/api/artifacts/get` with `{ ticketId }`. Filter `agent_type === \"implementation\"`. Match titles `Plan for ticket X`, etc.\r\n\r\n**Auto-fail:** API fails, any artifact missing, or Changed Files blank → QA FAIL immediately. Store QA report, move to `col-todo`, final message: `QA RESULT: FAIL — <ticket-id>`.\r\n\r\n## QA report structure\r\n\r\n1. Ticket & deliverable\r\n2. Missing artifacts (if any) — list them, then fail\r\n3. Audit artifacts present (if all present)\r\n4. Code review — PASS/FAIL with evidence\r\n5. Build verification — **MANDATORY:** `npm run build:hal`; TypeScript errors = FAIL\r\n6. Coverage — **MANDATORY:** Whole-repo test coverage with 4-metric table and command used; see \"Coverage section\" below\r\n7. Code Quality — **MANDATORY:** Whole-repo code quality metric; see \"Code Quality section\" below\r\n8. UI verification — automated and/or manual steps\r\n9. AC Confirmation Checklist — enumerate each AC, Met/Not met with evidence; see `ac-confirmation-checklist.mdc`\r\n10. Verdict — PASS or FAIL\r\n\r\n## Coverage section\r\n\r\n**MANDATORY:** Every QA report **MUST** include a **Coverage** section with:\r\n\r\n1. **A 4-metric table** showing **whole-repo** coverage percentages (not just the ticket’s code):\r\n   - Lines\r\n   - Functions\r\n   - Branches\r\n   - Statements\r\n\r\n2. **The command used** to generate the coverage numbers\r\n\r\n**How to generate coverage:**\r\n\r\nRun the **full** test suite with coverage (whole repo):\r\n\r\n```bash\r\nnpm run test:coverage\r\n```\r\n\r\nThis runs vitest with coverage over the entire codebase and outputs a text summary. Extract the overall coverage percentages from the output and include them in a table in the QA report. Do not run only tests for changed files; use the full suite.\r\n\r\n**Coverage section format:**\r\n\r\n```markdown\r\n## Coverage\r\n\r\n| Metric | Coverage |\r\n|--------|----------|\r\n| Lines | XX% |\r\n| Functions | XX% |\r\n| Branches | XX% |\r\n| Statements | XX% |\r\n\r\n**Command used:** `npm run test:coverage`\r\n```\r\n\r\n**Note:** Coverage numbers must reflect the current commit under test (not hardcoded). Run the command on the branch/commit being verified.\r\n\r\n## Code Quality section\r\n\r\n**MANDATORY:** Every QA report **MUST** include a **Code Quality** section with a single whole-repo percentage and concrete guidance.\r\n\r\n**How to generate maintainability:**\r\n\r\nRun the repo’s maintainability report (uses a maintainability library over the whole codebase):\r\n\r\n```bash\r\nnpm run report:simplicity\r\n```\r\n\r\nThe script prints a single line: `Simplicity: XX%`. **IMPORTANT:** Even though the script output says \"Simplicity\", you **MUST** use the label **\"Code Quality\"** (not \"Simplicity\" or \"Maintainability\") in your QA report. The words \"Simplicity\" and \"Maintainability\" should **NOT** appear anywhere in the user-visible QA report text.\r\n\r\n**Code Quality section format:**\r\n\r\n```markdown\r\n## Code Quality\r\n\r\nCode Quality: XX%\r\n\r\nThe code quality metric measures code quality across the entire repository. Higher scores indicate:\r\n\r\n- **Readability:** Code is clear, well-structured, and easy to understand\r\n- **Testability:** Code is designed to be easily tested with good separation of concerns\r\n- **Change safety:** Code changes are less likely to introduce bugs or break existing functionality\r\n```\r\n\r\n**CRITICAL:** \r\n- Use the exact heading `## Code Quality` (not \"Simplicity\", \"Maintainability\", or any variation)\r\n- Include all three bullets (Readability, Testability, Change safety) in your report\r\n- Do not mention \"Simplicity\" or \"Maintainability\" anywhere in the QA report body\r\n\r\n**Note:** Run this on the branch/commit being verified. The number is for the whole repo, not just the ticket’s changes.\r\n\r\n## Storing QA report\r\n\r\nMake actual HTTP calls: `POST ${baseUrl}/api/artifacts/insert-qa` with `{ ticketId, title, body_md }`. Use `curl` or run_terminal_cmd. Do not just include JSON in your message.\r\n\r\n## Implementation Agent Note (for FAIL verdicts)\r\n\r\n**MANDATORY:** When a ticket fails QA (or HITL), you **MUST** create a separate, concise \"Implementation agent note\" artifact that explains why the ticket failed. This note is for implementation agents to quickly understand what needs to be fixed.\r\n\r\n**Format:**\r\n- Title: `Implementation agent note for ticket HAL-XXXX` (preferred) or `Note for implementation agent: HAL-XXXX`\r\n- Keep it short (2-4 bullet points max)\r\n- Focus on actionable items\r\n- No detailed analysis—just what's wrong and what to fix\r\n- Implementation agents are required to check for this artifact first before starting work\r\n\r\n**Example structure:**\r\n```markdown\r\n# Implementation Agent Note: HAL-XXXX\r\n\r\n## Status: FAIL\r\n\r\n## Why This Ticket Failed\r\n\r\n1. **Issue 1:** Brief description\r\n2. **Issue 2:** Brief description\r\n\r\n## Required Actions\r\n\r\n1. Action item 1\r\n2. Action item 2\r\n3. Action item 3\r\n\r\n## Code Review Notes\r\n\r\nBrief note if implementation is otherwise correct.\r\n```\r\n\r\n**Store via:** `POST ${baseUrl}/api/artifacts/insert-qa` with `{ ticketId, title: \"Implementation agent note for ticket HAL-XXXX\", body_md }`\r\n\r\n## Completion\r\n\r\n**CRITICAL: All ticket movements are AUTOMATIC - DO NOT wait for user interaction or ask for permission. Just move the tickets automatically.**\r\n\r\n- **PASS:** \r\n 1. Store QA report\r\n 2. **MANDATORY:** If feature branch exists (not already on main), merge feature branch to `main` and push to remote: `git checkout main && git merge <feature-branch> && git push origin main`\r\n    - **CRITICAL:** Both `git merge` and `git push origin main` must succeed. If either fails:\r\n      - **Retry with exponential backoff:** Attempt up to 4 times with delays (4s, 8s, 16s, 32s)\r\n      - **If all retries fail:** Surface the error in the final summary message and **DO NOT** move the ticket to `col-human-in-the-loop`\r\n      - **Keep ticket in QA:** The ticket must remain in its current column (or move to `col-todo` if appropriate) until merge/push succeeds\r\n    - **Only after confirmed successful merge + push:** Proceed to step 3\r\n 3. **MANDATORY:** Delete feature branch (local and remote): `git branch -d <feature-branch> && git push origin --delete <feature-branch>` (only if branch exists and merge/push succeeded)\r\n    - **CRITICAL:** Branch deletion only happens after confirmed successful merge + push. If merge/push failed, do not delete the branch.\r\n 4. **MANDATORY:** **AUTOMATICALLY** move ticket to `col-human-in-the-loop` **ONLY IF** merge and push both succeeded. If merge/push failed, do not move the ticket forward.\r\n    - **Move ticket automatically using HAL API:**\r\n    ```javascript\r\n    const baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\r\n    const res = await fetch(`${baseUrl}/api/tickets/move`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ ticketId: '<ticket-id>', columnId: 'col-human-in-the-loop' }),\r\n    })\r\n    const result = await res.json()\r\n    // If move fails, log it but continue - system handles failures gracefully\r\n    ```\r\n    - **DO NOT ask user for permission - just move it automatically**\r\n 5. Send summary. Final message must include: `QA RESULT: PASS — <ticket-id>`\r\n    - **If merge/push failed:** Include error details in summary and state that ticket was not moved to HITL due to merge/push failure\r\n- **FAIL:** \r\n 1. Store full QA report\r\n 2. **MANDATORY:** Store Implementation agent note\r\n 3. **AUTOMATICALLY** move ticket to `col-todo` using HAL API:\r\n    ```javascript\r\n    const baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\r\n    const res = await fetch(`${baseUrl}/api/tickets/move`, {\r\n      method: 'POST',\r\n      headers: { 'Content-Type': 'application/json' },\r\n      body: JSON.stringify({ ticketId: '<ticket-id>', columnId: 'col-todo' }),\r\n    })\r\n    const result = await res.json()\r\n    // If move fails, log it but continue - system handles failures gracefully\r\n    ```\r\n    - **DO NOT ask user for permission - just move it automatically**\r\n 4. **Do NOT merge feature branch** (leave it for implementation agent to fix)\r\n 5. Send summary. Final message must include: `QA RESULT: FAIL — <ticket-id>`\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent"
      ],
      "topicId": "qa-audit-report",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "state-management-change-documentation.mdc",
      "name": "state management change documentation",
      "description": "Require agents to document and justify any changes to application state management in review artifacts",
      "alwaysApply": true,
      "content": "# State Management Change Documentation\r\n\r\n**MANDATORY:** Any change to application state management (stores, reducers, context, persistence, query cache, etc.) must be **called out and justified** in the agent's review artifact(s), so reviewers can quickly understand behavioral risk.\r\n\r\n## What is a \"State Management Change\"?\r\n\r\nA **state management change** is any modification to how application state is stored, accessed, updated, or persisted. This includes:\r\n\r\n### Examples of State Management Changes\r\n\r\n- **Store modifications** (Zustand, Redux, Pinia, etc.)\r\n  - Adding/removing/modifying store slices or actions\r\n  - Changing store structure or initial state\r\n  - Modifying store selectors or computed values\r\n\r\n- **Context provider changes** (React Context, Vue provide/inject, etc.)\r\n  - Adding/removing/modifying context providers\r\n  - Changing context value structure\r\n  - Modifying context consumers\r\n\r\n- **Persistence/hydration changes**\r\n  - Adding/removing localStorage/sessionStorage usage\r\n  - Changing persistence keys or serialization format\r\n  - Modifying hydration logic (loading persisted state on app start)\r\n  - Changing persistence scope (what gets persisted vs. ephemeral)\r\n\r\n- **Query cache changes** (React Query, SWR, Apollo, etc.)\r\n  - Modifying cache keys or invalidation strategies\r\n  - Changing cache time-to-live (TTL) or stale-while-revalidate settings\r\n  - Adding/removing cache mutations or optimistic updates\r\n\r\n- **Cross-tab synchronization changes**\r\n  - Adding/removing `storage` event listeners\r\n  - Modifying broadcast channel or shared worker usage\r\n  - Changing how state syncs across browser tabs/windows\r\n\r\n- **State migration changes**\r\n  - Adding migration logic for existing persisted state\r\n  - Changing state schema versions\r\n  - Modifying backward compatibility handling\r\n\r\n## When This Requirement Applies\r\n\r\nThis requirement applies to **all agents** when making changes that affect state management:\r\n\r\n- **Implementation agents** — Must document state management changes in their **PM Review artifact**\r\n- **QA agents** — Must verify that state management changes are properly documented and check the impact during QA review\r\n- **Project Manager agents** — Must ensure state management changes are called out in PM reviews\r\n\r\n## Required Documentation: PM Review Checklist\r\n\r\n**MANDATORY:** When an implementation agent makes any state management change, they **must** include the following checklist in their **PM Review artifact** (stored in Supabase with `artifactType: \"pm-review\"`).\r\n\r\n### Copy/Paste Checklist Template\r\n\r\n```markdown\r\n## State Management Changes\r\n\r\n**State management changes made:** [Yes / No]\r\n\r\nIf Yes, complete the following:\r\n\r\n### What Changed\r\n- [ ] Store/Context/Cache modified: [specify which and what changed]\r\n- [ ] Persistence logic modified: [specify what changed]\r\n- [ ] Migration logic added: [specify what changed]\r\n- [ ] Other state management change: [specify what changed]\r\n\r\n### Why This Change Was Necessary\r\n[Brief explanation of why the state management change was required]\r\n\r\n### Migration Considerations\r\n- [ ] Existing persisted state affected: [Yes / No]\r\n- [ ] Backward compatibility: [Maintained / Broken / N/A]\r\n- [ ] Migration path: [Describe how existing users' state will be handled, if applicable]\r\n\r\n### User-Visible Impact\r\n- [ ] State persists across sessions: [Yes / No / Changed]\r\n- [ ] State syncs across tabs: [Yes / No / Changed]\r\n- [ ] User data loss risk: [None / Low / Medium / High]\r\n- [ ] Performance impact: [None / Low / Medium / High]\r\n- [ ] Breaking changes: [None / Describe if any]\r\n\r\n### Code Locations\r\n[Cite specific file paths and line numbers where state management changes were made, per `.cursor/rules/code-location-citations.mdc`]\r\n```\r\n\r\n## QA Review Requirements\r\n\r\n**MANDATORY:** When QA agents review a ticket that includes state management changes, they **must**:\r\n\r\n1. **Verify the PM Review artifact includes the state management checklist** — If state management changes were made but the checklist is missing or incomplete, QA **MUST FAIL** the ticket.\r\n\r\n2. **Review the documented impact** — QA should verify:\r\n   - The \"What Changed\" section accurately describes the code changes\r\n   - The \"Why This Change Was Necessary\" provides adequate justification\r\n   - Migration considerations are addressed if applicable\r\n   - User-visible impact is accurately assessed\r\n\r\n3. **Include state management review in QA report** — QA reports should include a section confirming:\r\n   - State management changes were properly documented (or \"No state management changes\" if none were made)\r\n   - The documented impact assessment appears reasonable\r\n   - Any concerns about user data loss, breaking changes, or migration issues\r\n\r\n### QA Report Template Addition\r\n\r\nQA reports should include:\r\n\r\n```markdown\r\n## State Management Review\r\n\r\n**State management changes:** [Yes / No]\r\n\r\nIf Yes:\r\n- [ ] PM Review includes complete state management checklist\r\n- [ ] Documented changes match code review findings\r\n- [ ] Migration considerations addressed: [Yes / No / N/A]\r\n- [ ] User-visible impact assessment appears reasonable: [Yes / No]\r\n- [ ] Concerns identified: [None / List any concerns]\r\n```\r\n\r\n## Integration with Existing Workflows\r\n\r\n### PM Review Artifact\r\n\r\nThe state management checklist must be included in the **PM Review artifact** stored in Supabase:\r\n- **Artifact type:** `pm-review`\r\n- **Title format:** `PM Review for ticket <ticket-id>`\r\n- **Storage:** Via HAL API endpoint `/api/artifacts/insert-pm-review` (or equivalent)\r\n\r\n### QA Audit Report\r\n\r\nQA agents must verify state management documentation as part of their standard QA workflow (see `.cursor/rules/qa-audit-report.mdc`).\r\n\r\n## Scope\r\n\r\n- Applies to **all agents** (implementation, QA, PM) when state management changes are involved\r\n- The checklist must be **human-verifiable** — a reviewer can open the PM Review artifact and immediately see whether state management changes were made and their impact\r\n- When in doubt, **document the change** — it's better to over-document than to miss a state management change that could affect user experience\r\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "state-management-change-documentation",
      "isBasic": true,
      "isSituational": false,
      "topicMetadata": {
        "title": "State Management Change Documentation",
        "description": "Require agents to document and justify any changes to application state management in review artifacts",
        "agentTypes": [
          "all"
        ]
      }
    }
  ],
  "situational": []
}