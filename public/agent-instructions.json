{
  "index": {
    "basic": [
      "conversation-protocol",
      "agent-supabase-api-paradigm",
      "agent-runs-terminal-commands",
      "no-edits-on-main"
    ],
    "situational": {
      "implementation-agent": [
        "auditability-and-traceability",
        "done-means-pushed",
        "change-ownership-and-staging-discipline",
        "typescript-build-verification",
        "scope-discipline"
      ],
      "qa-agent": [
        "qa-audit-report",
        "typescript-build-verification"
      ],
      "project-manager": [
        "ticket-writing-sync-tickets",
        "task-sizing-and-in-app-debugging"
      ],
      "all": [
        "bugfix-tracking",
        "delete-branch-after-merge",
        "build-config-hygiene",
        "submodule-sync"
      ]
    },
    "topics": {
      "auditability-and-traceability": {
        "title": "Auditability and Traceability",
        "description": "Requirements for fully auditable agent work, including mandatory artifact checking",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "artifacts",
          "audit",
          "traceability",
          "qa reports",
          "human in the loop"
        ]
      },
      "done-means-pushed": {
        "title": "Done Means Committed + Pushed",
        "description": "Completion checklist and workflow requirements for implementation agents",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "commit",
          "push",
          "ready",
          "verification",
          "artifacts"
        ]
      },
      "qa-audit-report": {
        "title": "QA Audit Report",
        "description": "QA workflow, artifact verification, and report requirements",
        "agentTypes": [
          "qa-agent"
        ],
        "keywords": [
          "qa",
          "verification",
          "artifacts",
          "code review",
          "build"
        ]
      },
      "change-ownership-and-staging-discipline": {
        "title": "Change Ownership + Staging Discipline",
        "description": "Branching, staging, and commit discipline requirements",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "branch",
          "staging",
          "commit",
          "feature branch"
        ]
      },
      "typescript-build-verification": {
        "title": "TypeScript Build Verification",
        "description": "Mandatory TypeScript compilation checks before marking ready",
        "agentTypes": [
          "implementation-agent",
          "qa-agent"
        ],
        "keywords": [
          "typescript",
          "build",
          "compilation",
          "verification"
        ]
      },
      "scope-discipline": {
        "title": "Scope Discipline",
        "description": "Rules for staying within ticket scope and documenting deviations",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "scope",
          "unrequested changes",
          "decisions"
        ]
      },
      "ticket-writing-sync-tickets": {
        "title": "Ticket Source of Truth",
        "description": "Supabase-backed ticket management and sync requirements",
        "agentTypes": [
          "project-manager"
        ],
        "keywords": [
          "tickets",
          "supabase",
          "kanban",
          "sync"
        ]
      },
      "task-sizing-and-in-app-debugging": {
        "title": "Task Sizing + Verifiable Output",
        "description": "Task sizing requirements and in-app debugging needs",
        "agentTypes": [
          "project-manager"
        ],
        "keywords": [
          "task sizing",
          "debugging",
          "verification"
        ]
      },
      "bugfix-tracking": {
        "title": "Bugfix Tracking",
        "description": "Creating bugfix tickets when QA fails",
        "agentTypes": [
          "qa-agent"
        ],
        "keywords": [
          "bugfix",
          "qa failure",
          "tickets"
        ]
      },
      "delete-branch-after-merge": {
        "title": "Delete Branch After Merge",
        "description": "Branch cleanup after merging to main",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "branch",
          "merge",
          "cleanup"
        ]
      },
      "build-config-hygiene": {
        "title": "Build/Config Hygiene",
        "description": "Preventing mystery generated files and config issues",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "build",
          "config",
          "vite",
          "typescript"
        ]
      },
      "submodule-sync": {
        "title": "Submodule Sync Protocol",
        "description": "Global rules location and submodule handling",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "submodule",
          "rules",
          "monorepo"
        ]
      }
    }
  },
  "instructions": [
    {
      "path": "agent-runs-terminal-commands.mdc",
      "name": "agent runs terminal commands",
      "description": "Agents run terminal commands themselves; do not ask the user to run them",
      "alwaysApply": true,
      "content": "# Agent Runs Terminal Commands\n\n- **Tickets (Supabase-backed Kanban):** All ticket changes (create, update body, move column) must be made via **HAL API endpoints**, which update Supabase directly. Do not create or edit ticket files under `docs/tickets/` directly. Use `POST /api/tickets/update` for body updates and `POST /api/tickets/move` for column moves. The Kanban UI reflects changes within ~10 seconds (polling interval).\n- When a task requires running a terminal command (e.g. `npm run dev`, `npm run build`, `npm run sync-tickets`, restarting a dev server, `git status`, `git add`, `git commit`, `git push`), the **agent must run the command itself** when it has the ability to do so.\n- **Do not ask the user** to run terminal commands that the agent can run (e.g. \"Please run `npm run dev`\", \"Restart the HAL dev server\", \"Run `npm run sync-tickets` from the repo root\").\n- Only suggest the user run a command when the action truly requires user context (e.g. picking a folder, approving a destructive operation, or when the agent environment cannot execute the command).\n- When instructing verification or follow-up, prefer steps the agent can perform (run the command, then report the result) over steps that delegate to the user.\n\n## Keep the dev server current\n\n- **After changes that affect the HAL app or hal-agents**, run whatever is needed so the user can test immediately:\n  - Run `npm run build --prefix projects/hal-agents` if hal-agents or its consumers changed.\n  - If the dev server is not running or must be restarted: kill anything on ports 5173 and 5174 (e.g. `npx --yes kill-port 5173 5174`), then run `npm run dev` (in the background so the server stays up).\n- **Goal:** The dev server should always be current after an agent session—no \"please run npm run dev\" handoff. Start or restart dev when it makes sense so the user can open the app and test right away.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "agent-runs-terminal-commands",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "agent-supabase-api-paradigm.mdc",
      "name": "agent supabase api paradigm",
      "description": "All agents send tool calls to HAL via direct API",
      "alwaysApply": true,
      "content": "# Agent Tool Call Contract (All Agent Types)\n\n**MANDATORY:** All agent types (PM, Implementation, QA, Local Cursor, cloud agents) must persist tool calls so HAL can execute them (artifacts, ticket moves, etc.). HAL uses server-side Supabase credentials; agents never need credentials.\n\n## How to Send Tool Calls\n\n### Preferred: Call HAL API directly (cloud and local)\n\nWhen the repo contains **`.hal/api-base-url`**, read that file for the HAL base URL (e.g. `https://portfolio-2026-hal.vercel.app`). For **each** tool call, perform an HTTP request to the corresponding endpoint. No credentials are required in the request; the HAL server uses its own Supabase env.\n\n**Endpoint mapping:**\n\n| Tool | Method | Path | Request body |\n|------|--------|------|--------------|\n| `insert_implementation_artifact` | POST | `/api/artifacts/insert-implementation` | `{ ticketId, artifactType, title, body_md }` |\n| `insert_qa_artifact` | POST | `/api/artifacts/insert-qa` | `{ ticketId, title, body_md }` |\n| `update_ticket_body` | POST | `/api/tickets/update` | `{ ticketId, body_md }` |\n| `move_ticket_column` | POST | `/api/tickets/move` | `{ ticketId, columnId }` |\n| `get_ticket_content` | POST | `/api/tickets/get` | `{ ticketId }` |\n\n**Example (store plan artifact):**\n```javascript\nconst baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\nconst res = await fetch(`${baseUrl}/api/artifacts/insert-implementation`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    ticketId: '0097',\n    artifactType: 'plan',\n    title: 'Plan for ticket 0097',\n    body_md: '# Plan\\n\\n...',\n  }),\n})\nconst result = await res.json()\nif (!result.success) throw new Error(result.error)\n```\n\n**Example (move ticket):**\n```javascript\nconst res = await fetch(`${baseUrl}/api/tickets/move`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ ticketId: '0097', columnId: 'col-human-in-the-loop' }),\n})\n```\n\nCall the API **immediately** when you have artifact content or a column move—do not wait for merge. This way artifacts and ticket moves appear in Supabase and on the Kanban without merging to main.\n\n**Note:** HAL runs as an API-driven app. All tool calls must be sent via direct API calls. The `.hal/api-base-url` file must be present for agents to function properly.\n\n## Available Tools\n\n### `insert_implementation_artifact`\n\nStore an implementation artifact in Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n- `artifactType` (string): One of \"plan\", \"worklog\", \"changed-files\", \"decisions\", \"verification\", \"pm-review\"\n- `title` (string): Artifact title (e.g. \"Plan for ticket 0076\")\n- `body_md` (string): Full markdown content of the artifact\n\n**Example:**\n```json\n{\n  \"tool\": \"insert_implementation_artifact\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"artifactType\": \"plan\",\n    \"title\": \"Plan for ticket 0076\",\n    \"body_md\": \"# Plan\\n\\n...\"\n  }\n}\n```\n\n### `insert_qa_artifact`\n\nStore a QA artifact in Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n- `title` (string): Artifact title (e.g. \"QA report for ticket 0076\")\n- `body_md` (string): Full markdown content of the QA report\n\n**Example:**\n```json\n{\n  \"tool\": \"insert_qa_artifact\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"title\": \"QA report for ticket 0076\",\n    \"body_md\": \"# QA Report\\n\\n...\"\n  }\n}\n```\n\n### `update_ticket_body`\n\nUpdate a ticket's body_md in Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n- `body_md` (string): Full markdown body of the ticket\n\n**Example:**\n```json\n{\n  \"tool\": \"update_ticket_body\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"body_md\": \"# Updated ticket body...\"\n  }\n}\n```\n\n### `move_ticket_column`\n\nMove a ticket to a different Kanban column.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n- `columnId` (string): Target column ID (e.g. \"col-qa\", \"col-human-in-the-loop\", \"col-todo\")\n\n**Example:**\n```json\n{\n  \"tool\": \"move_ticket_column\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"columnId\": \"col-human-in-the-loop\"\n  }\n}\n```\n\n### `get_ticket_content`\n\nFetch a ticket's content from Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n\n**Example:**\n```json\n{\n  \"tool\": \"get_ticket_content\",\n  \"params\": {\n    \"ticketId\": \"0076\"\n  }\n}\n```\n\n### `get_artifacts`\n\nFetch all artifacts for a ticket from Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n\n**Returns:**\n- `success` (boolean): Whether the operation succeeded\n- `artifacts` (array): Array of artifact objects with fields: `artifact_id`, `ticket_pk`, `agent_type`, `title`, `body_md`, `created_at`\n\n**Example:**\n```json\n{\n  \"tool\": \"get_artifacts\",\n  \"params\": {\n    \"ticketId\": \"0076\"\n  }\n}\n```\n\n## Benefits\n\n1. **Direct API** - Artifacts and ticket moves apply immediately without merging to main; no credentials in agent environment.\n2. **No credentials needed** - HAL server uses its own Supabase credentials.\n3. **API-driven workflow** - All tool calls are executed immediately via HTTP requests to HAL's API endpoints.\n\n## Implementation Agent Requirements\n\nImplementation agents must store all required artifacts before marking ticket ready:\n\n1. Plan artifact\n2. Worklog artifact\n3. Changed Files artifact\n4. Decisions artifact\n5. Verification artifact\n6. PM Review artifact\n\nUse `insert_implementation_artifact` for each one.\n\n## QA Agent Requirements\n\nQA agents must:\n\n1. **First step (MANDATORY):** Check for required implementation artifacts using HAL API endpoint `/api/artifacts/get` with `{ ticketId: \"<ticket-id>\" }`.\n   - If `.hal/api-base-url` exists, read it and call: `POST ${baseUrl}/api/artifacts/get`\n   - **If API call fails (404, 500, network error, timeout):** QA **MUST FAIL** immediately. You cannot verify artifacts exist, so treat as missing. Do NOT proceed with code review.\n   - **If API call succeeds:** Filter artifacts to find implementation artifacts (`agent_type === \"implementation\"`) and verify all 6 required artifact types are present.\n2. **Auto-fail if artifacts are missing or unverifiable** — store QA report enumerating missing artifacts (or API failure), move ticket to To-do, do NOT proceed with code review\n3. **If all artifacts present:** Store QA report using `insert_qa_artifact` after completing code review and verification\n4. Move ticket to Human in the Loop using `move_ticket_column` (only if QA passes)\n\n**CRITICAL:** Artifact verification is the first and mandatory step. If you cannot verify artifacts exist (API failure), the ticket fails QA. Do not skip this step or proceed with code review when verification fails.\n\nSee `.cursor/rules/qa-audit-report.mdc` for full workflow.\n\n## Documentation\n\nSee `docs/process/hal-tool-call-contract.mdc` for detailed documentation.\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent"
      ],
      "topicId": "agent-supabase-api-paradigm",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "auditability-and-traceability.mdc",
      "name": "auditability and traceability",
      "description": "Auditability and traceability requirements for all agent work",
      "alwaysApply": true,
      "content": "# Auditability (Always On)\n\nFor any coding task assigned to an implementation agent, the work must be **fully auditable**.\n\n## Implementation Agent: First Step (MANDATORY - DO THIS FIRST)\n\n**CRITICAL: This is the ABSOLUTE FIRST action when picking up a ticket. Do this BEFORE reading the ticket, BEFORE creating a branch, BEFORE any file edits.**\n\n**FORBIDDEN:** Starting implementation work without first checking for existing artifacts. This step is non-negotiable.\n\n### Step-by-Step Checklist (MUST COMPLETE IN ORDER):\n\n**Step 1: Fetch all existing artifacts**\n- Read `.hal/api-base-url` file to get the HAL base URL\n- Call HAL API: `POST ${baseUrl}/api/artifacts/get` with `{ ticketId: \"<ticket-id>\" }`\n- If API call fails (404, 500, network error, timeout), note the failure but proceed with caution\n- If API call succeeds, you will receive an array of artifacts\n\n**Step 2: Check for QA reports and Human in the Loop failures (CRITICAL)**\n- Filter artifacts to find QA reports: `agent_type === \"qa\"` and title matching `QA report for ticket <ticket-id>`\n- **If a QA report exists:**\n  - **READ IT IMMEDIATELY** - Do not skip this\n  - Check the verdict: Look for \"QA RESULT: FAIL\" or \"QA RESULT: PASS\" in the report\n  - **Check for Human validation failure:** Look for \"Human validation failure\" section in the report\n  - **If verdict is FAIL:**\n    - Read the entire QA report carefully\n    - Identify all blocking issues listed\n    - Understand what fixes are required\n    - Understand why the previous implementation failed\n    - **DO NOT repeat the same mistakes**\n    - **DO NOT start coding until you understand the failure context**\n  - **If Human validation failure section exists:**\n    - Read the entire QA report carefully, including the Human validation failure section\n    - Identify all issues that caused the Human in the Loop failure\n    - Understand what fixes are required based on the failure notes\n    - Understand why the previous implementation failed human validation\n    - **DO NOT repeat the same mistakes**\n    - **DO NOT start coding until you understand the failure context**\n- **If no QA report exists:** This may be a fresh ticket (proceed to Step 3)\n\n**Step 3: Review existing implementation artifacts (if any)**\n- Look for implementation artifacts (`agent_type === \"implementation\"`)\n- Read these artifacts to understand:\n  - **Plan artifact:** What approach was previously taken\n  - **Worklog artifact:** What was actually done\n  - **Changed Files artifact:** What files were changed\n  - **Decisions artifact:** What trade-offs/assumptions were made\n  - **Verification artifact:** What issues were identified during verification\n  - **PM Review artifact:** What potential failures were identified\n\n**Step 4: Synthesize understanding**\n- If the ticket has failed QA before:\n  - Document in your Plan artifact that you are addressing previous QA failures\n  - List the specific issues you will fix\n  - Explain how your approach addresses the previous failures\n- If the ticket has failed Human in the Loop validation before:\n  - Document in your Plan artifact that you are addressing previous Human in the Loop failures\n  - List the specific issues you will fix based on the Human validation failure notes\n  - Explain how your approach addresses the previous failures\n- If the ticket has been worked before but passed QA:\n  - Understand what was done and build on it appropriately\n- If this is a fresh ticket:\n  - Proceed with normal implementation\n\n**Step 5: Only after completing Steps 1-4, proceed with:**\n- Creating/checking out the feature branch (see **change-ownership-and-staging-discipline**)\n- Reading the ticket content (if not already reviewed)\n- Creating a new Plan artifact (or updating if continuing previous work)\n\n### Why This Matters\n\n- **Tickets often fail QA multiple times** - The same ticket may have been worked by previous agents who made mistakes\n- **Tickets often fail Human in the Loop validation** - Even after passing QA, tickets can fail when users test them in the UI\n- **QA reports contain critical information** - They tell you exactly what was wrong and what needs to be fixed\n- **Human validation failure notes contain critical information** - They tell you exactly what failed in user testing and what needs to be fixed\n- **Repeating mistakes wastes time** - Understanding previous failures prevents you from making the same errors\n- **Building on previous work** - If work was partially completed, you should understand what was done before\n\n### Warning Signs You Skipped This Step\n\nIf you find yourself:\n- Starting to code without checking artifacts first\n- Creating a Plan artifact without mentioning previous QA failures or Human in the Loop failures\n- Implementing features that were already identified as problematic in a QA report\n- Making the same mistakes that caused a previous QA failure\n- Making the same mistakes that caused a previous Human in the Loop failure\n\n**STOP and go back to Step 1.**\n\n## Standard Prompt Format (Supabase source of truth)\n\n- All new stories/tasks must be **tickets** stored in **Supabase** (source of truth). **Do not create or edit ticket files** under `docs/tickets/` directly; tickets are created via the HAL app (PM agent) or a script that writes to the Supabase `tickets` table. The app uses Supabase-only mode (0065) and does not read from `docs/tickets/*.md`.\n- **Kanban is Supabase-backed (Supabase-only mode, 0065).** For any ticket change (create, update body, move column): **update the DB directly via HAL API**. The Kanban UI reflects changes within the polling interval (~10s). Use `POST /api/tickets/move` for column moves. Never update ticket files locally — the app does not read them.\n- Use the workspace template for **content structure** when creating a ticket (in-app or via script):\n  - `docs/templates/ticket.template.md`\n- The ticket in Supabase (and, after sync, in `docs/tickets/<task-id>-<short-title>.md`) is the canonical \"prompt\" (we do **not** create a `prompt.md` artifact).\n\n## Task ID Convention (Uniqueness)\n\n- Task IDs must be **sequential numbers**, zero-padded to 4 digits (e.g. `0001`, `0002`, ...).\n- Task IDs must remain **globally unique** within this workspace; they will be used as keys later.\n\n## Required Artifacts (per task)\n\n**MANDATORY:** All artifacts are stored in **Supabase's `agent_artifacts` table**, not in `docs/audit/` folders. \n\n**FORBIDDEN:** Creating, writing, or editing files in `docs/audit/` directories. Artifacts must be stored in Supabase only via tool calls.\n\nUse HAL API endpoints (tool calls) to store artifacts:\n\n- Ticket in Supabase (not `docs/tickets/*.md` — Supabase-only mode, 0065)\n  - Canonical ticket used to brief the implementation agent (includes acceptance criteria). Fetch using tool call `get_ticket_content`.\n- **Plan artifact** (agent_type: `implementation`, title: `Plan for ticket <ticket-id>`)\n  - 3–10 bullets: intended approach and file touchpoints.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"plan\"`\n- **Worklog artifact** (agent_type: `implementation`, title: `Worklog for ticket <ticket-id>`)\n  - Timestamped (rough) notes of what was done, in order.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"worklog\"`\n- **Changed Files artifact** (agent_type: `implementation`, title: `Changed Files for ticket <ticket-id>`)\n  - List of files created/modified/deleted with 1–2 line purpose each.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"changed-files\"`\n- **Decisions artifact** (agent_type: `implementation`, title: `Decisions for ticket <ticket-id>`)\n  - Any trade-offs/assumptions + why.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"decisions\"`\n- **Verification artifact** (agent_type: `implementation`, title: `Verification for ticket <ticket-id>`)\n  - QA verification steps: code review + automated checks (build, lint). No manual UI testing at QA stage — user tests in Human in the Loop after merge.\n  - **MANDATORY:** Must include TypeScript compilation check: run `npm run build:hal` (or `tsc -b`) and verify it completes with **zero TypeScript errors**. If TypeScript errors exist, the implementation is **NOT ready** and must be fixed before claiming \"ready for QA\".\n  - If verification involves visuals, include screenshot filenames.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"verification\"`\n- **PM Review artifact** (agent_type: `implementation`, title: `PM Review for ticket <ticket-id>`)\n  - Likelihood of success (0–100%), potential failures, and how to diagnose them.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"pm-review\"`\n- **Git diff artifact** (agent_type: `implementation`, title: `Git diff for ticket <ticket-id>`)\n  - Full unified git diff of all changes for this ticket.\n  - Generate using: `git diff main...HEAD` (or `git diff main` if on feature branch) to get all changes.\n  - If no changes exist or diff is empty, include a message explaining why (e.g., \"No changes detected\" or \"All changes already merged\").\n  - The diff should be in unified diff format and will be displayed with syntax highlighting in the UI.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"git-diff\"`\n- **QA Report artifact** (agent_type: `qa`, title: `QA report for ticket <ticket-id>`)\n  - Created by QA agent after code review and verification.\n  - Store via tool call: `insert_qa_artifact`\n\n## Artifact Format: Source of Truth (No \"Copy From Old Audits\")\n\n- The source of truth for artifact **format and required files** is:\n  - `.cursor/rules/*.mdc` (workspace rules)\n  - `docs/templates/ticket.template.md`\n  - `docs/process/ticket-verification-rules.md`\n- Do **not** determine artifact format by inspecting prior artifacts in Supabase.\n  - You may reference older artifacts only as **examples** after you have already checked the rules/templates.\n  - Avoid narration like \"Checking an existing artifact for format\"; instead confirm you are following the rules/templates above.\n\n## QA (Commit + Push → Human in the Loop)\n\n- An implementation agent must **commit** all work for the ticket and **push** it to the remote before claiming the ticket is \"done\" or \"ready for verification.\"\n- \"Ready for verification\" additionally requires a **clean + synced repo**:\n  - working tree is clean (no uncommitted changes, no untracked files created by the task)\n  - branch is synced with remote (not ahead/behind)\n- \"Ready for verification\" must happen on a **feature branch** (not `main`) for ticketed work.\n- If any untracked/modified files remain, the agent must either:\n  - commit them (if they belong to the ticket), or\n  - delete/ignore/revert them (if they are accidental/generated), before claiming \"ready.\"\n- The ticket must exist in **Supabase** (Supabase-only mode, 0065):\n  - Ticket must exist in Supabase. `docs/tickets/*.md` files are not used by the app.\n\n- \"Ready for verification\" instructions must be **UI-only**:\n  - Do not ask the user/PM to commit, push, or otherwise \"finish\" the task.\n  - If the agent still needs to commit/push or store artifacts, the task is **not** ready.\n\n- The completion message to the user/PM must include:\n  - the **feature branch name** (so QA can review and merge), and\n  - the exact `git status -sb` output.\n- The implementation agent **must add the branch name to the ticket** when claiming \"ready for QA\" (see ticket template: QA → Branch).\n- The implementation agent **must store all 7 required artifacts in Supabase** when marking ready for QA (see \"Required Artifacts\" above).\n- The implementation agent **must move the ticket to QA column** (`col-qa`) via HAL API (`POST /api/tickets/move` with `{ ticketId: \"<id>\", columnId: \"col-qa\" }`) when marking ready for QA. **FORBIDDEN:** Claiming \"ready\" without moving the ticket to QA column. \n  - **Storage method:** Call HAL API directly (`POST ${baseUrl}/api/artifacts/insert-implementation`) or write to `.hal-tool-call-queue.json`.\n  - **Verification:** After storing, call `/api/artifacts/get` to verify all 7 artifacts are present. If any are missing, store them again.\n  - **FORBIDDEN:** Claiming \"ready\" without verifying all artifacts are stored. QA will fail tickets with missing artifacts.\n\n- Artifacts must be **stored in Supabase**:\n  - All artifacts must be stored via tool calls before claiming \"ready.\"\n  - **Required:** Call the HAL API directly (e.g. `POST ${baseUrl}/api/artifacts/insert-implementation`) so artifacts appear immediately. The `.hal/api-base-url` file must be present. See `.cursor/rules/agent-supabase-api-paradigm.mdc`.\n  - Artifacts are linked to tickets via `ticket_pk` in the `agent_artifacts` table.\n\n## PM Review is required before \"ready\"\n\n- Before claiming \"ready for verification,\" the agent must ensure:\n  - PM Review artifact exists in Supabase (stored via `POST /api/artifacts/insert-implementation`),\n  - and it reflects the actual implementation state (no placeholders).\n\n## Commit message linkage (no commit hashes in docs)\n\n- Every commit that belongs to a ticket must include the ticket ID in the commit subject (e.g. `feat(0010): ...`, `fix(0008): ...`, `docs(0009): ...`).\n- This includes \"supporting\" commits that are still part of delivering the ticket (examples: `chore`, `docs(rules)`, submodule pointer updates, dependency updates).\n- If a commit is **not** part of the ticket, it must be:\n  - separated (not bundled into the ticket's commits), and\n  - documented in the ticket's Decisions artifact under **Unrequested changes (required)** if it was unavoidable.\n \nNote: Workspace-wide, the definition of \"done\" for **all agents** is enforced by `.cursor/rules/done-means-pushed.mdc`.\n\n## In-App Trace Requirement\n\n- Any meaningful state change performed by the app should be visible in an **in-app debug/diagnostics UI** (not the console).\n- Errors should have an in-app representation suitable for a non-technical verifier.\n\n## Scope\n\n- **All artifacts are stored in Supabase**, not in `docs/audit/` folders.\n- **FORBIDDEN:** Writing artifact files to `docs/audit/` directories. Use tool calls to store in Supabase.\n- Keep each artifact concise; prefer bullets over prose.\n\n## PM Review Artifact (after implementation completes)\n\n- Store PM Review artifact in Supabase via tool call `insert_implementation_artifact` with `artifactType: \"pm-review\"`.\n- Use format from `docs/templates/pm-review.template.md` as reference.\n- The PM review must include:\n  - **likelihood of success** (0–100%)\n  - a ranked list of **potential failures** and how to diagnose them using **in-app** diagnostics\n\n## HAL Tool Call Contract\n\nAll artifact and ticket operations are sent to HAL as **tool calls** in your messages. HAL parses and executes them automatically.\n\n**Available tools:**\n\n- **`insert_implementation_artifact`** — Store implementation artifact\n  - Params: `{ ticketId: string, artifactType: string, title: string, body_md: string }`\n\n- **`insert_qa_artifact`** — Store QA artifact\n  - Params: `{ ticketId: string, title: string, body_md: string }`\n\n- **`get_ticket_content`** — Fetch ticket content\n  - Params: `{ ticketId: string }`\n\n- **`update_ticket_body`** — Update ticket body\n  - Params: `{ ticketId: string, body_md: string }`\n\n- **`move_ticket_column`** — Move ticket to different column\n  - Params: `{ ticketId: string, columnId: string }`\n\n**How to use:** Include tool calls as JSON blocks in your messages. HAL will parse and execute them. You don't need API URLs or credentials.\n\n**Example:**\n```\nI've completed the plan. Here's my tool call:\n\n{\n  \"tool\": \"insert_implementation_artifact\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"artifactType\": \"plan\",\n    \"title\": \"Plan for ticket 0076\",\n    \"body_md\": \"# Plan\\n\\n...\"\n  }\n}\n```\n\nSee `.cursor/rules/agent-supabase-api-paradigm.mdc` for full documentation.\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "auditability-and-traceability",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Auditability and Traceability",
        "description": "Requirements for fully auditable agent work, including mandatory artifact checking",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "artifacts",
          "audit",
          "traceability",
          "qa reports",
          "human in the loop"
        ]
      }
    },
    {
      "path": "bugfix-tracking.mdc",
      "name": "bugfix tracking",
      "description": "Track QA failures and bugfix follow-ups",
      "alwaysApply": true,
      "content": "# Bugfix Tracking (QA Failures + Follow-ups)\n\n## When QA fails\n\n- If a ticket is “done” but fails QA, create a **new bugfix ticket** (next sequential ID) **in Supabase** (via the HAL app PM agent or a script that inserts into the `tickets` table). Do not write a new ticket file in `docs/tickets/`; run `npm run sync-tickets` after creating in Supabase so the change propagates to docs.\n- The bugfix ticket must include:\n  - **Fixes**: the original ticket ID (e.g. `Fixes: 0007`)\n  - **QA failure summary**: what failed, in human terms\n  - **Category**: pick one: `DnD`, `State`, `CSS`, `Build`, `Process`, `Other`\n\n## Why\n\n- We want a clear, auditable trail of problem points (what keeps breaking and why).\n",
      "agentTypes": [
        "all",
        "project-manager"
      ],
      "topicId": "bugfix-tracking",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Bugfix Tracking",
        "description": "Creating bugfix tickets when QA fails",
        "agentTypes": [
          "qa-agent"
        ],
        "keywords": [
          "bugfix",
          "qa failure",
          "tickets"
        ]
      }
    },
    {
      "path": "build-config-hygiene.mdc",
      "name": "build config hygiene",
      "description": "Prevent generated config files (vite.config.js) from appearing",
      "alwaysApply": true,
      "content": "# Build/Config Hygiene (Prevent “mystery” generated files)\n\n## Vite config source of truth\n\n- This workspace should have **one** Vite config: `vite.config.ts`.\n- Do not create or keep `vite.config.js` alongside it.\n\n## TypeScript build must not emit configs\n\n- `tsconfig.node.json` must include `\"noEmit\": true`.\n  - Reason: `tsc -b` should typecheck; it must not compile `vite.config.ts` into `vite.config.js`.\n\n## Ready-for-verification cleanliness\n\n- Before claiming “ready for verification,” ensure the working tree is clean and there is **no untracked `vite.config.js`**.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "build-config-hygiene",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Build/Config Hygiene",
        "description": "Preventing mystery generated files and config issues",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "build",
          "config",
          "vite",
          "typescript"
        ]
      }
    },
    {
      "path": "change-ownership-and-staging-discipline.mdc",
      "name": "change ownership and staging discipline",
      "description": "Prevent committing unrelated changes; staging and ownership discipline",
      "alwaysApply": true,
      "content": "# Change Ownership + Staging Discipline\n\n## GATE: No edits on main (see also no-edits-on-main.mdc)\n\n- **Before using StrReplace, Write, or EditNotebook** for a ticket: run `git status -sb`. If the current branch is **`main`**, you **must not** make any file edits. Create or checkout the feature branch first, then edit.\n- **FORBIDDEN:** Implementing ticket work on `main` or any branch other than the ticket's feature branch. This is non-negotiable.\n\n## FIRST: Create feature branch before any edits (mandatory)\n\n- **BEFORE making your first edit** for a ticket, you MUST be on the correct feature branch.\n- **Required first action** when implementing a ticket (before touching any file):\n  1. Run `git status -sb`. Note the current branch.\n  2. Derive the feature branch name: `ticket/<id>-<short-title-kebab>` (e.g. ticket 0030 → `ticket/0030-ticket-list-add-delete-button-and-sync-deletion-to-filesystem`).\n  3. If the current branch is **not** that feature branch (including if it is `main`):\n     - Run `git checkout -b ticket/<id>-<short-title-kebab>` (or `git checkout ticket/<id>-...` if it already exists).\n     - Do this **before** any file edits.\n- **Why:** Edits on `main` conflate your work with others'; they can be lost if the tree is reset; they violate the branching policy. Branch first, then edit.\n\n## Only commit what your ticket changes\n\n- An agent must only commit changes that belong to the **current ticket** they are implementing.\n- **FORBIDDEN:** bundling unrelated file changes into the ticket commit (including stray edits, formatting passes, or leftover untracked files).\n\n## Concurrency safety (assume other agents may be running)\n\n- Always assume **another agent might be editing files in parallel** in the same repo.\n- **FORBIDDEN:** touching, restoring, staging, committing, or deleting files you did not personally change in the current task.\n  - Do **not** “clean up” other agents’ work-in-progress.\n  - Do **not** run broad commands that can affect unrelated files (examples: `git add .`, `git add -A`, `git restore .`, `git checkout .`, mass-formatting).\n  - Do **not** run `git stash` (or `git stash -u`) on the whole working tree unless you are certain no other agent has uncommitted work there — stashing removes uncommitted changes from the working tree; if another agent was implementing a ticket on a feature branch but had not yet committed, their code would exist only in the stash and can be lost.\n- If you need a clean place to work while the main working tree is dirty, use a **git worktree** so your changes are isolated.\n\n## Staging discipline (required)\n\nBefore committing ticket work:\n\n- Review `git diff` and `git status` and ensure every changed file is expected.\n- Stage only the intended files (explicit `git add <paths>`).\n- If any unrelated changes exist:\n  - revert them, delete them, or move them into a **separate ticket/branch**.\n\n## Do not “fix someone else’s work” inside a ticket\n\n- If you discover a problem outside the ticket scope (including process cleanup), do **not** fold it into the ticket.\n- Create a new ticket via the **HAL app** (PM agent) or HAL API, then fix it on its own branch. Do not write a ticket file in `docs/tickets/`; tickets are created only in Supabase. For column/status moves, use HAL API endpoint `POST /api/tickets/move` — do not edit ticket frontmatter by hand.\n\n## Branching requirement (ties to done-means-pushed)\n\n- Ticket work must be performed on `ticket/<id>-<short-title-kebab>` branches.\n- Do not commit ticket work directly on `main`.\n- If you discover you implemented on `main`: create the feature branch, then `git checkout -b ticket/<id>-...` — uncommitted changes will move with you. Commit on the feature branch.\n",
      "agentTypes": [
        "all",
        "project-manager"
      ],
      "topicId": "change-ownership-and-staging-discipline",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Change Ownership + Staging Discipline",
        "description": "Branching, staging, and commit discipline requirements",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "branch",
          "staging",
          "commit",
          "feature branch"
        ]
      }
    },
    {
      "path": "conversation-protocol.mdc",
      "name": "conversation protocol",
      "description": "Conversation protocol (one question when input needed)",
      "alwaysApply": true,
      "content": "# Conversation Protocol\n\n- You may do as much work as needed per message.\n- When you need user input, you may ask **at most one** question in that message.\n- Do not bundle multiple questions; spread them across messages.\n- When the user provides a new agent rule, record it in `.cursor/rules/` at the workspace root (not inside individual project folders).\n- After updating any rule file(s), explicitly state **which** `.cursor/rules/*.mdc` file(s) were updated.\n- **When starting a ticket:** your **ABSOLUTE FIRST action** (before reading the ticket, before any file edits, before creating a branch) is to:\n  1. **MANDATORY: Read existing artifacts first** - This is non-negotiable. See **auditability-and-traceability**: Implementation Agent: First Step.\n     - Read `.hal/api-base-url` and call `POST ${baseUrl}/api/artifacts/get` with `{ ticketId: \"<ticket-id>\" }`\n     - **CRITICAL:** Check for QA reports with FAIL verdicts - read them completely to understand what went wrong\n     - **CRITICAL:** Check for Human in the Loop failures in QA reports - read them completely to understand what failed in user testing\n     - Review all existing implementation artifacts to understand previous work\n     - **DO NOT skip this step** - Tickets often fail QA multiple times or fail Human in the Loop validation, and you must understand the failure context\n  2. Run `git status -sb` and create/checkout `ticket/<id>-<short-title-kebab>` if not already on it. FORBIDDEN: editing files on `main`. See **change-ownership-and-staging-discipline**: FIRST.\n- **When you have finished a feature/task** (implementation + audit): before sending any summary or \"done\" message, follow **done-means-pushed**: run `git add`, `git commit`, `git push`, then include `git status -sb` in your reply. Do not delegate commit/push to the user.\n",
      "agentTypes": [
        "all",
        "implementation-agent"
      ],
      "topicId": "conversation-protocol",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "delete-branch-after-merge.mdc",
      "name": "delete branch after merge",
      "description": "Delete feature branch after merge to main",
      "alwaysApply": true,
      "content": "# Delete Branch After Merge to Main\n\n- **After** a feature branch is merged into `main`, **delete that feature branch** (local and remote).\n- This keeps the repo tidy and makes it clear which branches are still in progress.\n\n## Who does it\n\n- **Whoever performs the merge** (QA, user, or agent when explicitly asked to merge) must delete the branch after merging.\n- If you merge a branch into `main` (e.g. `ticket/0012-...` or `feat/...`), run:\n  - `git branch -d <branch-name>` (local delete; use `-D` only if needed)\n  - `git push origin --delete <branch-name>` (remote delete)\n- If you use a pull request / merge on the host (e.g. GitHub), use the host’s “Delete branch” option after the merge.\n\n## Branch naming\n\n- Feature branches: `ticket/<id>-<short-title-kebab>` or `feat/...`.\n- Do not delete `main` or long-lived branches that are not feature branches.\n\n## Summary\n\n- Merge to `main` → then delete the merged feature branch (local + remote).\n- Prevents accumulation of stale branch names and clarifies what’s still open.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "delete-branch-after-merge",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Delete Branch After Merge",
        "description": "Branch cleanup after merging to main",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "branch",
          "merge",
          "cleanup"
        ]
      }
    },
    {
      "path": "done-means-pushed.mdc",
      "name": "done means pushed",
      "description": "\"Done\" requires commit + push (all agents)",
      "alwaysApply": true,
      "content": "# “Done” Means Committed + Pushed (All Agents)\n\n- **FORBIDDEN:** Sending a \"done\" or summary message while the working tree has uncommitted/unpushed changes. Commit and push first; then summarize.\n\n## Implementation Agent Completion Checklist (MANDATORY)\n\n**Before sending ANY summary message, verify ALL of these are complete:**\n\n- [ ] Code implemented and tested\n- [ ] **TypeScript compilation passes with zero errors** — Run `npm run build:hal` (or `tsc -b`) and verify it completes successfully. **NON-NEGOTIABLE:** TypeScript errors are blocking. Fix all TypeScript errors before proceeding.\n- [ ] **Build succeeds** — Run `npm run build:hal` and verify the build completes without errors. This ensures Vercel deployments will succeed.\n- [ ] All changes committed to feature branch (with ticket ID in commit message)\n- [ ] Feature branch pushed to remote\n- [ ] **All 7 artifacts stored in Supabase** (plan, worklog, changed-files, decisions, verification, pm-review, git-diff)\n- [ ] **Artifacts verified** via `/api/artifacts/get` - all 6 present\n- [ ] Feature branch merged to `main`\n- [ ] `main` pushed to remote\n- [ ] Feature branch deleted (local and remote)\n- [ ] HAL dev server restarted on latest `main`\n- [ ] Ticket body updated with branch name and merge confirmation\n- [ ] **Ticket moved to QA column** via HAL API (`POST /api/tickets/move` with `{ ticketId: \"<id>\", columnId: \"col-qa\" }`)\n- [ ] `git status -sb` shows clean working tree on `main`\n\n**Only after ALL items are checked may you send a summary message.**\n\n## Start of task: feature branch first (prevents lost work)\n\n- **MANDATORY:** Before making **any** file changes for a ticket, create/checkout the feature branch. This is non-negotiable. See also **no-edits-on-main.mdc**.\n- **Required first step** (before the first edit):\n  1. Run `git status -sb`. Note the current branch.\n  2. If you are on **`main`**: do **not** use StrReplace, Write, or EditNotebook. Run `git checkout -b ticket/<id>-<short-title-kebab>` (or `git checkout ticket/<id>-...` if it exists remotely) first.\n  3. Feature branch name: `ticket/<id>-<short-title-kebab>` (e.g. ticket 0030 → `ticket/0030-ticket-list-add-delete-button-and-sync-deletion-to-filesystem`).\n  4. Only after you are on the feature branch may you edit files.\n- **FORBIDDEN:** Implementing ticket work on `main`. If you realize you edited on `main`: run `git checkout -b ticket/<id>-...` — uncommitted changes move with you; commit on the feature branch.\n- **Why:** Edits on `main` conflate work, can be lost on stash/reset, and violate branching policy. Branch first.\n\n## Branching policy (feature branches required)\n\n- For ticketed work, agents must work on a **feature branch**, not directly on `main`.\n  - Branch naming: `ticket/<id>-<short-title-kebab>` (example: `ticket/0003-hal-chat-hal-agents`).\n- “Ready / done” requires:\n  - the feature branch is **pushed** to remote, and\n  - `git status -sb` shows the branch is **synced** and the working tree is **clean**.\n\n\n QA performs code review + automated verification (no manual UI testing), then merges to main and moves the ticket to Human in the Loop for user testing. The implementation agent must add the branch name to the ticket (see ticket template), then may claim “ready/done.”\n\n## Cloud QA branch access limitation (implementation agent workflow)\n\n- **Scenario:** Implementation cloud agent can create/push a feature branch, but the separate QA cloud agent **cannot access non-`main` branches** (e.g., due to cloud environment restrictions). This is the standard workflow for cloud agents.\n- **When ready for QA:** The implementation agent must:\n  1. **Run `npm run build:hal` (or `tsc -b`) and verify it completes with zero TypeScript errors**. **NON-NEGOTIABLE:** TypeScript errors are blocking. Fix all TypeScript errors before proceeding.\n  2. Verify the feature branch is clean and pushed to remote.\n  3. **Store all required artifacts in Supabase** by including tool calls in your message:\n     ```json\n     {\n       \"tool\": \"insert_implementation_artifact\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"artifactType\": \"plan\",\n         \"title\": \"Plan for ticket 0076\",\n         \"body_md\": \"# Plan\\n\\n...\"\n       }\n     }\n     ```\n     (Repeat for each required artifact: plan, worklog, changed-files, decisions, verification, pm-review, git-diff)\n  4. **Merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0056): merge feature branch to main for cloud QA access`).\n  5. Push `main` to remote.\n  6. **Kill HAL** (`npx --yes kill-port 5173 5174`), **pull from main** (`git pull origin main`), **restart HAL** (`npm run dev` in background).\n  7. **Update the ticket body** by including a tool call in your message:\n     ```json\n     {\n       \"tool\": \"update_ticket_body\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"body_md\": \"# Updated ticket body with branch name, merge note, etc.\"\n       }\n     }\n     ```\n  8. Mark the ticket as \"Merged to main for QA\" (add this note to the ticket body).\n  9. **Move the ticket to QA column** by including a tool call in your message:\n     ```json\n     {\n       \"tool\": \"move_ticket_column\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"columnId\": \"col-qa\"\n       }\n     }\n     ```\n  10. Then send the completion/summary message including the branch name, merge note, and `git status -sb`.\n- **Why:** Cloud QA agents may only have access to `main` branch. Merging to `main` makes the changes accessible for QA review and testing.\n\n## Artifacts storage requirement (implementation agent)\n\n**MANDATORY:** The implementation agent **must** store all 7 required artifacts in Supabase **before** claiming the ticket is \"ready for QA\" or \"done\". This is non-negotiable.\n\n- **When marking a ticket ready for QA:** The implementation agent **must** store all required artifacts in Supabase by sending tool calls in your messages.\n- **Required artifacts** (all stored via tool call `insert_implementation_artifact`):\n  - Plan (`artifactType: \"plan\"`, title: `Plan for ticket <ticket-id>`)\n  - Worklog (`artifactType: \"worklog\"`, title: `Worklog for ticket <ticket-id>`)\n  - Changed Files (`artifactType: \"changed-files\"`, title: `Changed Files for ticket <ticket-id>`)\n  - Decisions (`artifactType: \"decisions\"`, title: `Decisions for ticket <ticket-id>`)\n  - Verification (`artifactType: \"verification\"`, title: `Verification for ticket <ticket-id>`)\n  - PM Review (`artifactType: \"pm-review\"`, title: `PM Review for ticket <ticket-id>`)\n  - Git diff (`artifactType: \"git-diff\"`, title: `Git diff for ticket <ticket-id>`)\n- **Storage method:** \n  - **Preferred:** If `.hal/api-base-url` exists, call HAL API directly: `POST ${baseUrl}/api/artifacts/insert-implementation` for each artifact.\n  - **Fallback:** Write tool calls to `.hal-tool-call-queue.json` in the repo root.\n- **Verification:** After storing artifacts, verify they were stored by calling `/api/artifacts/get` with the ticket ID. If any artifact is missing, store it again before claiming \"ready\".\n- **FORBIDDEN:** Claiming \"ready for QA\", \"done\", or \"complete\" without storing all 7 required artifacts. QA will fail tickets with missing artifacts.\n- **Why:** All artifacts are stored in Supabase's `agent_artifacts` table and linked to the ticket via `ticket_pk`. The Kanban UI can display these artifacts, making work fully auditable without requiring access to the repo structure. QA agents **will fail** tickets that are missing artifacts.\n\n## Sequence: push first, merge to main, then summarize\n\n- The moment you **think** you're done (implementation complete, audit written, etc.) is when you **verify TypeScript compilation and build** — not after you've already told the user.\n- **First:** **Run `npm run build:hal` (or `tsc -b`) and verify it completes with zero TypeScript errors**. **NON-NEGOTIABLE:** TypeScript errors are blocking. Fix all TypeScript errors before proceeding. Then commit all relevant changes, **push the feature branch** to GitHub, **merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0060): merge feature branch to main`), push `main`, **delete the feature branch** (local and remote).\n- **After merge, before summarizing (implementation agent):** After merging to `main` and pushing `main`, and before updating the ticket body or sending the summary message:\n  1. **Kill HAL:** Stop the dev server (e.g. `npx --yes kill-port 5173 5174` to free HAL and Kanban ports).\n  2. **Pull from main:** Run `git pull origin main` (you should already be on `main`).\n  3. **Restart HAL:** Run `npm run dev` (in the background or in a dev terminal) so the app is running the latest `main`.\n- Then **update the ticket body** by including a tool call in your message to update the ticket with the branch name, merge note, and a note that all artifacts are stored in Supabase.\n- **Move the ticket to QA column** by including a tool call in your message:\n  ```json\n  {\n    \"tool\": \"move_ticket_column\",\n    \"params\": {\n      \"ticketId\": \"<ticket-id>\",\n      \"columnId\": \"col-qa\"\n    }\n  }\n  ```\n- **Then:** tell the user what was done (summary, verification, audit location, **branch name**). Do not give the long \"here's what I did\" report until after push + merge + branch deletion + HAL restart + ticket update + ticket move.\n- **MANDATORY:** Always merge to main and delete the feature branch before sending any summary message. This applies to all implementation work, not just cloud QA scenarios.\n- If you summarize first and then commit/push/merge (or forget to add the branch to the ticket), you did it in the wrong order.\n\n## Before you reply: the gate\n\n- **If you are about to send a message** that summarizes completed work, or that includes any of: \"done\", \"complete\", \"ready\", \"looks good\", \"here's what I did\", \"Implementation complete\", \"Summary:\", or similar — **STOP**.\n- **First** run: `git status -sb`. If there are any `M` (modified) or `??` (untracked) relevant to the task: **run `npm run build:hal` (or `tsc -b`) and verify it completes with zero TypeScript errors**. **NON-NEGOTIABLE:** If TypeScript errors exist, fix them before proceeding. Then run `git add`, `git commit -m '...'` (with ticket ID in subject), `git push` (feature branch), **store all 7 required artifacts in Supabase** by calling HAL API directly or writing to queue file, **verify artifacts were stored** by calling `/api/artifacts/get`, then **merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0060): merge feature branch to main`), push `main`, **delete the feature branch** (local and remote). Then **kill HAL** (`npx --yes kill-port 5173 5174`), **pull from main** (`git pull origin main`), **restart HAL** (`npm run dev` in background), **update the ticket body** by including a tool call in your message with the branch name, merge note, and a note that all artifacts are stored in Supabase, and **move the ticket to QA column** by including a tool call in your message with `{ ticketId: \"<id>\", columnId: \"col-qa\" }`. Then run `git status -sb` again.\n- **Only after** the working tree is clean, **all 7 required artifacts are verified as stored in Supabase** (via `/api/artifacts/get`), the feature branch is merged to main, the branch is deleted, HAL has been restarted on latest main, the **branch name is added to the ticket**, and the **ticket is moved to QA column** may you send that message — and your message **must** include the **branch name** and the exact `git status -sb` output.\n- **CRITICAL:** If artifact storage or verification fails, do **not** claim \"ready\" or \"done\". Fix the artifact storage issue first. QA will fail tickets with missing artifacts.\n- **MANDATORY:** Always merge to main and delete the feature branch before sending any summary message. Never send a summary while still on a feature branch.\n- If you have not yet committed, pushed, merged to main, and deleted the branch, do **not** send a \"done\" or summary message; do all of these steps in this same turn, then reply.\n\n## Requirements\n\n- If any agent believes a task/story is **done**, they must:\n  - **commit** all relevant changes, and\n  - **push** to the remote\n  before telling the user or project manager that it’s done.\n- Agents must not delegate commit/push work to the user/PM (e.g., “after you commit and push…”).\n  - If commit/push hasn’t happened yet, the correct status is **“not ready for verification.”**\n- “Done/ready” messages must include the **feature branch name** (so QA can check out and verify) and the exact `git status -sb` output showing the branch is synced and the working tree is clean.\n  - “Clean” means: **no modified files** and **no untracked files** (ignored build artifacts are fine).\n\n## Commit message linkage (no commit hashes in docs)\n\n- Every commit that belongs to a ticket must include the ticket ID in the commit subject (e.g. `feat(0010): ...`, `fix(0008): ...`, `docs(0009): ...`).\n- If a ticket requires follow-up commits after an initial “feat/fix” commit, those follow-up commits must also include the same ticket ID in the subject.\n  - Do not “sneak in” ticket work under unlabeled commits like `chore: ...` if it still belongs to the ticket.\n- If `git status -sb` is not clean/synced, the agent must say **“not ready for verification”** and keep working until it is.\n  - Do not claim “ready” if `git status` shows any `??` (untracked) or `M` (modified) entries.\n\n## PM verification\n\n- The project manager’s “done” is only **candidate-complete** until the user verifies the acceptance criteria.\n- Do not use language like “done” or “complete” until changes are committed and pushed.\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "done-means-pushed",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Done Means Committed + Pushed",
        "description": "Completion checklist and workflow requirements for implementation agents",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "commit",
          "push",
          "ready",
          "verification",
          "artifacts"
        ]
      }
    },
    {
      "path": "no-edits-on-main.mdc",
      "name": "no edits on main",
      "description": "Hard gate — never make file edits while on main; branch first",
      "alwaysApply": true,
      "content": "# No Edits on Main (Hard Gate)\n\n## You MUST NOT edit files when on `main`\n\n- **FORBIDDEN:** Using `StrReplace`, `Write`, `EditNotebook`, or any tool that modifies files when the current Git branch is `main`.\n- **Before any file-modifying action** for a ticket or implementation task:\n  1. Run `git status -sb` (or equivalent) and note the **current branch**.\n  2. If the current branch is **`main`** (or `master`):\n     - **STOP.** Do **not** run `StrReplace`, `Write`, or `EditNotebook`.\n     - Create or checkout the feature branch first:  \n       `git checkout -b ticket/<id>-<short-title-kebab>`  \n       (or `git checkout ticket/<id>-...` if it already exists).\n     - Only **after** you are on the feature branch may you make edits.\n  3. If the user did **not** give a ticket ID, ask for it or infer it from context (e.g. from the ticket file they referenced). The branch name is `ticket/<id>-<short-title-kebab>`.\n\n## Why this rule exists\n\n- Edits on `main` conflate work with other changes, get lost on reset/rebase, and violate the repo’s branching policy.\n- QA merges from feature branches; work on `main` bypasses that flow and cannot happen.\n\n## Summary\n\n- **On `main` → no file edits.** Branch first, then edit.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "no-edits-on-main",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "qa-audit-report.mdc",
      "name": "qa audit report",
      "description": "QA agents must store QA reports in Supabase via HAL API",
      "alwaysApply": true,
      "content": "# QA Audit Report (QA Agents)\n\nWhen you **QA a ticket** (e.g. user asks to \"QA\", \"verify\", or \"check\" a ticket that is allegedly complete), you **must** store a QA report in Supabase via HAL's API endpoints.\n\n## Cloud QA workflow context\n\nIn cloud environments, QA agents may not have access to feature branches (only `main`). When this is the case, the implementation agent merges the feature branch to `main` before QA begins. QA must then verify from `main` rather than attempting to check out a feature branch. This workflow is indicated when the ticket states \"merged to `main` for QA access\" or similar language.\n\n## Which branch to use (decision rule)\n\n- **If the ticket or prompt states that the implementation was \"merged to main for QA access\"** (or that code is on `main` for QA): \n  - You **must** verify from the **`main`** branch. \n  - Do **not** attempt to locate, check out, or use the feature branch.\n  - **Step 1:** Pull the latest `main` branch: `git checkout main && git pull origin main`\n  - **Step 2:** Perform QA on `main` (code review and verification).\n  - **Step 3:** Record in the QA report that verification was performed against `main` (e.g. \"Verified on `main`; implementation was merged to main for QA access.\").\n  - **Step 4:** Store the QA report in Supabase via HAL API (see \"Storing QA report\" below).\n  - **Step 5:** Move ticket to Human in the Loop via HAL API, then provide summary.\n- **Otherwise:** use the feature branch named in the ticket's QA → Branch field (or the branch you were launched on). Perform QA on that branch, then follow the full workflow (merge to main, delete branch, etc.).\n\n**Important:** When QA cannot access feature branches (cloud QA workflow), the implementation agent merges the feature branch to `main` before QA. In this case, QA must verify from `main` and record this in the QA report stored in Supabase.\n\n## Required implementation artifacts (must be present before QA)\n\n**MANDATORY:** Before performing any QA work, you **must** verify that all required implementation artifacts are present in Supabase. If any are missing, QA **must fail immediately** without attempting code review or verification.\n\n**Required implementation artifacts:**\n1. **Plan artifact** (`artifactType: \"plan\"`, title: `Plan for ticket <ticket-id>`)\n2. **Worklog artifact** (`artifactType: \"worklog\"`, title: `Worklog for ticket <ticket-id>`)\n3. **Changed Files artifact** (`artifactType: \"changed-files\"`, title: `Changed Files for ticket <ticket-id>`)\n4. **Decisions artifact** (`artifactType: \"decisions\"`, title: `Decisions for ticket <ticket-id>`)\n5. **Verification artifact** (`artifactType: \"verification\"`, title: `Verification for ticket <ticket-id>`)\n6. **PM Review artifact** (`artifactType: \"pm-review\"`, title: `PM Review for ticket <ticket-id>`)\n7. **Git diff artifact** (`artifactType: \"git-diff\"`, title: `Git diff for ticket <ticket-id>`)\n\n**How to check for artifacts:**\n1. **First step (MANDATORY):** Call HAL API endpoint `/api/artifacts/get` with `{ ticketId: \"<ticket-id>\" }` to fetch all artifacts for the ticket.\n   - If `.hal/api-base-url` exists, read it and call: `POST ${baseUrl}/api/artifacts/get`\n   - If API call fails (404, 500, network error, etc.), **QA MUST FAIL** — you cannot verify artifacts exist, so assume they are missing.\n   - **DO NOT proceed with code review if artifact verification fails.**\n2. Filter the returned artifacts to find implementation artifacts (where `agent_type === \"implementation\"`).\n3. Check that all 7 required artifact types are present by matching artifact titles:\n   - `Plan for ticket <ticket-id>`\n   - `Worklog for ticket <ticket-id>`\n   - `Changed Files for ticket <ticket-id>`\n   - `Decisions for ticket <ticket-id>`\n   - `Verification for ticket <ticket-id>`\n   - `PM Review for ticket <ticket-id>`\n   - `Git diff for ticket <ticket-id>`\n\n**Auto-fail when artifacts are missing or unverifiable:**\n- **If artifact API call fails (404, 500, network error, timeout):** QA **must fail immediately**. You cannot verify artifacts exist, so treat as missing.\n- **If any required artifact is missing:** QA **must fail immediately**.\n- **Do NOT** attempt code review, verification, or any other QA work when artifacts cannot be verified or are missing.\n- **Do NOT** attempt to \"guess\" or recreate missing artifacts.\n- **Do NOT** proceed with code review and note \"artifacts couldn't be verified\" — this is a FAIL condition.\n- **Record a QA Fail outcome** by storing a QA report that clearly states the failure reason.\n- **The QA report must enumerate the specific missing artifacts** (or state \"Artifact verification failed: API returned [error]\" if API call failed).\n- **Store the QA report in Supabase** using `insert_qa_artifact` tool (via HAL API or queue file).\n- **Move ticket to To-do** (`col-todo`) via HAL API.\n- **The final message must include:** `QA RESULT: FAIL — <ticket-id>` (see \"Completion message format requirement\" below).\n\n**Example QA report when artifacts are missing:**\n```markdown\n# QA Report for ticket 0076\n\n## Ticket & Deliverable\n[Brief summary from ticket]\n\n## Missing Required Implementation Artifacts\n\n**QA FAILED:** Required implementation artifacts are missing. QA cannot proceed without complete implementation artifacts.\n\n**Missing artifacts:**\n- Plan artifact (`Plan for ticket 0076`)\n- PM Review artifact (`PM Review for ticket 0076`)\n\n**Present artifacts:**\n- Worklog artifact\n- Changed Files artifact\n- Decisions artifact\n- Verification artifact\n\n## Verdict\n\n**FAIL** — Implementation artifacts incomplete. Implementation agent must store all required artifacts before QA can proceed.\n\nQA RESULT: FAIL — 0076\n```\n\n**If all required artifacts are present:** Proceed with normal QA workflow (code review, verification, etc.).\n\n**CRITICAL:** Artifact verification is the **first and mandatory step** of QA. Do not skip it, do not defer it, do not proceed with code review if verification fails. If you cannot verify artifacts exist, the ticket fails QA.\n\n## Required artifact (QA report)\n\n- **Storage:** Supabase `agent_artifacts` table (via HAL API endpoint `/api/artifacts/insert-qa`)\n- **When:** After performing QA (code review and, if possible, UI verification) for a ticket, OR when auto-failing due to missing implementation artifacts.\n- **Agent type:** `qa`\n- **Title format:** `QA report for ticket <ticket-id>`\n\n## QA report structure\n\n1. **Ticket & deliverable** — One-line goal, deliverable, and acceptance criteria from the ticket.\n2. **Missing Required Implementation Artifacts** (if applicable) — List of missing artifacts. If artifacts are missing, this section must be present and QA must fail.\n3. **Audit artifacts** — Confirm all required implementation artifacts are present in Supabase (plan, worklog, changed-files, decisions, verification, pm-review). Only include this section if all artifacts are present.\n4. **Code review** — PASS/FAIL with brief evidence (e.g. table of requirement vs implementation; file and line refs if helpful). Only include if artifacts are present.\n5. **Build verification** — **MANDATORY:** Run `npm run build:hal` (or `tsc -b`) and verify it completes with zero TypeScript errors. If TypeScript errors exist, QA **MUST FAIL** immediately. Document the build result (PASS/FAIL) and any TypeScript errors found. Only include if artifacts are present.\n6. **UI verification** — What was run: automated and/or manual steps. If automated UI was not run (e.g. native dialogs, login, or pickers), state that and list the manual steps the user should run. Only include if artifacts are present.\n7. **Verdict** — Implementation complete? OK to merge? Any blocking manual verification? Must clearly state PASS or FAIL.\n\n## Storing QA report\n\n**Send a tool call to HAL in your message:**\n\nInclude this JSON block in your message:\n\n```json\n{\n  \"tool\": \"insert_qa_artifact\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"title\": \"QA report for ticket 0076\",\n    \"body_md\": \"# QA Report\\n\\n...\"\n  }\n}\n```\n\nHAL will parse this from your message, execute it, and store the artifact in Supabase. You don't need API URLs or credentials - just include the JSON in your message.\n\n## QA completion: do not hand off to the user\n\nWhen the verdict is **PASS (OK to merge)**, QA must **complete the full workflow** — do not stop at a summary or \"next steps for the user.\"\n\n## Completion message format requirement\n\n**MANDATORY:** The final completion message to the user **must** include the ticket ID and an explicit PASS/FAIL outcome token in a consistent, easy-to-spot format.\n\n- **Format:** `QA RESULT: <PASS|FAIL> — <ticket-id>`\n- **Examples:**\n  - `QA RESULT: PASS — 0056`\n  - `QA RESULT: FAIL — 0056`\n- **Placement:** This must appear in the final summary message that QA sends to the user after completing all workflow steps (merge, branch deletion, ticket updates, etc.).\n- **Why:** HAL needs to reliably parse QA outcomes from chat transcripts. The format must be human-verifiable (no external tooling required) and consistently structured for automated interpretation.\n- **Verification:** A human can read the QA chat transcript in the app and immediately see the ticket ID and outcome without parsing complex prose.\n\n**If you are verifying from the feature branch** (normal workflow):\n\n1. **Store QA report in Supabase** — Include a tool call in your message:\n   ```json\n   {\n     \"tool\": \"insert_qa_artifact\",\n     \"params\": {\n       \"ticketId\": \"0076\",\n       \"title\": \"QA report for ticket 0076\",\n       \"body_md\": \"# QA Report\\n\\n...\"\n     }\n   }\n   ```\n2. **Update ticket body** (optional) — If needed, include a tool call to update the ticket body:\n   ```json\n   {\n     \"tool\": \"update_ticket_body\",\n     \"params\": {\n       \"ticketId\": \"0076\",\n       \"body_md\": \"# Updated ticket body...\"\n     }\n   }\n   ```\n3. **Move ticket to Human in the Loop** — Include a tool call:\n   ```json\n   {\n     \"tool\": \"move_ticket_column\",\n     \"params\": {\n       \"ticketId\": \"0076\",\n       \"columnId\": \"col-human-in-the-loop\"\n     }\n   }\n   ```\n4. **Merge to main** — checkout `main`, merge the feature branch, push `main`.\n5. **Delete the feature branch** — local and remote (see `delete-branch-after-merge.mdc`).\n6. **Then** give your summary to the user. **The final message must include:** `QA RESULT: PASS — <ticket-id>` (see \"Completion message format requirement\" above).\n\n**If you are verifying from `main`** (implementation was merged to main for QA access):\n\n1. **Store QA report in Supabase** — Include a tool call in your message. Include a note in the report that verification was performed against `main`.\n2. **Update ticket body** (optional) — If needed, include a tool call to note that verification was performed against `main`.\n3. **Move ticket to Human in the Loop** — Include a tool call to move the ticket.\n4. **Then** give your summary to the user. **The final message must include:** `QA RESULT: PASS — <ticket-id>` (see \"Completion message format requirement\" above).\n\nDo not give a summary with \"next steps\" or \"run these commands\" — QA performs the merge (or confirms main) and branch deletion where applicable. The user receives the completed result.\n\n- Use a commit subject that includes the ticket ID (e.g. `qa(0033): add QA report, move to Human in the Loop`).\n- **If verdict is FAIL:** Do not merge. Store the QA report in Supabase, then **move the ticket to the top of To-do** (`col-todo` column) via HAL API. Summarize findings and recommend a bugfix ticket (see `bugfix-tracking.mdc`). **The final message must include:** `QA RESULT: FAIL — <ticket-id>` (see \"Completion message format requirement\" above).\n  \n  **FAIL workflow:**\n  1. **Store QA report in Supabase** — Include a tool call in your message:\n     ```json\n     {\n       \"tool\": \"insert_qa_artifact\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"title\": \"QA report for ticket 0076\",\n         \"body_md\": \"# QA Report\\n\\n...\"\n       }\n     }\n     ```\n  2. **Move ticket to To-do** — Include a tool call to move the ticket to `col-todo`:\n     ```json\n     {\n       \"tool\": \"move_ticket_column\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"columnId\": \"col-todo\"\n       }\n     }\n     ```\n     **Note:** The goal is to move failed tickets to the **top** of the To-do column for priority handling. The current move API (`/api/tickets/move`) appends tickets to the end of the column. If the API is enhanced in the future to support position parameters, use position 0 or a negative value to place at the top. For now, moving to `col-todo` satisfies the requirement even if it's at the end initially.\n  3. **Then** give your summary to the user. **The final message must include:** `QA RESULT: FAIL — <ticket-id>`.\n\n## HAL Tool Call Contract\n\nAll Supabase operations are sent to HAL as **tool calls** in your messages. HAL parses and executes them automatically.\n\n**Available tools:**\n\n- **`insert_qa_artifact`** — Store QA report in Supabase\n  - Params: `{ ticketId: string, title: string, body_md: string }`\n\n- **`update_ticket_body`** — Update ticket body in Supabase\n  - Params: `{ ticketId: string, body_md: string }`\n\n- **`move_ticket_column`** — Move ticket to different column\n  - Params: `{ ticketId: string, columnId: string }`\n\n- **`get_ticket_content`** — Fetch ticket content\n  - Params: `{ ticketId: string }`\n\n**How to use:** Include tool calls as JSON blocks in your messages. HAL will parse and execute them. You don't need API URLs or credentials.\n\nSee `.cursor/rules/agent-supabase-api-paradigm.mdc` for full documentation.\n\n## Scope\n\n- Applies to any QA or verification of a **ticketed** task (ticket in Supabase).\n- Keep the report concise; use bullets and tables where appropriate.\n- All artifacts are stored in Supabase, not in `docs/audit/` folders.",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent"
      ],
      "topicId": "qa-audit-report",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "QA Audit Report",
        "description": "QA workflow, artifact verification, and report requirements",
        "agentTypes": [
          "qa-agent"
        ],
        "keywords": [
          "qa",
          "verification",
          "artifacts",
          "code review",
          "build"
        ]
      }
    },
    {
      "path": "scope-discipline.mdc",
      "name": "scope discipline",
      "description": "Prevent unrequested changes (scope discipline)",
      "alwaysApply": true,
      "content": "# Scope Discipline (No Unrequested Changes)\n\n- Implement **only** what the ticket requests.\n- Do not change styling/behavior “while you’re here” unless:\n  - it is required to satisfy an acceptance criterion, OR\n  - it fixes a bug introduced by the task, AND it is documented.\n\n## Required documentation when deviations are unavoidable\n\n- If you must make a change not explicitly requested:\n  - add it to the Decisions artifact in Supabase (stored via `POST /api/artifacts/insert-implementation` with `artifactType: \"decisions\"`) under **Unrequested changes (required)**:\n    - what changed\n    - why it was necessary\n    - how a human can verify it in the UI\n\n## Verification quality bar\n\n- The Verification artifact in Supabase (stored via `POST /api/artifacts/insert-implementation` with `artifactType: \"verification\"`) must include checks that confirm:\n  - the requested change works, AND\n  - adjacent UI did **not** regress (basic smoke checks).\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "scope-discipline",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Scope Discipline",
        "description": "Rules for staying within ticket scope and documenting deviations",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "scope",
          "unrequested changes",
          "decisions"
        ]
      }
    },
    {
      "path": "submodule-sync.mdc",
      "name": "submodule sync",
      "description": "Submodule synchronization (when HAL has submodules)",
      "alwaysApply": true,
      "content": "# Submodule Sync Protocol\n\n## Global rules live in the HAL repo\n\n- The **only** authoritative global agent rules are in: `portfolio-2026-hal/.cursor/rules/`.\n- `projects/kanban` and `projects/hal-agents` are **normal directories** in the HAL repo (monorepo). Edit them directly; no submodule sync needed.\n- If HAL later adds other submodules (e.g. `projects/project-1`), they may contain a stub rule that points back here.\n\n## Context (0013)\n\n`portfolio-2026-hal` is a **monorepo**. Kanban and hal-agents are vendored under `projects/`:\n\n- `projects/kanban` — vendored (was submodule; now regular tracked files).\n- `projects/hal-agents` — normal directory (agents code; single source of truth).\n\nThere are **no git submodules** in HAL after 0013. Running `npm run dev` does not require `git submodule update`.\n\n## After Pushing to an External Repo (if you mirror)\n\nIf you maintain a separate mirror of kanban or hal-agents and push there, update that repo from HAL when needed. HAL is the source of truth; no submodule pointer to update in HAL.\n\n## Why This Matters\n\n- The HAL app embeds the kanban board from `projects/kanban`.\n- All code is in one repo; no sync step. Fresh clone + `npm install` (root and projects/kanban if needed) + `npm run dev` is enough.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "submodule-sync",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Submodule Sync Protocol",
        "description": "Global rules location and submodule handling",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "submodule",
          "rules",
          "monorepo"
        ]
      }
    },
    {
      "path": "task-sizing-and-in-app-debugging.mdc",
      "name": "task sizing and in app debugging",
      "description": "Task sizing, verifiability, and in-app debugging (no console)",
      "alwaysApply": true,
      "content": "# Task Sizing + Verifiable Output\n\n- Every coding task assigned to an agent must be as small as possible.\n- The limiting factor on shrinking tasks/stories is that **each task must result in a human-verifiable change to the app**.\n- Verification must require **no external tools** (no terminal, no devtools console, no logs).\n- Prefer acceptance criteria phrased as: “A human can click/see X in the UI and confirm Y.”\n\n# In-App Debugging Requirement\n\n- The app must include whatever **in-app debugging/diagnostics UI** we need to understand failures.\n- Do **not** rely on console output or logs for debugging during normal verification.\n\n# Role Constraint (for now)\n\n- In this phase, act as a **project manager**:\n  - do not implement code directly\n  - help organize thoughts and write prompts for other agents\n",
      "agentTypes": [
        "all",
        "project-manager"
      ],
      "topicId": "task-sizing-and-in-app-debugging",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Task Sizing + Verifiable Output",
        "description": "Task sizing requirements and in-app debugging needs",
        "agentTypes": [
          "project-manager"
        ],
        "keywords": [
          "task sizing",
          "debugging",
          "verification"
        ]
      }
    },
    {
      "path": "ticket-writing-sync-tickets.mdc",
      "name": "ticket writing sync tickets",
      "description": "Supabase-backed Kanban — ALWAYS update tickets in the DB first, then run sync (all agents)",
      "alwaysApply": true,
      "content": "# Ticket Source of Truth: Supabase Only (All Agents)\n\nWe use a **Supabase-backed Kanban** in **Supabase-only mode** (0065). Ticket state (content, column, position) lives in the database. The app and agents **do not read from `docs/tickets/*.md`** — tickets are fetched directly from Supabase.\n\n- **Do not create or edit ticket files** under `docs/tickets/` directly. The app does not read these files (Supabase-only mode).\n- **To create or change a ticket (any agent):** use **HAL API endpoints**:\n  - **Create / update body:** Use the HAL PM agent (create_ticket / update_ticket_body tools) or HAL API endpoint `POST /api/tickets/update`. The Kanban UI reflects changes within the polling interval (~10s).\n  - **Move ticket column (e.g. QA → Human in the Loop):** Use HAL API endpoint `POST /api/tickets/move` with `{ ticketId: string, columnId: string }`. The API uses server-side Supabase credentials.\n- **HAL API endpoints:** All Supabase operations go through HAL's API endpoints, which use server-side environment variables (`SUPABASE_URL`, `SUPABASE_ANON_KEY`). Agents don't need credentials in their environment.\n  - `POST /api/tickets/get` — Fetch ticket content\n  - `POST /api/tickets/update` — Update ticket body\n  - `POST /api/tickets/move` — Move ticket to different column\n  - `POST /api/artifacts/insert-implementation` — Store implementation artifacts\n  - `POST /api/artifacts/insert-qa` — Store QA artifacts\n- **`sync-tickets.js` is migration-only (0065):** The script no longer writes to `docs/tickets/*.md`. It can be used for one-time migration of existing files to Supabase (Docs→DB only).\n- **Never commit `.env`** (it must remain ignored).\n",
      "agentTypes": [
        "all",
        "project-manager"
      ],
      "topicId": "ticket-writing-sync-tickets",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Ticket Source of Truth",
        "description": "Supabase-backed ticket management and sync requirements",
        "agentTypes": [
          "project-manager"
        ],
        "keywords": [
          "tickets",
          "supabase",
          "kanban",
          "sync"
        ]
      }
    },
    {
      "path": "typescript-build-verification.mdc",
      "name": "typescript build verification",
      "description": "TypeScript compilation and build verification requirements (non-negotiable)",
      "alwaysApply": true,
      "content": "# TypeScript Build Verification (Non-Negotiable)\n\n**CRITICAL:** All implementation work must pass TypeScript compilation and build verification before being marked \"ready for QA\". This is **non-negotiable** and prevents Vercel deployment failures.\n\n## Mandatory Verification Steps\n\n**Before claiming \"ready for QA\" or \"done\", the implementation agent MUST:**\n\n1. **Run TypeScript compilation check:**\n   ```bash\n   npm run build:hal\n   ```\n   OR\n   ```bash\n   tsc -b\n   ```\n\n2. **Verify zero TypeScript errors:**\n   - The command must complete with exit code 0\n   - No TypeScript errors may be present in the output\n   - All type errors must be fixed before proceeding\n\n3. **Verify build succeeds:**\n   - `npm run build:hal` must complete successfully\n   - This ensures Vercel deployments will succeed\n\n## When to Run Verification\n\n- **Before committing:** Run TypeScript check after code changes\n- **Before pushing:** Verify build passes before pushing to remote\n- **Before marking \"ready\":** Final verification must pass before claiming \"ready for QA\"\n- **In Verification artifact:** Document that TypeScript compilation passed with zero errors\n\n## Failure Handling\n\n**If TypeScript errors exist:**\n- **STOP** — Do not commit, push, or claim \"ready\"\n- Fix all TypeScript errors\n- Re-run verification until it passes\n- Only then proceed with commit/push/ready workflow\n\n**If build fails:**\n- **STOP** — Do not commit, push, or claim \"ready\"\n- Fix the build errors\n- Re-run verification until it passes\n- Only then proceed with commit/push/ready workflow\n\n## Verification Artifact Requirement\n\nThe Verification artifact **must** include:\n- Confirmation that `npm run build:hal` (or `tsc -b`) was run\n- Confirmation that it completed with **zero TypeScript errors**\n- Confirmation that the build succeeded\n\n**Example:**\n```markdown\n## Automated Checks\n- ✅ TypeScript compilation: `npm run build:hal` completed with zero errors\n- ✅ Build: `npm run build:hal` succeeded\n- ✅ Linter: No errors\n```\n\n## Why This Matters\n\n- **Vercel deployments fail** if TypeScript errors exist\n- **Build failures block** deployment and prevent user testing\n- **Type safety** prevents runtime errors\n- **Consistency** ensures all code is properly typed\n\n## Commands Reference\n\n- **TypeScript check:** `npm run build:hal` or `tsc -b`\n- **Full build:** `npm run build:hal` (includes TypeScript + Vite build)\n- **Agents only:** `npm run build:agents` (TypeScript check for agents code)\n\n## Summary\n\n**NON-NEGOTIABLE:** TypeScript compilation must pass with zero errors before any work is marked \"ready for QA\". Build must succeed. No exceptions.\n",
      "agentTypes": [
        "all",
        "implementation-agent"
      ],
      "topicId": "typescript-build-verification",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "TypeScript Build Verification",
        "description": "Mandatory TypeScript compilation checks before marking ready",
        "agentTypes": [
          "implementation-agent",
          "qa-agent"
        ],
        "keywords": [
          "typescript",
          "build",
          "compilation",
          "verification"
        ]
      }
    }
  ],
  "basic": [
    {
      "path": "agent-runs-terminal-commands.mdc",
      "name": "agent runs terminal commands",
      "description": "Agents run terminal commands themselves; do not ask the user to run them",
      "alwaysApply": true,
      "content": "# Agent Runs Terminal Commands\n\n- **Tickets (Supabase-backed Kanban):** All ticket changes (create, update body, move column) must be made via **HAL API endpoints**, which update Supabase directly. Do not create or edit ticket files under `docs/tickets/` directly. Use `POST /api/tickets/update` for body updates and `POST /api/tickets/move` for column moves. The Kanban UI reflects changes within ~10 seconds (polling interval).\n- When a task requires running a terminal command (e.g. `npm run dev`, `npm run build`, `npm run sync-tickets`, restarting a dev server, `git status`, `git add`, `git commit`, `git push`), the **agent must run the command itself** when it has the ability to do so.\n- **Do not ask the user** to run terminal commands that the agent can run (e.g. \"Please run `npm run dev`\", \"Restart the HAL dev server\", \"Run `npm run sync-tickets` from the repo root\").\n- Only suggest the user run a command when the action truly requires user context (e.g. picking a folder, approving a destructive operation, or when the agent environment cannot execute the command).\n- When instructing verification or follow-up, prefer steps the agent can perform (run the command, then report the result) over steps that delegate to the user.\n\n## Keep the dev server current\n\n- **After changes that affect the HAL app or hal-agents**, run whatever is needed so the user can test immediately:\n  - Run `npm run build --prefix projects/hal-agents` if hal-agents or its consumers changed.\n  - If the dev server is not running or must be restarted: kill anything on ports 5173 and 5174 (e.g. `npx --yes kill-port 5173 5174`), then run `npm run dev` (in the background so the server stays up).\n- **Goal:** The dev server should always be current after an agent session—no \"please run npm run dev\" handoff. Start or restart dev when it makes sense so the user can open the app and test right away.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "agent-runs-terminal-commands",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "agent-supabase-api-paradigm.mdc",
      "name": "agent supabase api paradigm",
      "description": "All agents send tool calls to HAL via direct API",
      "alwaysApply": true,
      "content": "# Agent Tool Call Contract (All Agent Types)\n\n**MANDATORY:** All agent types (PM, Implementation, QA, Local Cursor, cloud agents) must persist tool calls so HAL can execute them (artifacts, ticket moves, etc.). HAL uses server-side Supabase credentials; agents never need credentials.\n\n## How to Send Tool Calls\n\n### Preferred: Call HAL API directly (cloud and local)\n\nWhen the repo contains **`.hal/api-base-url`**, read that file for the HAL base URL (e.g. `https://portfolio-2026-hal.vercel.app`). For **each** tool call, perform an HTTP request to the corresponding endpoint. No credentials are required in the request; the HAL server uses its own Supabase env.\n\n**Endpoint mapping:**\n\n| Tool | Method | Path | Request body |\n|------|--------|------|--------------|\n| `insert_implementation_artifact` | POST | `/api/artifacts/insert-implementation` | `{ ticketId, artifactType, title, body_md }` |\n| `insert_qa_artifact` | POST | `/api/artifacts/insert-qa` | `{ ticketId, title, body_md }` |\n| `update_ticket_body` | POST | `/api/tickets/update` | `{ ticketId, body_md }` |\n| `move_ticket_column` | POST | `/api/tickets/move` | `{ ticketId, columnId }` |\n| `get_ticket_content` | POST | `/api/tickets/get` | `{ ticketId }` |\n\n**Example (store plan artifact):**\n```javascript\nconst baseUrl = (await readFile('.hal/api-base-url', 'utf8')).trim()\nconst res = await fetch(`${baseUrl}/api/artifacts/insert-implementation`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({\n    ticketId: '0097',\n    artifactType: 'plan',\n    title: 'Plan for ticket 0097',\n    body_md: '# Plan\\n\\n...',\n  }),\n})\nconst result = await res.json()\nif (!result.success) throw new Error(result.error)\n```\n\n**Example (move ticket):**\n```javascript\nconst res = await fetch(`${baseUrl}/api/tickets/move`, {\n  method: 'POST',\n  headers: { 'Content-Type': 'application/json' },\n  body: JSON.stringify({ ticketId: '0097', columnId: 'col-human-in-the-loop' }),\n})\n```\n\nCall the API **immediately** when you have artifact content or a column move—do not wait for merge. This way artifacts and ticket moves appear in Supabase and on the Kanban without merging to main.\n\n**Note:** HAL runs as an API-driven app. All tool calls must be sent via direct API calls. The `.hal/api-base-url` file must be present for agents to function properly.\n\n## Available Tools\n\n### `insert_implementation_artifact`\n\nStore an implementation artifact in Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n- `artifactType` (string): One of \"plan\", \"worklog\", \"changed-files\", \"decisions\", \"verification\", \"pm-review\"\n- `title` (string): Artifact title (e.g. \"Plan for ticket 0076\")\n- `body_md` (string): Full markdown content of the artifact\n\n**Example:**\n```json\n{\n  \"tool\": \"insert_implementation_artifact\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"artifactType\": \"plan\",\n    \"title\": \"Plan for ticket 0076\",\n    \"body_md\": \"# Plan\\n\\n...\"\n  }\n}\n```\n\n### `insert_qa_artifact`\n\nStore a QA artifact in Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n- `title` (string): Artifact title (e.g. \"QA report for ticket 0076\")\n- `body_md` (string): Full markdown content of the QA report\n\n**Example:**\n```json\n{\n  \"tool\": \"insert_qa_artifact\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"title\": \"QA report for ticket 0076\",\n    \"body_md\": \"# QA Report\\n\\n...\"\n  }\n}\n```\n\n### `update_ticket_body`\n\nUpdate a ticket's body_md in Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n- `body_md` (string): Full markdown body of the ticket\n\n**Example:**\n```json\n{\n  \"tool\": \"update_ticket_body\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"body_md\": \"# Updated ticket body...\"\n  }\n}\n```\n\n### `move_ticket_column`\n\nMove a ticket to a different Kanban column.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n- `columnId` (string): Target column ID (e.g. \"col-qa\", \"col-human-in-the-loop\", \"col-todo\")\n\n**Example:**\n```json\n{\n  \"tool\": \"move_ticket_column\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"columnId\": \"col-human-in-the-loop\"\n  }\n}\n```\n\n### `get_ticket_content`\n\nFetch a ticket's content from Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n\n**Example:**\n```json\n{\n  \"tool\": \"get_ticket_content\",\n  \"params\": {\n    \"ticketId\": \"0076\"\n  }\n}\n```\n\n### `get_artifacts`\n\nFetch all artifacts for a ticket from Supabase.\n\n**Params:**\n- `ticketId` (string): Ticket ID (e.g. \"0076\")\n\n**Returns:**\n- `success` (boolean): Whether the operation succeeded\n- `artifacts` (array): Array of artifact objects with fields: `artifact_id`, `ticket_pk`, `agent_type`, `title`, `body_md`, `created_at`\n\n**Example:**\n```json\n{\n  \"tool\": \"get_artifacts\",\n  \"params\": {\n    \"ticketId\": \"0076\"\n  }\n}\n```\n\n## Benefits\n\n1. **Direct API** - Artifacts and ticket moves apply immediately without merging to main; no credentials in agent environment.\n2. **No credentials needed** - HAL server uses its own Supabase credentials.\n3. **API-driven workflow** - All tool calls are executed immediately via HTTP requests to HAL's API endpoints.\n\n## Implementation Agent Requirements\n\nImplementation agents must store all required artifacts before marking ticket ready:\n\n1. Plan artifact\n2. Worklog artifact\n3. Changed Files artifact\n4. Decisions artifact\n5. Verification artifact\n6. PM Review artifact\n\nUse `insert_implementation_artifact` for each one.\n\n## QA Agent Requirements\n\nQA agents must:\n\n1. **First step (MANDATORY):** Check for required implementation artifacts using HAL API endpoint `/api/artifacts/get` with `{ ticketId: \"<ticket-id>\" }`.\n   - If `.hal/api-base-url` exists, read it and call: `POST ${baseUrl}/api/artifacts/get`\n   - **If API call fails (404, 500, network error, timeout):** QA **MUST FAIL** immediately. You cannot verify artifacts exist, so treat as missing. Do NOT proceed with code review.\n   - **If API call succeeds:** Filter artifacts to find implementation artifacts (`agent_type === \"implementation\"`) and verify all 6 required artifact types are present.\n2. **Auto-fail if artifacts are missing or unverifiable** — store QA report enumerating missing artifacts (or API failure), move ticket to To-do, do NOT proceed with code review\n3. **If all artifacts present:** Store QA report using `insert_qa_artifact` after completing code review and verification\n4. Move ticket to Human in the Loop using `move_ticket_column` (only if QA passes)\n\n**CRITICAL:** Artifact verification is the first and mandatory step. If you cannot verify artifacts exist (API failure), the ticket fails QA. Do not skip this step or proceed with code review when verification fails.\n\nSee `.cursor/rules/qa-audit-report.mdc` for full workflow.\n\n## Documentation\n\nSee `docs/process/hal-tool-call-contract.mdc` for detailed documentation.\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent"
      ],
      "topicId": "agent-supabase-api-paradigm",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "conversation-protocol.mdc",
      "name": "conversation protocol",
      "description": "Conversation protocol (one question when input needed)",
      "alwaysApply": true,
      "content": "# Conversation Protocol\n\n- You may do as much work as needed per message.\n- When you need user input, you may ask **at most one** question in that message.\n- Do not bundle multiple questions; spread them across messages.\n- When the user provides a new agent rule, record it in `.cursor/rules/` at the workspace root (not inside individual project folders).\n- After updating any rule file(s), explicitly state **which** `.cursor/rules/*.mdc` file(s) were updated.\n- **When starting a ticket:** your **ABSOLUTE FIRST action** (before reading the ticket, before any file edits, before creating a branch) is to:\n  1. **MANDATORY: Read existing artifacts first** - This is non-negotiable. See **auditability-and-traceability**: Implementation Agent: First Step.\n     - Read `.hal/api-base-url` and call `POST ${baseUrl}/api/artifacts/get` with `{ ticketId: \"<ticket-id>\" }`\n     - **CRITICAL:** Check for QA reports with FAIL verdicts - read them completely to understand what went wrong\n     - **CRITICAL:** Check for Human in the Loop failures in QA reports - read them completely to understand what failed in user testing\n     - Review all existing implementation artifacts to understand previous work\n     - **DO NOT skip this step** - Tickets often fail QA multiple times or fail Human in the Loop validation, and you must understand the failure context\n  2. Run `git status -sb` and create/checkout `ticket/<id>-<short-title-kebab>` if not already on it. FORBIDDEN: editing files on `main`. See **change-ownership-and-staging-discipline**: FIRST.\n- **When you have finished a feature/task** (implementation + audit): before sending any summary or \"done\" message, follow **done-means-pushed**: run `git add`, `git commit`, `git push`, then include `git status -sb` in your reply. Do not delegate commit/push to the user.\n",
      "agentTypes": [
        "all",
        "implementation-agent"
      ],
      "topicId": "conversation-protocol",
      "isBasic": true,
      "isSituational": false
    },
    {
      "path": "no-edits-on-main.mdc",
      "name": "no edits on main",
      "description": "Hard gate — never make file edits while on main; branch first",
      "alwaysApply": true,
      "content": "# No Edits on Main (Hard Gate)\n\n## You MUST NOT edit files when on `main`\n\n- **FORBIDDEN:** Using `StrReplace`, `Write`, `EditNotebook`, or any tool that modifies files when the current Git branch is `main`.\n- **Before any file-modifying action** for a ticket or implementation task:\n  1. Run `git status -sb` (or equivalent) and note the **current branch**.\n  2. If the current branch is **`main`** (or `master`):\n     - **STOP.** Do **not** run `StrReplace`, `Write`, or `EditNotebook`.\n     - Create or checkout the feature branch first:  \n       `git checkout -b ticket/<id>-<short-title-kebab>`  \n       (or `git checkout ticket/<id>-...` if it already exists).\n     - Only **after** you are on the feature branch may you make edits.\n  3. If the user did **not** give a ticket ID, ask for it or infer it from context (e.g. from the ticket file they referenced). The branch name is `ticket/<id>-<short-title-kebab>`.\n\n## Why this rule exists\n\n- Edits on `main` conflate work with other changes, get lost on reset/rebase, and violate the repo’s branching policy.\n- QA merges from feature branches; work on `main` bypasses that flow and cannot happen.\n\n## Summary\n\n- **On `main` → no file edits.** Branch first, then edit.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "no-edits-on-main",
      "isBasic": true,
      "isSituational": false
    }
  ],
  "situational": [
    {
      "path": "auditability-and-traceability.mdc",
      "name": "auditability and traceability",
      "description": "Auditability and traceability requirements for all agent work",
      "alwaysApply": true,
      "content": "# Auditability (Always On)\n\nFor any coding task assigned to an implementation agent, the work must be **fully auditable**.\n\n## Implementation Agent: First Step (MANDATORY - DO THIS FIRST)\n\n**CRITICAL: This is the ABSOLUTE FIRST action when picking up a ticket. Do this BEFORE reading the ticket, BEFORE creating a branch, BEFORE any file edits.**\n\n**FORBIDDEN:** Starting implementation work without first checking for existing artifacts. This step is non-negotiable.\n\n### Step-by-Step Checklist (MUST COMPLETE IN ORDER):\n\n**Step 1: Fetch all existing artifacts**\n- Read `.hal/api-base-url` file to get the HAL base URL\n- Call HAL API: `POST ${baseUrl}/api/artifacts/get` with `{ ticketId: \"<ticket-id>\" }`\n- If API call fails (404, 500, network error, timeout), note the failure but proceed with caution\n- If API call succeeds, you will receive an array of artifacts\n\n**Step 2: Check for QA reports and Human in the Loop failures (CRITICAL)**\n- Filter artifacts to find QA reports: `agent_type === \"qa\"` and title matching `QA report for ticket <ticket-id>`\n- **If a QA report exists:**\n  - **READ IT IMMEDIATELY** - Do not skip this\n  - Check the verdict: Look for \"QA RESULT: FAIL\" or \"QA RESULT: PASS\" in the report\n  - **Check for Human validation failure:** Look for \"Human validation failure\" section in the report\n  - **If verdict is FAIL:**\n    - Read the entire QA report carefully\n    - Identify all blocking issues listed\n    - Understand what fixes are required\n    - Understand why the previous implementation failed\n    - **DO NOT repeat the same mistakes**\n    - **DO NOT start coding until you understand the failure context**\n  - **If Human validation failure section exists:**\n    - Read the entire QA report carefully, including the Human validation failure section\n    - Identify all issues that caused the Human in the Loop failure\n    - Understand what fixes are required based on the failure notes\n    - Understand why the previous implementation failed human validation\n    - **DO NOT repeat the same mistakes**\n    - **DO NOT start coding until you understand the failure context**\n- **If no QA report exists:** This may be a fresh ticket (proceed to Step 3)\n\n**Step 3: Review existing implementation artifacts (if any)**\n- Look for implementation artifacts (`agent_type === \"implementation\"`)\n- Read these artifacts to understand:\n  - **Plan artifact:** What approach was previously taken\n  - **Worklog artifact:** What was actually done\n  - **Changed Files artifact:** What files were changed\n  - **Decisions artifact:** What trade-offs/assumptions were made\n  - **Verification artifact:** What issues were identified during verification\n  - **PM Review artifact:** What potential failures were identified\n\n**Step 4: Synthesize understanding**\n- If the ticket has failed QA before:\n  - Document in your Plan artifact that you are addressing previous QA failures\n  - List the specific issues you will fix\n  - Explain how your approach addresses the previous failures\n- If the ticket has failed Human in the Loop validation before:\n  - Document in your Plan artifact that you are addressing previous Human in the Loop failures\n  - List the specific issues you will fix based on the Human validation failure notes\n  - Explain how your approach addresses the previous failures\n- If the ticket has been worked before but passed QA:\n  - Understand what was done and build on it appropriately\n- If this is a fresh ticket:\n  - Proceed with normal implementation\n\n**Step 5: Only after completing Steps 1-4, proceed with:**\n- Creating/checking out the feature branch (see **change-ownership-and-staging-discipline**)\n- Reading the ticket content (if not already reviewed)\n- Creating a new Plan artifact (or updating if continuing previous work)\n\n### Why This Matters\n\n- **Tickets often fail QA multiple times** - The same ticket may have been worked by previous agents who made mistakes\n- **Tickets often fail Human in the Loop validation** - Even after passing QA, tickets can fail when users test them in the UI\n- **QA reports contain critical information** - They tell you exactly what was wrong and what needs to be fixed\n- **Human validation failure notes contain critical information** - They tell you exactly what failed in user testing and what needs to be fixed\n- **Repeating mistakes wastes time** - Understanding previous failures prevents you from making the same errors\n- **Building on previous work** - If work was partially completed, you should understand what was done before\n\n### Warning Signs You Skipped This Step\n\nIf you find yourself:\n- Starting to code without checking artifacts first\n- Creating a Plan artifact without mentioning previous QA failures or Human in the Loop failures\n- Implementing features that were already identified as problematic in a QA report\n- Making the same mistakes that caused a previous QA failure\n- Making the same mistakes that caused a previous Human in the Loop failure\n\n**STOP and go back to Step 1.**\n\n## Standard Prompt Format (Supabase source of truth)\n\n- All new stories/tasks must be **tickets** stored in **Supabase** (source of truth). **Do not create or edit ticket files** under `docs/tickets/` directly; tickets are created via the HAL app (PM agent) or a script that writes to the Supabase `tickets` table. The app uses Supabase-only mode (0065) and does not read from `docs/tickets/*.md`.\n- **Kanban is Supabase-backed (Supabase-only mode, 0065).** For any ticket change (create, update body, move column): **update the DB directly via HAL API**. The Kanban UI reflects changes within the polling interval (~10s). Use `POST /api/tickets/move` for column moves. Never update ticket files locally — the app does not read them.\n- Use the workspace template for **content structure** when creating a ticket (in-app or via script):\n  - `docs/templates/ticket.template.md`\n- The ticket in Supabase (and, after sync, in `docs/tickets/<task-id>-<short-title>.md`) is the canonical \"prompt\" (we do **not** create a `prompt.md` artifact).\n\n## Task ID Convention (Uniqueness)\n\n- Task IDs must be **sequential numbers**, zero-padded to 4 digits (e.g. `0001`, `0002`, ...).\n- Task IDs must remain **globally unique** within this workspace; they will be used as keys later.\n\n## Required Artifacts (per task)\n\n**MANDATORY:** All artifacts are stored in **Supabase's `agent_artifacts` table**, not in `docs/audit/` folders. \n\n**FORBIDDEN:** Creating, writing, or editing files in `docs/audit/` directories. Artifacts must be stored in Supabase only via tool calls.\n\nUse HAL API endpoints (tool calls) to store artifacts:\n\n- Ticket in Supabase (not `docs/tickets/*.md` — Supabase-only mode, 0065)\n  - Canonical ticket used to brief the implementation agent (includes acceptance criteria). Fetch using tool call `get_ticket_content`.\n- **Plan artifact** (agent_type: `implementation`, title: `Plan for ticket <ticket-id>`)\n  - 3–10 bullets: intended approach and file touchpoints.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"plan\"`\n- **Worklog artifact** (agent_type: `implementation`, title: `Worklog for ticket <ticket-id>`)\n  - Timestamped (rough) notes of what was done, in order.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"worklog\"`\n- **Changed Files artifact** (agent_type: `implementation`, title: `Changed Files for ticket <ticket-id>`)\n  - List of files created/modified/deleted with 1–2 line purpose each.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"changed-files\"`\n- **Decisions artifact** (agent_type: `implementation`, title: `Decisions for ticket <ticket-id>`)\n  - Any trade-offs/assumptions + why.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"decisions\"`\n- **Verification artifact** (agent_type: `implementation`, title: `Verification for ticket <ticket-id>`)\n  - QA verification steps: code review + automated checks (build, lint). No manual UI testing at QA stage — user tests in Human in the Loop after merge.\n  - **MANDATORY:** Must include TypeScript compilation check: run `npm run build:hal` (or `tsc -b`) and verify it completes with **zero TypeScript errors**. If TypeScript errors exist, the implementation is **NOT ready** and must be fixed before claiming \"ready for QA\".\n  - If verification involves visuals, include screenshot filenames.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"verification\"`\n- **PM Review artifact** (agent_type: `implementation`, title: `PM Review for ticket <ticket-id>`)\n  - Likelihood of success (0–100%), potential failures, and how to diagnose them.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"pm-review\"`\n- **Git diff artifact** (agent_type: `implementation`, title: `Git diff for ticket <ticket-id>`)\n  - Full unified git diff of all changes for this ticket.\n  - Generate using: `git diff main...HEAD` (or `git diff main` if on feature branch) to get all changes.\n  - If no changes exist or diff is empty, include a message explaining why (e.g., \"No changes detected\" or \"All changes already merged\").\n  - The diff should be in unified diff format and will be displayed with syntax highlighting in the UI.\n  - Store via tool call: `insert_implementation_artifact` with `artifactType: \"git-diff\"`\n- **QA Report artifact** (agent_type: `qa`, title: `QA report for ticket <ticket-id>`)\n  - Created by QA agent after code review and verification.\n  - Store via tool call: `insert_qa_artifact`\n\n## Artifact Format: Source of Truth (No \"Copy From Old Audits\")\n\n- The source of truth for artifact **format and required files** is:\n  - `.cursor/rules/*.mdc` (workspace rules)\n  - `docs/templates/ticket.template.md`\n  - `docs/process/ticket-verification-rules.md`\n- Do **not** determine artifact format by inspecting prior artifacts in Supabase.\n  - You may reference older artifacts only as **examples** after you have already checked the rules/templates.\n  - Avoid narration like \"Checking an existing artifact for format\"; instead confirm you are following the rules/templates above.\n\n## QA (Commit + Push → Human in the Loop)\n\n- An implementation agent must **commit** all work for the ticket and **push** it to the remote before claiming the ticket is \"done\" or \"ready for verification.\"\n- \"Ready for verification\" additionally requires a **clean + synced repo**:\n  - working tree is clean (no uncommitted changes, no untracked files created by the task)\n  - branch is synced with remote (not ahead/behind)\n- \"Ready for verification\" must happen on a **feature branch** (not `main`) for ticketed work.\n- If any untracked/modified files remain, the agent must either:\n  - commit them (if they belong to the ticket), or\n  - delete/ignore/revert them (if they are accidental/generated), before claiming \"ready.\"\n- The ticket must exist in **Supabase** (Supabase-only mode, 0065):\n  - Ticket must exist in Supabase. `docs/tickets/*.md` files are not used by the app.\n\n- \"Ready for verification\" instructions must be **UI-only**:\n  - Do not ask the user/PM to commit, push, or otherwise \"finish\" the task.\n  - If the agent still needs to commit/push or store artifacts, the task is **not** ready.\n\n- The completion message to the user/PM must include:\n  - the **feature branch name** (so QA can review and merge), and\n  - the exact `git status -sb` output.\n- The implementation agent **must add the branch name to the ticket** when claiming \"ready for QA\" (see ticket template: QA → Branch).\n- The implementation agent **must store all 7 required artifacts in Supabase** when marking ready for QA (see \"Required Artifacts\" above).\n- The implementation agent **must move the ticket to QA column** (`col-qa`) via HAL API (`POST /api/tickets/move` with `{ ticketId: \"<id>\", columnId: \"col-qa\" }`) when marking ready for QA. **FORBIDDEN:** Claiming \"ready\" without moving the ticket to QA column. \n  - **Storage method:** Call HAL API directly (`POST ${baseUrl}/api/artifacts/insert-implementation`) or write to `.hal-tool-call-queue.json`.\n  - **Verification:** After storing, call `/api/artifacts/get` to verify all 7 artifacts are present. If any are missing, store them again.\n  - **FORBIDDEN:** Claiming \"ready\" without verifying all artifacts are stored. QA will fail tickets with missing artifacts.\n\n- Artifacts must be **stored in Supabase**:\n  - All artifacts must be stored via tool calls before claiming \"ready.\"\n  - **Required:** Call the HAL API directly (e.g. `POST ${baseUrl}/api/artifacts/insert-implementation`) so artifacts appear immediately. The `.hal/api-base-url` file must be present. See `.cursor/rules/agent-supabase-api-paradigm.mdc`.\n  - Artifacts are linked to tickets via `ticket_pk` in the `agent_artifacts` table.\n\n## PM Review is required before \"ready\"\n\n- Before claiming \"ready for verification,\" the agent must ensure:\n  - PM Review artifact exists in Supabase (stored via `POST /api/artifacts/insert-implementation`),\n  - and it reflects the actual implementation state (no placeholders).\n\n## Commit message linkage (no commit hashes in docs)\n\n- Every commit that belongs to a ticket must include the ticket ID in the commit subject (e.g. `feat(0010): ...`, `fix(0008): ...`, `docs(0009): ...`).\n- This includes \"supporting\" commits that are still part of delivering the ticket (examples: `chore`, `docs(rules)`, submodule pointer updates, dependency updates).\n- If a commit is **not** part of the ticket, it must be:\n  - separated (not bundled into the ticket's commits), and\n  - documented in the ticket's Decisions artifact under **Unrequested changes (required)** if it was unavoidable.\n \nNote: Workspace-wide, the definition of \"done\" for **all agents** is enforced by `.cursor/rules/done-means-pushed.mdc`.\n\n## In-App Trace Requirement\n\n- Any meaningful state change performed by the app should be visible in an **in-app debug/diagnostics UI** (not the console).\n- Errors should have an in-app representation suitable for a non-technical verifier.\n\n## Scope\n\n- **All artifacts are stored in Supabase**, not in `docs/audit/` folders.\n- **FORBIDDEN:** Writing artifact files to `docs/audit/` directories. Use tool calls to store in Supabase.\n- Keep each artifact concise; prefer bullets over prose.\n\n## PM Review Artifact (after implementation completes)\n\n- Store PM Review artifact in Supabase via tool call `insert_implementation_artifact` with `artifactType: \"pm-review\"`.\n- Use format from `docs/templates/pm-review.template.md` as reference.\n- The PM review must include:\n  - **likelihood of success** (0–100%)\n  - a ranked list of **potential failures** and how to diagnose them using **in-app** diagnostics\n\n## HAL Tool Call Contract\n\nAll artifact and ticket operations are sent to HAL as **tool calls** in your messages. HAL parses and executes them automatically.\n\n**Available tools:**\n\n- **`insert_implementation_artifact`** — Store implementation artifact\n  - Params: `{ ticketId: string, artifactType: string, title: string, body_md: string }`\n\n- **`insert_qa_artifact`** — Store QA artifact\n  - Params: `{ ticketId: string, title: string, body_md: string }`\n\n- **`get_ticket_content`** — Fetch ticket content\n  - Params: `{ ticketId: string }`\n\n- **`update_ticket_body`** — Update ticket body\n  - Params: `{ ticketId: string, body_md: string }`\n\n- **`move_ticket_column`** — Move ticket to different column\n  - Params: `{ ticketId: string, columnId: string }`\n\n**How to use:** Include tool calls as JSON blocks in your messages. HAL will parse and execute them. You don't need API URLs or credentials.\n\n**Example:**\n```\nI've completed the plan. Here's my tool call:\n\n{\n  \"tool\": \"insert_implementation_artifact\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"artifactType\": \"plan\",\n    \"title\": \"Plan for ticket 0076\",\n    \"body_md\": \"# Plan\\n\\n...\"\n  }\n}\n```\n\nSee `.cursor/rules/agent-supabase-api-paradigm.mdc` for full documentation.\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "auditability-and-traceability",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Auditability and Traceability",
        "description": "Requirements for fully auditable agent work, including mandatory artifact checking",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "artifacts",
          "audit",
          "traceability",
          "qa reports",
          "human in the loop"
        ]
      }
    },
    {
      "path": "bugfix-tracking.mdc",
      "name": "bugfix tracking",
      "description": "Track QA failures and bugfix follow-ups",
      "alwaysApply": true,
      "content": "# Bugfix Tracking (QA Failures + Follow-ups)\n\n## When QA fails\n\n- If a ticket is “done” but fails QA, create a **new bugfix ticket** (next sequential ID) **in Supabase** (via the HAL app PM agent or a script that inserts into the `tickets` table). Do not write a new ticket file in `docs/tickets/`; run `npm run sync-tickets` after creating in Supabase so the change propagates to docs.\n- The bugfix ticket must include:\n  - **Fixes**: the original ticket ID (e.g. `Fixes: 0007`)\n  - **QA failure summary**: what failed, in human terms\n  - **Category**: pick one: `DnD`, `State`, `CSS`, `Build`, `Process`, `Other`\n\n## Why\n\n- We want a clear, auditable trail of problem points (what keeps breaking and why).\n",
      "agentTypes": [
        "all",
        "project-manager"
      ],
      "topicId": "bugfix-tracking",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Bugfix Tracking",
        "description": "Creating bugfix tickets when QA fails",
        "agentTypes": [
          "qa-agent"
        ],
        "keywords": [
          "bugfix",
          "qa failure",
          "tickets"
        ]
      }
    },
    {
      "path": "build-config-hygiene.mdc",
      "name": "build config hygiene",
      "description": "Prevent generated config files (vite.config.js) from appearing",
      "alwaysApply": true,
      "content": "# Build/Config Hygiene (Prevent “mystery” generated files)\n\n## Vite config source of truth\n\n- This workspace should have **one** Vite config: `vite.config.ts`.\n- Do not create or keep `vite.config.js` alongside it.\n\n## TypeScript build must not emit configs\n\n- `tsconfig.node.json` must include `\"noEmit\": true`.\n  - Reason: `tsc -b` should typecheck; it must not compile `vite.config.ts` into `vite.config.js`.\n\n## Ready-for-verification cleanliness\n\n- Before claiming “ready for verification,” ensure the working tree is clean and there is **no untracked `vite.config.js`**.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "build-config-hygiene",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Build/Config Hygiene",
        "description": "Preventing mystery generated files and config issues",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "build",
          "config",
          "vite",
          "typescript"
        ]
      }
    },
    {
      "path": "change-ownership-and-staging-discipline.mdc",
      "name": "change ownership and staging discipline",
      "description": "Prevent committing unrelated changes; staging and ownership discipline",
      "alwaysApply": true,
      "content": "# Change Ownership + Staging Discipline\n\n## GATE: No edits on main (see also no-edits-on-main.mdc)\n\n- **Before using StrReplace, Write, or EditNotebook** for a ticket: run `git status -sb`. If the current branch is **`main`**, you **must not** make any file edits. Create or checkout the feature branch first, then edit.\n- **FORBIDDEN:** Implementing ticket work on `main` or any branch other than the ticket's feature branch. This is non-negotiable.\n\n## FIRST: Create feature branch before any edits (mandatory)\n\n- **BEFORE making your first edit** for a ticket, you MUST be on the correct feature branch.\n- **Required first action** when implementing a ticket (before touching any file):\n  1. Run `git status -sb`. Note the current branch.\n  2. Derive the feature branch name: `ticket/<id>-<short-title-kebab>` (e.g. ticket 0030 → `ticket/0030-ticket-list-add-delete-button-and-sync-deletion-to-filesystem`).\n  3. If the current branch is **not** that feature branch (including if it is `main`):\n     - Run `git checkout -b ticket/<id>-<short-title-kebab>` (or `git checkout ticket/<id>-...` if it already exists).\n     - Do this **before** any file edits.\n- **Why:** Edits on `main` conflate your work with others'; they can be lost if the tree is reset; they violate the branching policy. Branch first, then edit.\n\n## Only commit what your ticket changes\n\n- An agent must only commit changes that belong to the **current ticket** they are implementing.\n- **FORBIDDEN:** bundling unrelated file changes into the ticket commit (including stray edits, formatting passes, or leftover untracked files).\n\n## Concurrency safety (assume other agents may be running)\n\n- Always assume **another agent might be editing files in parallel** in the same repo.\n- **FORBIDDEN:** touching, restoring, staging, committing, or deleting files you did not personally change in the current task.\n  - Do **not** “clean up” other agents’ work-in-progress.\n  - Do **not** run broad commands that can affect unrelated files (examples: `git add .`, `git add -A`, `git restore .`, `git checkout .`, mass-formatting).\n  - Do **not** run `git stash` (or `git stash -u`) on the whole working tree unless you are certain no other agent has uncommitted work there — stashing removes uncommitted changes from the working tree; if another agent was implementing a ticket on a feature branch but had not yet committed, their code would exist only in the stash and can be lost.\n- If you need a clean place to work while the main working tree is dirty, use a **git worktree** so your changes are isolated.\n\n## Staging discipline (required)\n\nBefore committing ticket work:\n\n- Review `git diff` and `git status` and ensure every changed file is expected.\n- Stage only the intended files (explicit `git add <paths>`).\n- If any unrelated changes exist:\n  - revert them, delete them, or move them into a **separate ticket/branch**.\n\n## Do not “fix someone else’s work” inside a ticket\n\n- If you discover a problem outside the ticket scope (including process cleanup), do **not** fold it into the ticket.\n- Create a new ticket via the **HAL app** (PM agent) or HAL API, then fix it on its own branch. Do not write a ticket file in `docs/tickets/`; tickets are created only in Supabase. For column/status moves, use HAL API endpoint `POST /api/tickets/move` — do not edit ticket frontmatter by hand.\n\n## Branching requirement (ties to done-means-pushed)\n\n- Ticket work must be performed on `ticket/<id>-<short-title-kebab>` branches.\n- Do not commit ticket work directly on `main`.\n- If you discover you implemented on `main`: create the feature branch, then `git checkout -b ticket/<id>-...` — uncommitted changes will move with you. Commit on the feature branch.\n",
      "agentTypes": [
        "all",
        "project-manager"
      ],
      "topicId": "change-ownership-and-staging-discipline",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Change Ownership + Staging Discipline",
        "description": "Branching, staging, and commit discipline requirements",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "branch",
          "staging",
          "commit",
          "feature branch"
        ]
      }
    },
    {
      "path": "delete-branch-after-merge.mdc",
      "name": "delete branch after merge",
      "description": "Delete feature branch after merge to main",
      "alwaysApply": true,
      "content": "# Delete Branch After Merge to Main\n\n- **After** a feature branch is merged into `main`, **delete that feature branch** (local and remote).\n- This keeps the repo tidy and makes it clear which branches are still in progress.\n\n## Who does it\n\n- **Whoever performs the merge** (QA, user, or agent when explicitly asked to merge) must delete the branch after merging.\n- If you merge a branch into `main` (e.g. `ticket/0012-...` or `feat/...`), run:\n  - `git branch -d <branch-name>` (local delete; use `-D` only if needed)\n  - `git push origin --delete <branch-name>` (remote delete)\n- If you use a pull request / merge on the host (e.g. GitHub), use the host’s “Delete branch” option after the merge.\n\n## Branch naming\n\n- Feature branches: `ticket/<id>-<short-title-kebab>` or `feat/...`.\n- Do not delete `main` or long-lived branches that are not feature branches.\n\n## Summary\n\n- Merge to `main` → then delete the merged feature branch (local + remote).\n- Prevents accumulation of stale branch names and clarifies what’s still open.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "delete-branch-after-merge",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Delete Branch After Merge",
        "description": "Branch cleanup after merging to main",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "branch",
          "merge",
          "cleanup"
        ]
      }
    },
    {
      "path": "done-means-pushed.mdc",
      "name": "done means pushed",
      "description": "\"Done\" requires commit + push (all agents)",
      "alwaysApply": true,
      "content": "# “Done” Means Committed + Pushed (All Agents)\n\n- **FORBIDDEN:** Sending a \"done\" or summary message while the working tree has uncommitted/unpushed changes. Commit and push first; then summarize.\n\n## Implementation Agent Completion Checklist (MANDATORY)\n\n**Before sending ANY summary message, verify ALL of these are complete:**\n\n- [ ] Code implemented and tested\n- [ ] **TypeScript compilation passes with zero errors** — Run `npm run build:hal` (or `tsc -b`) and verify it completes successfully. **NON-NEGOTIABLE:** TypeScript errors are blocking. Fix all TypeScript errors before proceeding.\n- [ ] **Build succeeds** — Run `npm run build:hal` and verify the build completes without errors. This ensures Vercel deployments will succeed.\n- [ ] All changes committed to feature branch (with ticket ID in commit message)\n- [ ] Feature branch pushed to remote\n- [ ] **All 7 artifacts stored in Supabase** (plan, worklog, changed-files, decisions, verification, pm-review, git-diff)\n- [ ] **Artifacts verified** via `/api/artifacts/get` - all 6 present\n- [ ] Feature branch merged to `main`\n- [ ] `main` pushed to remote\n- [ ] Feature branch deleted (local and remote)\n- [ ] HAL dev server restarted on latest `main`\n- [ ] Ticket body updated with branch name and merge confirmation\n- [ ] **Ticket moved to QA column** via HAL API (`POST /api/tickets/move` with `{ ticketId: \"<id>\", columnId: \"col-qa\" }`)\n- [ ] `git status -sb` shows clean working tree on `main`\n\n**Only after ALL items are checked may you send a summary message.**\n\n## Start of task: feature branch first (prevents lost work)\n\n- **MANDATORY:** Before making **any** file changes for a ticket, create/checkout the feature branch. This is non-negotiable. See also **no-edits-on-main.mdc**.\n- **Required first step** (before the first edit):\n  1. Run `git status -sb`. Note the current branch.\n  2. If you are on **`main`**: do **not** use StrReplace, Write, or EditNotebook. Run `git checkout -b ticket/<id>-<short-title-kebab>` (or `git checkout ticket/<id>-...` if it exists remotely) first.\n  3. Feature branch name: `ticket/<id>-<short-title-kebab>` (e.g. ticket 0030 → `ticket/0030-ticket-list-add-delete-button-and-sync-deletion-to-filesystem`).\n  4. Only after you are on the feature branch may you edit files.\n- **FORBIDDEN:** Implementing ticket work on `main`. If you realize you edited on `main`: run `git checkout -b ticket/<id>-...` — uncommitted changes move with you; commit on the feature branch.\n- **Why:** Edits on `main` conflate work, can be lost on stash/reset, and violate branching policy. Branch first.\n\n## Branching policy (feature branches required)\n\n- For ticketed work, agents must work on a **feature branch**, not directly on `main`.\n  - Branch naming: `ticket/<id>-<short-title-kebab>` (example: `ticket/0003-hal-chat-hal-agents`).\n- “Ready / done” requires:\n  - the feature branch is **pushed** to remote, and\n  - `git status -sb` shows the branch is **synced** and the working tree is **clean**.\n\n\n QA performs code review + automated verification (no manual UI testing), then merges to main and moves the ticket to Human in the Loop for user testing. The implementation agent must add the branch name to the ticket (see ticket template), then may claim “ready/done.”\n\n## Cloud QA branch access limitation (implementation agent workflow)\n\n- **Scenario:** Implementation cloud agent can create/push a feature branch, but the separate QA cloud agent **cannot access non-`main` branches** (e.g., due to cloud environment restrictions). This is the standard workflow for cloud agents.\n- **When ready for QA:** The implementation agent must:\n  1. **Run `npm run build:hal` (or `tsc -b`) and verify it completes with zero TypeScript errors**. **NON-NEGOTIABLE:** TypeScript errors are blocking. Fix all TypeScript errors before proceeding.\n  2. Verify the feature branch is clean and pushed to remote.\n  3. **Store all required artifacts in Supabase** by including tool calls in your message:\n     ```json\n     {\n       \"tool\": \"insert_implementation_artifact\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"artifactType\": \"plan\",\n         \"title\": \"Plan for ticket 0076\",\n         \"body_md\": \"# Plan\\n\\n...\"\n       }\n     }\n     ```\n     (Repeat for each required artifact: plan, worklog, changed-files, decisions, verification, pm-review, git-diff)\n  4. **Merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0056): merge feature branch to main for cloud QA access`).\n  5. Push `main` to remote.\n  6. **Kill HAL** (`npx --yes kill-port 5173 5174`), **pull from main** (`git pull origin main`), **restart HAL** (`npm run dev` in background).\n  7. **Update the ticket body** by including a tool call in your message:\n     ```json\n     {\n       \"tool\": \"update_ticket_body\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"body_md\": \"# Updated ticket body with branch name, merge note, etc.\"\n       }\n     }\n     ```\n  8. Mark the ticket as \"Merged to main for QA\" (add this note to the ticket body).\n  9. **Move the ticket to QA column** by including a tool call in your message:\n     ```json\n     {\n       \"tool\": \"move_ticket_column\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"columnId\": \"col-qa\"\n       }\n     }\n     ```\n  10. Then send the completion/summary message including the branch name, merge note, and `git status -sb`.\n- **Why:** Cloud QA agents may only have access to `main` branch. Merging to `main` makes the changes accessible for QA review and testing.\n\n## Artifacts storage requirement (implementation agent)\n\n**MANDATORY:** The implementation agent **must** store all 7 required artifacts in Supabase **before** claiming the ticket is \"ready for QA\" or \"done\". This is non-negotiable.\n\n- **When marking a ticket ready for QA:** The implementation agent **must** store all required artifacts in Supabase by sending tool calls in your messages.\n- **Required artifacts** (all stored via tool call `insert_implementation_artifact`):\n  - Plan (`artifactType: \"plan\"`, title: `Plan for ticket <ticket-id>`)\n  - Worklog (`artifactType: \"worklog\"`, title: `Worklog for ticket <ticket-id>`)\n  - Changed Files (`artifactType: \"changed-files\"`, title: `Changed Files for ticket <ticket-id>`)\n  - Decisions (`artifactType: \"decisions\"`, title: `Decisions for ticket <ticket-id>`)\n  - Verification (`artifactType: \"verification\"`, title: `Verification for ticket <ticket-id>`)\n  - PM Review (`artifactType: \"pm-review\"`, title: `PM Review for ticket <ticket-id>`)\n  - Git diff (`artifactType: \"git-diff\"`, title: `Git diff for ticket <ticket-id>`)\n- **Storage method:** \n  - **Preferred:** If `.hal/api-base-url` exists, call HAL API directly: `POST ${baseUrl}/api/artifacts/insert-implementation` for each artifact.\n  - **Fallback:** Write tool calls to `.hal-tool-call-queue.json` in the repo root.\n- **Verification:** After storing artifacts, verify they were stored by calling `/api/artifacts/get` with the ticket ID. If any artifact is missing, store it again before claiming \"ready\".\n- **FORBIDDEN:** Claiming \"ready for QA\", \"done\", or \"complete\" without storing all 7 required artifacts. QA will fail tickets with missing artifacts.\n- **Why:** All artifacts are stored in Supabase's `agent_artifacts` table and linked to the ticket via `ticket_pk`. The Kanban UI can display these artifacts, making work fully auditable without requiring access to the repo structure. QA agents **will fail** tickets that are missing artifacts.\n\n## Sequence: push first, merge to main, then summarize\n\n- The moment you **think** you're done (implementation complete, audit written, etc.) is when you **verify TypeScript compilation and build** — not after you've already told the user.\n- **First:** **Run `npm run build:hal` (or `tsc -b`) and verify it completes with zero TypeScript errors**. **NON-NEGOTIABLE:** TypeScript errors are blocking. Fix all TypeScript errors before proceeding. Then commit all relevant changes, **push the feature branch** to GitHub, **merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0060): merge feature branch to main`), push `main`, **delete the feature branch** (local and remote).\n- **After merge, before summarizing (implementation agent):** After merging to `main` and pushing `main`, and before updating the ticket body or sending the summary message:\n  1. **Kill HAL:** Stop the dev server (e.g. `npx --yes kill-port 5173 5174` to free HAL and Kanban ports).\n  2. **Pull from main:** Run `git pull origin main` (you should already be on `main`).\n  3. **Restart HAL:** Run `npm run dev` (in the background or in a dev terminal) so the app is running the latest `main`.\n- Then **update the ticket body** by including a tool call in your message to update the ticket with the branch name, merge note, and a note that all artifacts are stored in Supabase.\n- **Move the ticket to QA column** by including a tool call in your message:\n  ```json\n  {\n    \"tool\": \"move_ticket_column\",\n    \"params\": {\n      \"ticketId\": \"<ticket-id>\",\n      \"columnId\": \"col-qa\"\n    }\n  }\n  ```\n- **Then:** tell the user what was done (summary, verification, audit location, **branch name**). Do not give the long \"here's what I did\" report until after push + merge + branch deletion + HAL restart + ticket update + ticket move.\n- **MANDATORY:** Always merge to main and delete the feature branch before sending any summary message. This applies to all implementation work, not just cloud QA scenarios.\n- If you summarize first and then commit/push/merge (or forget to add the branch to the ticket), you did it in the wrong order.\n\n## Before you reply: the gate\n\n- **If you are about to send a message** that summarizes completed work, or that includes any of: \"done\", \"complete\", \"ready\", \"looks good\", \"here's what I did\", \"Implementation complete\", \"Summary:\", or similar — **STOP**.\n- **First** run: `git status -sb`. If there are any `M` (modified) or `??` (untracked) relevant to the task: **run `npm run build:hal` (or `tsc -b`) and verify it completes with zero TypeScript errors**. **NON-NEGOTIABLE:** If TypeScript errors exist, fix them before proceeding. Then run `git add`, `git commit -m '...'` (with ticket ID in subject), `git push` (feature branch), **store all 7 required artifacts in Supabase** by calling HAL API directly or writing to queue file, **verify artifacts were stored** by calling `/api/artifacts/get`, then **merge the feature branch into `main`** (with a commit message that includes the ticket ID, e.g., `merge(0060): merge feature branch to main`), push `main`, **delete the feature branch** (local and remote). Then **kill HAL** (`npx --yes kill-port 5173 5174`), **pull from main** (`git pull origin main`), **restart HAL** (`npm run dev` in background), **update the ticket body** by including a tool call in your message with the branch name, merge note, and a note that all artifacts are stored in Supabase, and **move the ticket to QA column** by including a tool call in your message with `{ ticketId: \"<id>\", columnId: \"col-qa\" }`. Then run `git status -sb` again.\n- **Only after** the working tree is clean, **all 7 required artifacts are verified as stored in Supabase** (via `/api/artifacts/get`), the feature branch is merged to main, the branch is deleted, HAL has been restarted on latest main, the **branch name is added to the ticket**, and the **ticket is moved to QA column** may you send that message — and your message **must** include the **branch name** and the exact `git status -sb` output.\n- **CRITICAL:** If artifact storage or verification fails, do **not** claim \"ready\" or \"done\". Fix the artifact storage issue first. QA will fail tickets with missing artifacts.\n- **MANDATORY:** Always merge to main and delete the feature branch before sending any summary message. Never send a summary while still on a feature branch.\n- If you have not yet committed, pushed, merged to main, and deleted the branch, do **not** send a \"done\" or summary message; do all of these steps in this same turn, then reply.\n\n## Requirements\n\n- If any agent believes a task/story is **done**, they must:\n  - **commit** all relevant changes, and\n  - **push** to the remote\n  before telling the user or project manager that it’s done.\n- Agents must not delegate commit/push work to the user/PM (e.g., “after you commit and push…”).\n  - If commit/push hasn’t happened yet, the correct status is **“not ready for verification.”**\n- “Done/ready” messages must include the **feature branch name** (so QA can check out and verify) and the exact `git status -sb` output showing the branch is synced and the working tree is clean.\n  - “Clean” means: **no modified files** and **no untracked files** (ignored build artifacts are fine).\n\n## Commit message linkage (no commit hashes in docs)\n\n- Every commit that belongs to a ticket must include the ticket ID in the commit subject (e.g. `feat(0010): ...`, `fix(0008): ...`, `docs(0009): ...`).\n- If a ticket requires follow-up commits after an initial “feat/fix” commit, those follow-up commits must also include the same ticket ID in the subject.\n  - Do not “sneak in” ticket work under unlabeled commits like `chore: ...` if it still belongs to the ticket.\n- If `git status -sb` is not clean/synced, the agent must say **“not ready for verification”** and keep working until it is.\n  - Do not claim “ready” if `git status` shows any `??` (untracked) or `M` (modified) entries.\n\n## PM verification\n\n- The project manager’s “done” is only **candidate-complete** until the user verifies the acceptance criteria.\n- Do not use language like “done” or “complete” until changes are committed and pushed.\n",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent",
        "project-manager"
      ],
      "topicId": "done-means-pushed",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Done Means Committed + Pushed",
        "description": "Completion checklist and workflow requirements for implementation agents",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "commit",
          "push",
          "ready",
          "verification",
          "artifacts"
        ]
      }
    },
    {
      "path": "qa-audit-report.mdc",
      "name": "qa audit report",
      "description": "QA agents must store QA reports in Supabase via HAL API",
      "alwaysApply": true,
      "content": "# QA Audit Report (QA Agents)\n\nWhen you **QA a ticket** (e.g. user asks to \"QA\", \"verify\", or \"check\" a ticket that is allegedly complete), you **must** store a QA report in Supabase via HAL's API endpoints.\n\n## Cloud QA workflow context\n\nIn cloud environments, QA agents may not have access to feature branches (only `main`). When this is the case, the implementation agent merges the feature branch to `main` before QA begins. QA must then verify from `main` rather than attempting to check out a feature branch. This workflow is indicated when the ticket states \"merged to `main` for QA access\" or similar language.\n\n## Which branch to use (decision rule)\n\n- **If the ticket or prompt states that the implementation was \"merged to main for QA access\"** (or that code is on `main` for QA): \n  - You **must** verify from the **`main`** branch. \n  - Do **not** attempt to locate, check out, or use the feature branch.\n  - **Step 1:** Pull the latest `main` branch: `git checkout main && git pull origin main`\n  - **Step 2:** Perform QA on `main` (code review and verification).\n  - **Step 3:** Record in the QA report that verification was performed against `main` (e.g. \"Verified on `main`; implementation was merged to main for QA access.\").\n  - **Step 4:** Store the QA report in Supabase via HAL API (see \"Storing QA report\" below).\n  - **Step 5:** Move ticket to Human in the Loop via HAL API, then provide summary.\n- **Otherwise:** use the feature branch named in the ticket's QA → Branch field (or the branch you were launched on). Perform QA on that branch, then follow the full workflow (merge to main, delete branch, etc.).\n\n**Important:** When QA cannot access feature branches (cloud QA workflow), the implementation agent merges the feature branch to `main` before QA. In this case, QA must verify from `main` and record this in the QA report stored in Supabase.\n\n## Required implementation artifacts (must be present before QA)\n\n**MANDATORY:** Before performing any QA work, you **must** verify that all required implementation artifacts are present in Supabase. If any are missing, QA **must fail immediately** without attempting code review or verification.\n\n**Required implementation artifacts:**\n1. **Plan artifact** (`artifactType: \"plan\"`, title: `Plan for ticket <ticket-id>`)\n2. **Worklog artifact** (`artifactType: \"worklog\"`, title: `Worklog for ticket <ticket-id>`)\n3. **Changed Files artifact** (`artifactType: \"changed-files\"`, title: `Changed Files for ticket <ticket-id>`)\n4. **Decisions artifact** (`artifactType: \"decisions\"`, title: `Decisions for ticket <ticket-id>`)\n5. **Verification artifact** (`artifactType: \"verification\"`, title: `Verification for ticket <ticket-id>`)\n6. **PM Review artifact** (`artifactType: \"pm-review\"`, title: `PM Review for ticket <ticket-id>`)\n7. **Git diff artifact** (`artifactType: \"git-diff\"`, title: `Git diff for ticket <ticket-id>`)\n\n**How to check for artifacts:**\n1. **First step (MANDATORY):** Call HAL API endpoint `/api/artifacts/get` with `{ ticketId: \"<ticket-id>\" }` to fetch all artifacts for the ticket.\n   - If `.hal/api-base-url` exists, read it and call: `POST ${baseUrl}/api/artifacts/get`\n   - If API call fails (404, 500, network error, etc.), **QA MUST FAIL** — you cannot verify artifacts exist, so assume they are missing.\n   - **DO NOT proceed with code review if artifact verification fails.**\n2. Filter the returned artifacts to find implementation artifacts (where `agent_type === \"implementation\"`).\n3. Check that all 7 required artifact types are present by matching artifact titles:\n   - `Plan for ticket <ticket-id>`\n   - `Worklog for ticket <ticket-id>`\n   - `Changed Files for ticket <ticket-id>`\n   - `Decisions for ticket <ticket-id>`\n   - `Verification for ticket <ticket-id>`\n   - `PM Review for ticket <ticket-id>`\n   - `Git diff for ticket <ticket-id>`\n\n**Auto-fail when artifacts are missing or unverifiable:**\n- **If artifact API call fails (404, 500, network error, timeout):** QA **must fail immediately**. You cannot verify artifacts exist, so treat as missing.\n- **If any required artifact is missing:** QA **must fail immediately**.\n- **Do NOT** attempt code review, verification, or any other QA work when artifacts cannot be verified or are missing.\n- **Do NOT** attempt to \"guess\" or recreate missing artifacts.\n- **Do NOT** proceed with code review and note \"artifacts couldn't be verified\" — this is a FAIL condition.\n- **Record a QA Fail outcome** by storing a QA report that clearly states the failure reason.\n- **The QA report must enumerate the specific missing artifacts** (or state \"Artifact verification failed: API returned [error]\" if API call failed).\n- **Store the QA report in Supabase** using `insert_qa_artifact` tool (via HAL API or queue file).\n- **Move ticket to To-do** (`col-todo`) via HAL API.\n- **The final message must include:** `QA RESULT: FAIL — <ticket-id>` (see \"Completion message format requirement\" below).\n\n**Example QA report when artifacts are missing:**\n```markdown\n# QA Report for ticket 0076\n\n## Ticket & Deliverable\n[Brief summary from ticket]\n\n## Missing Required Implementation Artifacts\n\n**QA FAILED:** Required implementation artifacts are missing. QA cannot proceed without complete implementation artifacts.\n\n**Missing artifacts:**\n- Plan artifact (`Plan for ticket 0076`)\n- PM Review artifact (`PM Review for ticket 0076`)\n\n**Present artifacts:**\n- Worklog artifact\n- Changed Files artifact\n- Decisions artifact\n- Verification artifact\n\n## Verdict\n\n**FAIL** — Implementation artifacts incomplete. Implementation agent must store all required artifacts before QA can proceed.\n\nQA RESULT: FAIL — 0076\n```\n\n**If all required artifacts are present:** Proceed with normal QA workflow (code review, verification, etc.).\n\n**CRITICAL:** Artifact verification is the **first and mandatory step** of QA. Do not skip it, do not defer it, do not proceed with code review if verification fails. If you cannot verify artifacts exist, the ticket fails QA.\n\n## Required artifact (QA report)\n\n- **Storage:** Supabase `agent_artifacts` table (via HAL API endpoint `/api/artifacts/insert-qa`)\n- **When:** After performing QA (code review and, if possible, UI verification) for a ticket, OR when auto-failing due to missing implementation artifacts.\n- **Agent type:** `qa`\n- **Title format:** `QA report for ticket <ticket-id>`\n\n## QA report structure\n\n1. **Ticket & deliverable** — One-line goal, deliverable, and acceptance criteria from the ticket.\n2. **Missing Required Implementation Artifacts** (if applicable) — List of missing artifacts. If artifacts are missing, this section must be present and QA must fail.\n3. **Audit artifacts** — Confirm all required implementation artifacts are present in Supabase (plan, worklog, changed-files, decisions, verification, pm-review). Only include this section if all artifacts are present.\n4. **Code review** — PASS/FAIL with brief evidence (e.g. table of requirement vs implementation; file and line refs if helpful). Only include if artifacts are present.\n5. **Build verification** — **MANDATORY:** Run `npm run build:hal` (or `tsc -b`) and verify it completes with zero TypeScript errors. If TypeScript errors exist, QA **MUST FAIL** immediately. Document the build result (PASS/FAIL) and any TypeScript errors found. Only include if artifacts are present.\n6. **UI verification** — What was run: automated and/or manual steps. If automated UI was not run (e.g. native dialogs, login, or pickers), state that and list the manual steps the user should run. Only include if artifacts are present.\n7. **Verdict** — Implementation complete? OK to merge? Any blocking manual verification? Must clearly state PASS or FAIL.\n\n## Storing QA report\n\n**Send a tool call to HAL in your message:**\n\nInclude this JSON block in your message:\n\n```json\n{\n  \"tool\": \"insert_qa_artifact\",\n  \"params\": {\n    \"ticketId\": \"0076\",\n    \"title\": \"QA report for ticket 0076\",\n    \"body_md\": \"# QA Report\\n\\n...\"\n  }\n}\n```\n\nHAL will parse this from your message, execute it, and store the artifact in Supabase. You don't need API URLs or credentials - just include the JSON in your message.\n\n## QA completion: do not hand off to the user\n\nWhen the verdict is **PASS (OK to merge)**, QA must **complete the full workflow** — do not stop at a summary or \"next steps for the user.\"\n\n## Completion message format requirement\n\n**MANDATORY:** The final completion message to the user **must** include the ticket ID and an explicit PASS/FAIL outcome token in a consistent, easy-to-spot format.\n\n- **Format:** `QA RESULT: <PASS|FAIL> — <ticket-id>`\n- **Examples:**\n  - `QA RESULT: PASS — 0056`\n  - `QA RESULT: FAIL — 0056`\n- **Placement:** This must appear in the final summary message that QA sends to the user after completing all workflow steps (merge, branch deletion, ticket updates, etc.).\n- **Why:** HAL needs to reliably parse QA outcomes from chat transcripts. The format must be human-verifiable (no external tooling required) and consistently structured for automated interpretation.\n- **Verification:** A human can read the QA chat transcript in the app and immediately see the ticket ID and outcome without parsing complex prose.\n\n**If you are verifying from the feature branch** (normal workflow):\n\n1. **Store QA report in Supabase** — Include a tool call in your message:\n   ```json\n   {\n     \"tool\": \"insert_qa_artifact\",\n     \"params\": {\n       \"ticketId\": \"0076\",\n       \"title\": \"QA report for ticket 0076\",\n       \"body_md\": \"# QA Report\\n\\n...\"\n     }\n   }\n   ```\n2. **Update ticket body** (optional) — If needed, include a tool call to update the ticket body:\n   ```json\n   {\n     \"tool\": \"update_ticket_body\",\n     \"params\": {\n       \"ticketId\": \"0076\",\n       \"body_md\": \"# Updated ticket body...\"\n     }\n   }\n   ```\n3. **Move ticket to Human in the Loop** — Include a tool call:\n   ```json\n   {\n     \"tool\": \"move_ticket_column\",\n     \"params\": {\n       \"ticketId\": \"0076\",\n       \"columnId\": \"col-human-in-the-loop\"\n     }\n   }\n   ```\n4. **Merge to main** — checkout `main`, merge the feature branch, push `main`.\n5. **Delete the feature branch** — local and remote (see `delete-branch-after-merge.mdc`).\n6. **Then** give your summary to the user. **The final message must include:** `QA RESULT: PASS — <ticket-id>` (see \"Completion message format requirement\" above).\n\n**If you are verifying from `main`** (implementation was merged to main for QA access):\n\n1. **Store QA report in Supabase** — Include a tool call in your message. Include a note in the report that verification was performed against `main`.\n2. **Update ticket body** (optional) — If needed, include a tool call to note that verification was performed against `main`.\n3. **Move ticket to Human in the Loop** — Include a tool call to move the ticket.\n4. **Then** give your summary to the user. **The final message must include:** `QA RESULT: PASS — <ticket-id>` (see \"Completion message format requirement\" above).\n\nDo not give a summary with \"next steps\" or \"run these commands\" — QA performs the merge (or confirms main) and branch deletion where applicable. The user receives the completed result.\n\n- Use a commit subject that includes the ticket ID (e.g. `qa(0033): add QA report, move to Human in the Loop`).\n- **If verdict is FAIL:** Do not merge. Store the QA report in Supabase, then **move the ticket to the top of To-do** (`col-todo` column) via HAL API. Summarize findings and recommend a bugfix ticket (see `bugfix-tracking.mdc`). **The final message must include:** `QA RESULT: FAIL — <ticket-id>` (see \"Completion message format requirement\" above).\n  \n  **FAIL workflow:**\n  1. **Store QA report in Supabase** — Include a tool call in your message:\n     ```json\n     {\n       \"tool\": \"insert_qa_artifact\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"title\": \"QA report for ticket 0076\",\n         \"body_md\": \"# QA Report\\n\\n...\"\n       }\n     }\n     ```\n  2. **Move ticket to To-do** — Include a tool call to move the ticket to `col-todo`:\n     ```json\n     {\n       \"tool\": \"move_ticket_column\",\n       \"params\": {\n         \"ticketId\": \"0076\",\n         \"columnId\": \"col-todo\"\n       }\n     }\n     ```\n     **Note:** The goal is to move failed tickets to the **top** of the To-do column for priority handling. The current move API (`/api/tickets/move`) appends tickets to the end of the column. If the API is enhanced in the future to support position parameters, use position 0 or a negative value to place at the top. For now, moving to `col-todo` satisfies the requirement even if it's at the end initially.\n  3. **Then** give your summary to the user. **The final message must include:** `QA RESULT: FAIL — <ticket-id>`.\n\n## HAL Tool Call Contract\n\nAll Supabase operations are sent to HAL as **tool calls** in your messages. HAL parses and executes them automatically.\n\n**Available tools:**\n\n- **`insert_qa_artifact`** — Store QA report in Supabase\n  - Params: `{ ticketId: string, title: string, body_md: string }`\n\n- **`update_ticket_body`** — Update ticket body in Supabase\n  - Params: `{ ticketId: string, body_md: string }`\n\n- **`move_ticket_column`** — Move ticket to different column\n  - Params: `{ ticketId: string, columnId: string }`\n\n- **`get_ticket_content`** — Fetch ticket content\n  - Params: `{ ticketId: string }`\n\n**How to use:** Include tool calls as JSON blocks in your messages. HAL will parse and execute them. You don't need API URLs or credentials.\n\nSee `.cursor/rules/agent-supabase-api-paradigm.mdc` for full documentation.\n\n## Scope\n\n- Applies to any QA or verification of a **ticketed** task (ticket in Supabase).\n- Keep the report concise; use bullets and tables where appropriate.\n- All artifacts are stored in Supabase, not in `docs/audit/` folders.",
      "agentTypes": [
        "all",
        "qa-agent",
        "implementation-agent"
      ],
      "topicId": "qa-audit-report",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "QA Audit Report",
        "description": "QA workflow, artifact verification, and report requirements",
        "agentTypes": [
          "qa-agent"
        ],
        "keywords": [
          "qa",
          "verification",
          "artifacts",
          "code review",
          "build"
        ]
      }
    },
    {
      "path": "scope-discipline.mdc",
      "name": "scope discipline",
      "description": "Prevent unrequested changes (scope discipline)",
      "alwaysApply": true,
      "content": "# Scope Discipline (No Unrequested Changes)\n\n- Implement **only** what the ticket requests.\n- Do not change styling/behavior “while you’re here” unless:\n  - it is required to satisfy an acceptance criterion, OR\n  - it fixes a bug introduced by the task, AND it is documented.\n\n## Required documentation when deviations are unavoidable\n\n- If you must make a change not explicitly requested:\n  - add it to the Decisions artifact in Supabase (stored via `POST /api/artifacts/insert-implementation` with `artifactType: \"decisions\"`) under **Unrequested changes (required)**:\n    - what changed\n    - why it was necessary\n    - how a human can verify it in the UI\n\n## Verification quality bar\n\n- The Verification artifact in Supabase (stored via `POST /api/artifacts/insert-implementation` with `artifactType: \"verification\"`) must include checks that confirm:\n  - the requested change works, AND\n  - adjacent UI did **not** regress (basic smoke checks).\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "scope-discipline",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Scope Discipline",
        "description": "Rules for staying within ticket scope and documenting deviations",
        "agentTypes": [
          "implementation-agent"
        ],
        "keywords": [
          "scope",
          "unrequested changes",
          "decisions"
        ]
      }
    },
    {
      "path": "submodule-sync.mdc",
      "name": "submodule sync",
      "description": "Submodule synchronization (when HAL has submodules)",
      "alwaysApply": true,
      "content": "# Submodule Sync Protocol\n\n## Global rules live in the HAL repo\n\n- The **only** authoritative global agent rules are in: `portfolio-2026-hal/.cursor/rules/`.\n- `projects/kanban` and `projects/hal-agents` are **normal directories** in the HAL repo (monorepo). Edit them directly; no submodule sync needed.\n- If HAL later adds other submodules (e.g. `projects/project-1`), they may contain a stub rule that points back here.\n\n## Context (0013)\n\n`portfolio-2026-hal` is a **monorepo**. Kanban and hal-agents are vendored under `projects/`:\n\n- `projects/kanban` — vendored (was submodule; now regular tracked files).\n- `projects/hal-agents` — normal directory (agents code; single source of truth).\n\nThere are **no git submodules** in HAL after 0013. Running `npm run dev` does not require `git submodule update`.\n\n## After Pushing to an External Repo (if you mirror)\n\nIf you maintain a separate mirror of kanban or hal-agents and push there, update that repo from HAL when needed. HAL is the source of truth; no submodule pointer to update in HAL.\n\n## Why This Matters\n\n- The HAL app embeds the kanban board from `projects/kanban`.\n- All code is in one repo; no sync step. Fresh clone + `npm install` (root and projects/kanban if needed) + `npm run dev` is enough.\n",
      "agentTypes": [
        "all"
      ],
      "topicId": "submodule-sync",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Submodule Sync Protocol",
        "description": "Global rules location and submodule handling",
        "agentTypes": [
          "all"
        ],
        "keywords": [
          "submodule",
          "rules",
          "monorepo"
        ]
      }
    },
    {
      "path": "task-sizing-and-in-app-debugging.mdc",
      "name": "task sizing and in app debugging",
      "description": "Task sizing, verifiability, and in-app debugging (no console)",
      "alwaysApply": true,
      "content": "# Task Sizing + Verifiable Output\n\n- Every coding task assigned to an agent must be as small as possible.\n- The limiting factor on shrinking tasks/stories is that **each task must result in a human-verifiable change to the app**.\n- Verification must require **no external tools** (no terminal, no devtools console, no logs).\n- Prefer acceptance criteria phrased as: “A human can click/see X in the UI and confirm Y.”\n\n# In-App Debugging Requirement\n\n- The app must include whatever **in-app debugging/diagnostics UI** we need to understand failures.\n- Do **not** rely on console output or logs for debugging during normal verification.\n\n# Role Constraint (for now)\n\n- In this phase, act as a **project manager**:\n  - do not implement code directly\n  - help organize thoughts and write prompts for other agents\n",
      "agentTypes": [
        "all",
        "project-manager"
      ],
      "topicId": "task-sizing-and-in-app-debugging",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Task Sizing + Verifiable Output",
        "description": "Task sizing requirements and in-app debugging needs",
        "agentTypes": [
          "project-manager"
        ],
        "keywords": [
          "task sizing",
          "debugging",
          "verification"
        ]
      }
    },
    {
      "path": "ticket-writing-sync-tickets.mdc",
      "name": "ticket writing sync tickets",
      "description": "Supabase-backed Kanban — ALWAYS update tickets in the DB first, then run sync (all agents)",
      "alwaysApply": true,
      "content": "# Ticket Source of Truth: Supabase Only (All Agents)\n\nWe use a **Supabase-backed Kanban** in **Supabase-only mode** (0065). Ticket state (content, column, position) lives in the database. The app and agents **do not read from `docs/tickets/*.md`** — tickets are fetched directly from Supabase.\n\n- **Do not create or edit ticket files** under `docs/tickets/` directly. The app does not read these files (Supabase-only mode).\n- **To create or change a ticket (any agent):** use **HAL API endpoints**:\n  - **Create / update body:** Use the HAL PM agent (create_ticket / update_ticket_body tools) or HAL API endpoint `POST /api/tickets/update`. The Kanban UI reflects changes within the polling interval (~10s).\n  - **Move ticket column (e.g. QA → Human in the Loop):** Use HAL API endpoint `POST /api/tickets/move` with `{ ticketId: string, columnId: string }`. The API uses server-side Supabase credentials.\n- **HAL API endpoints:** All Supabase operations go through HAL's API endpoints, which use server-side environment variables (`SUPABASE_URL`, `SUPABASE_ANON_KEY`). Agents don't need credentials in their environment.\n  - `POST /api/tickets/get` — Fetch ticket content\n  - `POST /api/tickets/update` — Update ticket body\n  - `POST /api/tickets/move` — Move ticket to different column\n  - `POST /api/artifacts/insert-implementation` — Store implementation artifacts\n  - `POST /api/artifacts/insert-qa` — Store QA artifacts\n- **`sync-tickets.js` is migration-only (0065):** The script no longer writes to `docs/tickets/*.md`. It can be used for one-time migration of existing files to Supabase (Docs→DB only).\n- **Never commit `.env`** (it must remain ignored).\n",
      "agentTypes": [
        "all",
        "project-manager"
      ],
      "topicId": "ticket-writing-sync-tickets",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "Ticket Source of Truth",
        "description": "Supabase-backed ticket management and sync requirements",
        "agentTypes": [
          "project-manager"
        ],
        "keywords": [
          "tickets",
          "supabase",
          "kanban",
          "sync"
        ]
      }
    },
    {
      "path": "typescript-build-verification.mdc",
      "name": "typescript build verification",
      "description": "TypeScript compilation and build verification requirements (non-negotiable)",
      "alwaysApply": true,
      "content": "# TypeScript Build Verification (Non-Negotiable)\n\n**CRITICAL:** All implementation work must pass TypeScript compilation and build verification before being marked \"ready for QA\". This is **non-negotiable** and prevents Vercel deployment failures.\n\n## Mandatory Verification Steps\n\n**Before claiming \"ready for QA\" or \"done\", the implementation agent MUST:**\n\n1. **Run TypeScript compilation check:**\n   ```bash\n   npm run build:hal\n   ```\n   OR\n   ```bash\n   tsc -b\n   ```\n\n2. **Verify zero TypeScript errors:**\n   - The command must complete with exit code 0\n   - No TypeScript errors may be present in the output\n   - All type errors must be fixed before proceeding\n\n3. **Verify build succeeds:**\n   - `npm run build:hal` must complete successfully\n   - This ensures Vercel deployments will succeed\n\n## When to Run Verification\n\n- **Before committing:** Run TypeScript check after code changes\n- **Before pushing:** Verify build passes before pushing to remote\n- **Before marking \"ready\":** Final verification must pass before claiming \"ready for QA\"\n- **In Verification artifact:** Document that TypeScript compilation passed with zero errors\n\n## Failure Handling\n\n**If TypeScript errors exist:**\n- **STOP** — Do not commit, push, or claim \"ready\"\n- Fix all TypeScript errors\n- Re-run verification until it passes\n- Only then proceed with commit/push/ready workflow\n\n**If build fails:**\n- **STOP** — Do not commit, push, or claim \"ready\"\n- Fix the build errors\n- Re-run verification until it passes\n- Only then proceed with commit/push/ready workflow\n\n## Verification Artifact Requirement\n\nThe Verification artifact **must** include:\n- Confirmation that `npm run build:hal` (or `tsc -b`) was run\n- Confirmation that it completed with **zero TypeScript errors**\n- Confirmation that the build succeeded\n\n**Example:**\n```markdown\n## Automated Checks\n- ✅ TypeScript compilation: `npm run build:hal` completed with zero errors\n- ✅ Build: `npm run build:hal` succeeded\n- ✅ Linter: No errors\n```\n\n## Why This Matters\n\n- **Vercel deployments fail** if TypeScript errors exist\n- **Build failures block** deployment and prevent user testing\n- **Type safety** prevents runtime errors\n- **Consistency** ensures all code is properly typed\n\n## Commands Reference\n\n- **TypeScript check:** `npm run build:hal` or `tsc -b`\n- **Full build:** `npm run build:hal` (includes TypeScript + Vite build)\n- **Agents only:** `npm run build:agents` (TypeScript check for agents code)\n\n## Summary\n\n**NON-NEGOTIABLE:** TypeScript compilation must pass with zero errors before any work is marked \"ready for QA\". Build must succeed. No exceptions.\n",
      "agentTypes": [
        "all",
        "implementation-agent"
      ],
      "topicId": "typescript-build-verification",
      "isBasic": false,
      "isSituational": true,
      "topicMetadata": {
        "title": "TypeScript Build Verification",
        "description": "Mandatory TypeScript compilation checks before marking ready",
        "agentTypes": [
          "implementation-agent",
          "qa-agent"
        ],
        "keywords": [
          "typescript",
          "build",
          "compilation",
          "verification"
        ]
      }
    }
  ]
}